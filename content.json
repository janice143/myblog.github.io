{"pages":[],"posts":[{"title":"【python】清理重复图片","text":"引言本文解释如何编写python脚本，实现重复图片清理的功能。 正文MD5,Message-Digest Algorithm，信息摘要算法，是一种信息加密算法，可以把任意长度的数据转换为一个长度固定的数据串（通常是16进制的字符串表示）。一个图片文本的本质是一个数据串，所以要想清理重复图片，就是要匹配到相同的数据串的两张图片，使用DM5的目的是将图片的数据串统一，如果两张图片经过MD5算法变换后的数据串相同，则可判断这两种图片重复。 以计算一个字符串的MD5值为例，代码如下： 12345import hashlibmd5 = hashlib.md5()md5.update('how to use md5 in python hashlib?'.encode('utf-8'))print(md5.hexdigest()) 计算结果为 1d26a53750bc40b38b65a520292f69306 参考网站：廖雪峰老师博客中摘要算法简介 本文的脚本的思路如下：1 遍历文件夹下的图片文件2 把图片文件记录到一个字典变量中3 生成所有图片文件的MD5值4 把MD5值存放到一个新的字典变量中5 判断如果已经存放，则该图片为重复图片，删除即可 选取文件夹，遍历文件夹下所有的文件123456inpath = &quot;G:/最新/照片/2018-2019年照片备份/2021年&quot;for path,dir,filelist in os.walk(inpath): for filename in filelist: # print(filename) allfile.append(os.path.join(path,filename)) 获取MD5值123456fd = open(file,'rb')md5 = hashlib.md5()md5.update(fd.read())fd.close()return md5.hexdigest() 根据MD5值比较123456for photo in allfile: md5sum = getmd5(photo) if md5sum not in md5list: md5list.append(md5sum) else: identicallist.append(photo) 删除重复照片12for idenPhoto in identicallist: os.remove(idenPhoto) 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/09/02/%E3%80%90python%E3%80%91%E6%B8%85%E7%90%86%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87/"},{"title":"配置连接github","text":"复制代码配置身份，不正确会影响贡献度统计 12git config --global user.email &quot;A175A174@gmail.com&quot;git config --global user.name &quot;A175A174&quot; 配置 ssh 链接，一路回车，打开提示目录下 id_rsa.pub复制到 https://github.com/settings/keys 点击 New sshKey，Title 可以不写 1ssh-keygen -t rsa -C &quot;A175A174@email.com&quot; 验证 ssh 是否成功Hi A175A174! You’ve successfully authenticated, but GitHub does not provide shell access 1ssh -T git@github.com","link":"/myblog.github.io/2021/08/20/%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5github/"},{"title":"【程序】我是如何建立我的第一个博客网站的？","text":"写在前面我从大二开始喜欢上写程序，也从那开始自学了很多编程语言。当我第一次接触到前端开发的时候，那些由多个不同后缀名组成的项目，让我觉得又新奇（第一次见这种编程语言，太有特色了），同时又恐惧（这么多个编程语言组成，我能学会吗）。 大二是我人生阶段最迷茫的一段时间，不想上课，不想和人交往。但是我生来好像就有股向上的劲头，即使每天很颓废，也告诫自己做点有用的事情，做点有用的事情。所以我那段时间学了很多编程语言，虽然是迷迷糊糊学了很多语言，走了很多弯路。 好在我也勉勉强强地学了前端开发，我记得那段时间我先是在网上看了一个教学视频，然后就开始自己动手捣鼓做起了第一个个人网站，花了一天一夜的时间。 大三开始我稳定地在实验室跟着一个老师做科研，便没有时间再去学写程序。 大四基本上是在做创新创业比赛，更没有时间写程序了。 但是大二以后的整个过程，我总是偶尔地问自己：当初我为何要学写这么多程序？我大二整整一年的时间都花在自学程序上，感觉就这么放弃有点太不值得？自学程序有用吗以后？ 现在我也不知道学的程序有没有用，但是就是因为当初花了一年时间起步，不甘心没有一点收获地戛然而止。所以我，到了大四暑假的末尾，研一马上要开学，要重新拾起我以前学的东西，好好做下去，希望能做出点东西。 自学编程的时候听到最多、最有用的建议就是要多做实战，而对于前端开发来讲，第一个要做的实战就是建立自己的个人网站，第二个就是建立个人博客。所以在建立好自己的第一个网站，一年后，也就是现在，我开始建个人博客，并且立下不倒的flag，这个网站将会见证我一点一滴的成长（未来我的生活琐事，学习曲线等奖全部记录记录在这里），是我人生中一笔宝贵的财富，我一定会好好经营。 正文一、找资料一般开始一个新东西，第一步肯定是找资料，毕竟光想是想不出来的。我找的第一个资料就是B站Up主CodeSheep的一个视频手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo：https://www.bilibili.com/video/BV1Yb411a7ty 在看这个视频的过程中，我有很多疑惑（为什么要下载node.js,在cmd下建文件夹是怎么回事等等），所以也会找其他资料使用hexo+github搭建免费个人博客详细教程：https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.htmlhexo5分钟免费搭建个人博客教程：https://www.jianshu.com/p/722fe57ef163 结合视频，以及文本资料，我的很多疑惑都消除了，接下来我便可以自己动手尝试了。 二、下载软件，准备环境1.安装好node.js（最好下载Windows 安装包 (.msi)，在安装过程中会配置好路径，用zip文件还要自己手动配置，特别容易报错） 和 Git 2.在das窗口下输入命令 node -v和 npm -v，检验hexo运行环境 3.git安装完成后的检验操作是：鼠标右键。会出现git GUI here 和git bash here 三、使用hexo框架搭建静态博客1.安装 hexo 框架 1npm install -g hexo 2.在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\\程序\\html_codes\\janiceBlog，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 3.cmd窗口下切换到janiceBlog文件夹路径，然后输入一下代码： 1hexo init # 初始化 hexo会自动下载一些文件到这个目录，包括node_modules 12hexo g # 生成hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。hexo s是开启本地预览服务，打开浏览器访问http://localhost:4000即可看到内容 4.修改主题可以再官网选一个好看的主题以yilia主题为例，在博客路径下，输入一下命令: 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布 四、上传到github1.配置_config.yml中有关deploy的部分： 1234deploy: type: git repository: git@github.com:janice143/iainsBlog.git branch: master 2.打开博客文件夹，右键选择git bash here，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会(部署这个命令一定要用git bash,不要在cmd下，不然会报错) 五、上传到GitHub出现一些错误错误1： hexo + github pages搭建博客，本地server成功，部署到github上之后样式加载不出来解决：需要修改根目录_config.yml文件中的url地址和根目录 123456##If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://janice143.github.io/myblog.github.io/root: /myblog.github.iopermalink: :year/:month/:day/:title.htmlpermalink_defaults: url 是GitHub pages给我们分配的网址root是搭建该博客的仓库名 最后重新部署上传就可以了 123hexo cleanhexo ghexo d 错误2：修改默认头像解决：在主题的yilia文件夹的img文件夹里放上头像图片，然后修改yilia文件夹下的_config.yml文件 12#你的头像urlavatar: /myblog.github.io/img/me.JPG 六、写博客1.定位到我们的博客目录，执行命令： 1hexo new “博客名自己取” 2.markdown格式编写规则参考：http://www.mdeditor.com/","link":"/myblog.github.io/2020/09/11/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%EF%BC%9F/"},{"title":"【原生javascript项目】Real time clock 02","text":"引言本文利用javascript写一个实时显示时间的时钟特效网页。 网址为(https://janice143.github.io/realTImeClock/) 正文1网页布局与功能 网页主体为一个时钟，具有表盘（12个数字）和三个指针（时针、分针、秒针）。 2实现原理一、 html代码 使用一个类名为clock为的div容器，里面包含时针.hour-hand,分针.minute-hand,秒针second-hand，以及12个数字。 12345678910111213141516171819202122&lt;div class=&quot;clock&quot;&gt; &lt;div class=&quot;hour-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;minute-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;second-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;number&quot;&gt; &lt;span class=&quot;num12&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;num1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;num2&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;num3&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;num4&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;num5&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;num6&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;num7&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;num8&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;num9&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;num10&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;num11&quot;&gt;11&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 二、css代码 1 先让时钟显示在页面的中部（垂直居中，水平居中），这可以用个在clock的上一级词main中设置flex容器。 12345678#main{ display: flex; min-height: 100vh; align-items: center; justify-content: center;} 2 时钟的表盘的样式 1234567.clock{ width: 300px; height: 300px; border-radius: 300px; border: 20px solid white; position: relative;} 3 指针的样式 指针旋转的特效是由transfrom：rotate(deg)实现的（本文这里是通过js代码后面再设置的）。transform-origin默认是50%，元素会绕着中间旋转，设置成100%后，元素绕着一端旋转。transition-timing-function是设置过渡的时间函数特效，不设置是默认均匀地过渡。 1234567891011121314151617.hand{ width: 120px; height: 6px; background-color: blueviolet; position:absolute; top:148px; right: 148px; transform-origin: 100%; transition:all 0.05s; transition-timing-function: cubic-bezier(0.1, 2.7, 0.58, 1);}.hour-hand{ width: 100px;}.second-hand{ height: 4px;} 4 12个数字的样式 先给数字设置相对定位，相对于上一级.number。然后再给每个数字设置相应的top和left. 数字位置算法为： num=2; top=135sin((num-3)30/180pi)+135； left=135cos((num-3)30/180pi)+135 （num为1-12的数字） 1234567891011.number{ width: 300px; height:300px; font-size: 15px; position:absolute; top:0px; right: 0px;} 三、 javascript代码 分别获取时针、分钟、秒针的类名，然后通过当前时间给三个指针分配正确的旋转角度。 1 秒针： parseInt(second/60*360)+90; 2 分针： parseInt(minute/(60)*360+second/10)+90; 3 时针：parseInt(hour/(12)*360+minute/(60)*30)+90; +90度是因为设置指针css样式的时候，指针都在指在9点钟的位置，+90度可让指针从12点为起始点旋转。 设置为指针的角度后，利用定时器每隔一秒刷新指针的位置，这样就可以达到实时显示的效果。 当指针转弯一圈后，重新运行设置时间函数 setDate()重置指针的角度。 123456789101112131415161718192021222324252627// 获取指针的transform样式，从而让其旋转 const secondHand = document.querySelector('.second-hand'); const minuteHand = document.querySelector('.minute-hand'); const hourHand = document.querySelector('.hour-hand'); const audio = document.querySelector('audio'); // 获取当前时间，从时间里设置指针 function setDate(){ const time = new Date(); const second = time.getSeconds(); const secondDeg = parseInt(second/60*360)+90; secondHand.style.transform = `rotate(${secondDeg}deg)`; const minute= time.getMinutes(); const minuteDeg = parseInt(minute/(60)*360+second/10)+90; minuteHand.style.transform = `rotate(${minuteDeg}deg)`; const hour= time.getHours(); const hourDeg = parseInt(hour/(12)*360+minute/(60)*30)+90; hourHand.style.transform = `rotate(${hourDeg}deg)`; } // 设置定时器美隔一秒时间进行刷新页面 setInterval(setDate,1000); // setDate(); // 当指针转一圈后，重置度数 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/12/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Real-time-clock-02/"},{"title":"【原生javascript项目】Image Procession with Javascipt 03","text":"引言本文利用javascripts更新css变量，实现一个简易的图像处理网页。对于图像处理部分，本网页可调节图像的边框宽度、模糊度以及边框颜色值。 网址为(https://janice143.github.io/imageProcessionwithJS/) 正文1 页面布局 页面分为三部分：标题、三个input组成的控件、图像 通过调节三个Input的值，可以实现对外边距、模糊值和颜色的改变。 一、html代码 1 标题 123456&lt;h2&gt;利用&lt;span class=&quot;text-color&quot;&gt;JS&lt;/span&gt;更新CSS自定义变量&lt;/h2&gt; &lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt;&lt;/div&gt; 2 三个input值 12345678910&lt;div class=&quot;controlers&quot;&gt; &lt;label for=&quot;spacing&quot;&gt;外边距:&lt;/label&gt; &lt;input id=&quot;spacing&quot; type=&quot;range&quot; name=&quot;spacing&quot; value=&quot;10&quot; data-unit=&quot;px&quot;&gt; &lt;label for=&quot;blur&quot;&gt;模糊值:&lt;/label&gt; &lt;input id=&quot;blur&quot; type=&quot;range&quot; name=&quot;blur&quot; value=&quot;10&quot; data-unit=&quot;px&quot;&gt; &lt;label for=&quot;color&quot;&gt;底色:&lt;/label&gt; &lt;input id=&quot;color&quot; type=&quot;color&quot; name=&quot;color&quot; value=&quot;#fecc00&quot;&gt;&lt;/div&gt; data-unit=”px”是自己设置的dataset(数据集合)。input的type类型和对应效果如图。 input的id名字一般和name一样。 3 图像 1&lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt; 二、css代码 1 css变量 变量声明：在选择器里（任何选择器），变量名前面要加两根连词线（--）。本文里在:root根元素里声明，这是全局变量的声明方式，保证任何选择器都可以使用。变量名大小写敏感。 12345678img{ margin-top:50px; width:600px; height: 375px; padding: var(--spacing);/* var函数获取变量 */ background-color: var(--color); filter:blur(var(--blur));} 读取变量：利用var()函数读取 12345 :root{ --color:#fecc00; --spacing:10px; --blur:10px;} css变量参考网址：（https://www.ruanyifeng.com/blog/2017/05/css-variables.html） 三、javascript代码 1 suffix中文意思为 后缀。在js代码中，设置了一个suffix变量，这是因为spacing和blur的值在css中需要加上px单位，而color的值没有，所以使用了||逻辑运算。 2 this.dataset需要注意一下，在html代码中，我们设置了自定义了data-unit数据，this.dataset会取出所有自定义的数据集，比如你可以在Html中设置data-key(回想起前几天的js程序）,data-name,data-poo任何数据名字，因为是自定义。this.dataset.unit是本文在html代码中提前设置好的。 3 document.documentElement用来获取当前文档的直接子节点，对于Html文档而言，一般是。 4 style.setProperty(propertyName, value);给css样式某个属性名propertyName赋一个新值value。 5 --${this.name}为模板字面量，可以嵌入表达式的字符串字面量，${}表示一个占位符。一般的字符串是用单引号或者双引号标注的，这些字符串之间没有任何区别，而模板字面量则可以通过一个占位符来进行插值，模板字面量用反引号``实现。 6 箭头函数优点：剪短、this指向函数定义生效时所在对象。 函数声明：关键字、函数名、参数、函数体 123function functionName ([arg1 [,arg2 [...,argn]]]) { // functionBody 函数体} 没有函数名时，函数为匿名函数 1234const square = function (number) { return number * number;};// 相当于箭头函数：number=&gt;number*number; 具名函数由函数名，而且函数内部可以代指本身（迭代函数使用） 123const factorial = function fac(n) { return n &lt; 2 ? 1 : n * fac(n - 1);};console.log(factorial(3));var x = square(4);// x 得到的值为16 箭头函数；如果函数体只有一个表达式，可以不用{}符号 123const fn = () =&gt; { // do something}; 1234567// 获取Input的value，并且将value赋值给cssconst inputs = document.querySelectorAll('.controlers input');function updateValue(){ const suffix = this.dataset.unit || ''; // 给blur和spacing加单位 document.documentElement.style.setProperty(`--${this.name}`,this.value + suffix);}inputs.forEach(input=&gt;input.addEventListener('change',updateValue)); 结论完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/13/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Image-Procession-with-Javascipt-03/"},{"title":"【python】定时健康打卡网站打卡发送邮箱","text":"引言本文介绍如何编写python脚本，实现网站自动、定时健康打卡功能，打卡成功后截取当前屏幕信息，并通过发送邮件告知对方已经打卡成功。 正文思路：1 package 安装2 实现网站打卡功能3 保存当前网站截图4 发送邮件5 定时运行程序 package 安装Selenium安装 1pip install selenium ChromeDriver下载：下载与本机安装的Chrome浏览器的版本相同的ChromeDriver.exe，并放在python安装路径下的scripts路径下。 实现网站打卡功能打开浏览器，进入网站搜索 123browser = webdriver.Chrome()browser.get('这里填你要打卡的网站地址')time.sleep(2) 通过find_element_by_xpath来定位用户名和密码的输入框，并输入用户名和密码 1234uid = '你的用户名'pwd = '密码'browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[4]/input&quot;).send_keys(uid)browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[5]/input&quot;).send_keys(pwd) 通过find_element_by_xpath来定位登录输入框，并点击回车键 1browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[7]/input&quot;).send_keys(Keys.ENTER) 点击健康打卡 123click_btn = browser.find_element_by_xpath(&quot;//*[@id='apply-content']/div[2]/ul[1]/li[2]&quot;)ActionChains(browser).click(click_btn).perform()# time.sleep(2) 点击填报 12click_btn2 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[4]/button&quot;)ActionChains(browser).click(click_btn2).perform() 点击 我知晓 12click_btn3 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[51]/div[1]/input&quot;)ActionChains(browser).click(click_btn3).perform() 点击上报 12click_btn4 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[52]&quot;)ActionChains(browser).click(click_btn4).perform() 截屏并保存，保存当前网站截图打卡成功后，我想保留当前网页的截图，作为打卡成功的凭证 1browser.get_screenshot_as_file(&quot;success.png&quot;) 退出浏览器 1browser.quit() 发送邮件通过发送邮件的方式，通知对方已经成功打卡。 准备用于发送信息、接收信息的邮箱 123MAIL_USER = &quot;邮箱地址&quot; # 用于发送通知的邮箱MAIL_PASS = &quot;授权码&quot; # 授权码，注意不是邮箱登录密码！！mail_to = &quot;接收信息的邮箱&quot; 发送带有图片附件images和正文mail_text的邮件 12345678910111213141516msg = MIMEMultipart()mail_text = &quot;已经成功打卡！&quot;mail_body = MIMEText(mail_text)# 设置邮件主题、发送方和接收方msg['Subject'] = &quot;每日健康打卡通知&quot;msg['From'] = MAIL_USERmsg['To'] = mail_tomsg.attach(mail_body)# 添加截图附件fp = open(&quot;success.png&quot;, 'rb')images = MIMEImage(fp.read())fp.close()images.add_header('Content-Disposition', 'attachment', filename='success.png')msg.attach(images) 登陆并发送邮件(我这里是用163邮箱) 123456smtp = smtplib.SMTP()smtp.connect('smtp.163.com')smtp.login(MAIL_USER, MAIL_PASS)smtp.sendmail(MAIL_USER, mail_to, msg.as_string())smtp.quit() 定时运行程序通过使用Win10自带的“任务计划程序”来设置运行编写的.py脚本，设置步骤如下： 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/08/20/%E3%80%90python%E3%80%91%E5%AE%9A%E6%97%B6%E5%81%A5%E5%BA%B7%E6%89%93%E5%8D%A1%E7%BD%91%E7%AB%99%E6%89%93%E5%8D%A1%E5%8F%91%E9%80%81%E9%82%AE%E7%AE%B1/"},{"title":"【原生javascript项目】Piano-Kit-01","text":"引言本文介绍如何用javascripty语法写一个简单的琴键(drum ang piano)网页，通过敲击特定键盘（音键），可以发出不同音调。 网址为(https://janice143.github.io/musicKit.github.io/) 正文1网页布局与功能 网页整体分为3个部分： 1是最顶上居中排布的乐器切换(Drum Kit, Piano Kit)组块，选中响应的kit，背景图和琴键切换为响应的内容，同时kit字体变为白色； 2是页面居中排布的琴键； 3是背景图。 琴键可以通过鼠标点击或者按下响应的键盘来操作，可以发出对应的音效（黄色字体表示音效的名称）。琴键被点击按下后，加以一定的css动画（黄色高亮边框）来区分。 2实现原理一、 html代码 1 乐器切换组块： 1234&lt;div id=&quot;switch&quot;&gt; &lt;a class=&quot;drum chosen&quot; href=&quot;#&quot; onclick=&quot;addChosenDrum()&quot;&gt;Drum Kit&lt;/a&gt; &lt;a class=&quot;piano&quot; href=&quot;#&quot; onclick=&quot;addChosen()&quot;&gt;Piano Kit&lt;/a&gt;&lt;/div&gt; 2 Drum Kit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=&quot;pianoKit&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key1 key&quot; &gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(65)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;A&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;DO&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key2 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(83)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;S&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;RE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key3 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(68)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;D&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;MI&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key4 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(70)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;F&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;FA&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key5 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(71)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;G&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SOL&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key6 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(72)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;H&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;LA&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(74)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;J&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SI&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;audio data-key=&quot;65&quot; src=&quot;sounds/1.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;83&quot; src=&quot;sounds/2.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;68&quot; src=&quot;sounds/3.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;70&quot; src=&quot;sounds/4.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;71&quot; src=&quot;sounds/5.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;72&quot; src=&quot;sounds/6.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;74&quot; src=&quot;sounds/7.MP3&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 3 Piano Kit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;div id=&quot;drumKit&quot; class=&quot;chosen&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key1 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(65)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;A&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;CLAP&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key2 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(83)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;S&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;HIHAT&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key3 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(68)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;D&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;KICK&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key4 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(70)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;F&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;OPENHAP&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key5 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(71)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;G&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;BOOM&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key6 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(72)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;H&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;RIDE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(74)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;J&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SNARE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;75&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(75)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;K&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;TOM&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;76&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(76)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;L&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;TINK&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;audio data-key=&quot;65&quot; src=&quot;sounds/clap.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;83&quot; src=&quot;sounds/hihat.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;68&quot; src=&quot;sounds/kick.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;70&quot; src=&quot;sounds/openhat.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;71&quot; src=&quot;sounds/boom.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;72&quot; src=&quot;sounds/ride.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;74&quot; src=&quot;sounds/snare.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;75&quot; src=&quot;sounds/tom.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;76&quot; src=&quot;sounds/tink.wav&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 二、css代码 1 实现顶部的切换组块（Drum Kit, Piano Kit)固定在窗口的某个位置，不占位置，脱离标准文档流；居中排布 1234position: fixed;left:0; right:0; margin:0 auto; 2 实现琴键居中排布：用Flex 布局实现垂直、水平居中。 任何一个容器都可以指定为 Flex 布局（flex容器），display: flex即可实现。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”Item”。 容器具有6个属性： · flex-direction:水平主轴的方向 · flex-wrap:如果主轴拍不下，可以用这个属性来设置换行的形式 · flex-flow:合并了flex-direction 和flex-wrap的功能，用这个属性可以同时设置这两个属性。 · justify-content:定义了item在主轴（水平方向上）的对齐方式 ·align-items：定义了item在垂直方向上的对齐方式 · align-content：定义了多跟轴线的对齐方式 123456789#drumKit,#pianoKit{ /* background-color: red; */ /* 在需要垂直居中的父元素上，设置display:flex和align-items：center。要求：父元素必须显示设置height值 */ display: flex; flex:1; min-height: 90vh; /*vh 就是当前屏幕可见高度的100% align-items: center; /*子元素水平居中*/ justify-content: center; /*子元素垂直居中*/} 90vh表示占窗口（当前页面窗口）大小的90%。 3 键盘被点击时，js会添加playing类，其css布局为 12345.playing{ transform: scale(1.1); border-color: #ffc600; box-shadow: 0 0 1rem #ffc600;} 4 drum kit 和piano kit被选中时，js会添加chosen类名。设置css代码让选中字体变为白色以区分 123#switch .chosen{ color:white;} 三、 javascript代码 1 切换键盘(drum kit, piano kit) 对于drum kit：点击drum，添加.chosen，同时去掉piano kit 的.chosen类名；显示drum琴键，隐藏piano琴键；显示响应背景background-image。 12345678910111213141516171819202122232425262728293031// 点击a标签，切换键盘:点击piano键盘，添加chosen class，去掉drum的class; 显示对应的piano键盘;在对应的键盘中添加chosen，这样audio也可以对应 function addChosen(){ const chosen = document.getElementsByClassName(&quot;piano&quot;); const notChosen = document.getElementsByClassName(&quot;drum&quot;); chosen[0].classList.add('chosen'); notChosen[0].classList.remove('chosen'); const notChosenKit = document.getElementById(&quot;drumKit&quot;); notChosenKit.classList.remove('chosen'); notChosenKit.style.display = &quot;none&quot;; const chosenKit = document.getElementById(&quot;pianoKit&quot;); chosenKit.style.display = &quot;flex&quot;; chosenKit.classList.add('chosen'); // 换钢琴壁纸 const wallpaper = document.getElementsByTagName(&quot;html&quot;); wallpaper[0].style.backgroundImage=&quot;url(./pianoback.jpg)&quot;; } function addChosenDrum(){ const chosen = document.getElementsByClassName(&quot;drum&quot;); const notChosen = document.getElementsByClassName(&quot;piano&quot;); chosen[0].classList.add('chosen'); notChosen[0].classList.remove('chosen'); const notChosenKit = document.getElementById(&quot;pianoKit&quot;); notChosenKit.classList.remove('chosen'); notChosenKit.style.display = &quot;none&quot;; const chosenKit = document.getElementById(&quot;drumKit&quot;); chosenKit.style.display = &quot;flex&quot;; chosenKit.classList.add('chosen'); // 换鼓壁纸 const wallpaper = document.getElementsByTagName(&quot;html&quot;); wallpaper[0].style.backgroundImage=&quot;url(./drumback.jpg)&quot;; } 2 键盘敲击琴键，用keycode标注，给对应琴键添加.playing类名。设置audio.play发出音效。 1234567891011// 点击键盘字母时，对应的键添加class属性function playSound(e){ const audio = document.querySelector(`.chosen audio[data-key=&quot;${e.keyCode}&quot;]`); // console.log(audio); if (!audio) return; const key = document.querySelector(`.chosen div[data-key=&quot;${e.keyCode}&quot;]`); key.classList.add('playing');//添加playing类属性 audio.currentTime = 0; //音频重头播放 audio.play();} 3 如果连续敲击多个琴键，多个琴键都会显示过渡特效（黄色Border,放大1.2倍），为了让最后一个琴键之前的琴键过滤样式去掉，可以利用transitionend事件，让已经过渡的琴键去掉.playing类名。 12345678910// 去掉playing 类属性function removeTransition(e){ if (e.propertyName !='transform') return; this.classList.remove('playing');}const keys = document.querySelectorAll('.key');keys.forEach(key=&gt;key.addEventListener('transitionend',removeTransition));window.addEventListener('keydown',playSound); 4 鼠标点击也可以实现琴键发出音效。设置onclick事件，传入keycode参数。 1234567891011function clickPlaySound(keycode){ // data-key=keycode; const audio = document.querySelector(`.chosen audio[data-key=&quot;${keycode}&quot;]`); if (!audio) return; const key = document.querySelector(`.chosen div[data-key=&quot;${keycode}&quot;]`); key.classList.add('playing');//添加playing类属性 audio.currentTime = 0; //音频重头播放 audio.play(); // console.log(audio); }; 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Piano-Kit-01/"},{"title":"【原生javascript项目】数组操作 04","text":"引言本文介绍一下数组操作的一些常用方法。 正文1创建数组1234567const people = ['Bernhard, Sandra', 'Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd', 'Beckett, Samuel', 'Blake, William', 'Berger, Ric', 'Beddoes, Mick', 'Beethoven, Ludwig','Belloc, Hilaire', 'Begin, Menachem', 'Bellow, Saul', 'Benchley, Robert', 'Blair, Robert', 'Benenson, Peter', 'Benjamin, Walter', 'Berlin, Irving','Benn, Tony', 'Benson, Leana', 'Bent, Silas', 'Berle, Milton', 'Berry, Halle', 'Biko, Steve', 'Beck, Glenn', 'Bergman, Ingmar', 'Black, Elk', 'Berio, Luciano','Berne, Eric', 'Berra, Yogi', 'Berry, Wendell', 'Bevan, Aneurin', 'Ben-Gurion, David', 'Bevel, Ken', 'Biden, Joseph', 'Bennington, Chester', 'Bierce, Ambrose','Billings, Josh', 'Birrell, Augustine', 'Blair, Tony', 'Beecher, Henry', 'Biondo, Frank']; 2 获取数组长度1console.log(people.length); 3循环123people.forEach(function(item,index){ console.log(item,index);}) 4 数据尾部添加一个元素12let newLength = people.push('Wheeler, Ben');// newLength的结果是people的长度，不是新添加的元素内容console.log(people.length); 5 从尾部删除一个元素12let last = people.pop();console.log(people.length); 6 从头部删除一个元素12let first = people.shift();console.log(people.length); 7 从提添加一个新元素12let firstItem = people.unshift('Bernhard, Sandra');console.log(people); 8 寻找下标12let pos = people.indexOf('Blair, Tony');console.log(pos); 9 根据下标删除元素12let removeItem = people.splice(pos,1);//参数1表示Pos下标后多少个console.log(removeItem); 10 复制数组1234// 复制数组 1let newPeople1 = people; //people和newPeople1指向同一个内存// 复制数组 2let newPeople2 = people.slice(); // people和newPeople1指向不同一个内存 11 Index超出数组长度12people[100] = 'bbb';console.log(people); 12 Array.prototype.filter() 过滤12const fifteen = inventors.filter(inventor=&gt;(inventor.year&gt;=1500 &amp;&amp; inventor.year &lt; 1600));console.table(fifteen); 13 Array.prototype.map()12345const fullNames = inventors.map(inventor =&gt; (inventor.first + ' ' + inventor.last));const fullNames2 = inventors.map(inventor =&gt; `${inventor.first} ${inventor.last}`);console.log(fullNames);console.log(fullNames2); 14 Array.prototype.sort()12345678910// 升序const ordered = inventors.sort((a,b) =&gt; a.year &gt; b.year ? 1 : -1);console.table(ordered);// 降序const oldest = inventors.sort(function(a,b){ const lastInventor = a.passed - a.year; const nextInventor = b.passed - b.year; return lastInventor &gt; nextInventor ? -1:1;});console.table(oldest); 15 Array.prototype.reduce() 结果返回单个值123456// Array.prototype.reduce() 结果返回单个值const totalYears = inventors.reduce((total,inventor) =&gt; { return total + (inventor.passed - inventor.year);}, 0); // 0表示返回的单个值再加上0console.log(totalYears); 结论完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/15/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C-04/"},{"title":"【原生javascript项目】 Flex Panel 05","text":"引言本文介绍一个动态放映网页，知识点主要涉及到flex容器，以及元素点击事件。 效果网站：https://janice143.github.io/flexPanel/ 正文一、html部分主要为5个div元素将网页分为5块，横向排列。每一个div元素中有上中下三个p标签，对应3段话。 123456789101112131415161718192021222324252627&lt;div class=&quot;panels&quot;&gt; &lt;div class=&quot;panel1 panel&quot; onclick=&quot;clickOpen(1)&quot;&gt; &lt;p&gt;Hey&lt;/p&gt; &lt;p&gt;Let's&lt;/p&gt; &lt;p&gt;Dance&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel2 panel&quot; onclick=&quot;clickOpen(2)&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;Take&lt;/p&gt; &lt;p&gt;Receive&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel3 panel&quot; onclick=&quot;clickOpen(3)&quot;&gt; &lt;p&gt;Experience&lt;/p&gt; &lt;p&gt;It&lt;/p&gt; &lt;p&gt;Today&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel4 panel&quot; onclick=&quot;clickOpen(4)&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;All&lt;/p&gt; &lt;p&gt;You can&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel5 panel&quot; onclick=&quot;clickOpen(5)&quot;&gt; &lt;p&gt;Life&lt;/p&gt; &lt;p&gt;In&lt;/p&gt; &lt;p&gt;Motion&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 二、css部分css代码主要要实现5个div元素均匀横向排列，每个div元素内有对应的背景图片、3个p标签的文本。P标签的文本在每一个div元素中也是左右居中、上下均匀排列。主要是利用了flex容器来实现。 1 flex容器参考网站：https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器的属性： flex-direction：项目的排列方向 flex-wrap：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 flex-flow：flex-direction属性和flex-wrap属性的简写形式 justify-content：项目在主轴上的对齐方式 align-items：项目在交叉轴上如何对齐 align-content：定义了多根轴线的对齐方式 项目的属性： order：项目的排列顺序，数值越小，排列越靠前 flex-grow：定义项目的放大比例，默认为0 flex-shrink：项目的缩小比例，默认为1 flex-basis： 项目占据的主轴空间 flex：是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 2 css字体1234&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Amatic+SC&quot;&gt;text-transform: uppercase;font-family: 'Amatic SC',cursive;text-shadow: 0 0 4px rgba(0,0,0,0.72),0 0 14px rgba(0,0,0,0.45); 3过渡样式12345transition:font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),background 0.2s;transform:translateY(-100%); 4 背景图片1234567background-size: cover;background-position: center;.panel1 { background-image:url(https://source.unsplash.com/gYl-UtwNg_I/1500x1500); }.panel2 { background-image:url(https://source.unsplash.com/rFKUFzjPYiQ/1500x1500); }.panel3 { background-image:url(https://images.unsplash.com/photo-1465188162913-8fb5709d6d57?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;w=1500&amp;h=1500&amp;fit=crop&amp;s=967e8a713a4e395260793fc8c802901d); }.panel4 { background-image:url(https://source.unsplash.com/ITjiVXcwVng/1500x1500); }.panel5 { background-image:url(https://source.unsplash.com/3MNzGlQM7qs/1500x1500); } 5其他CSS选择器 * 将匹配文档的所有元素；&gt; 组合器选择前一个元素的直接子代的节点。 .panel &gt; *选择类名为panel的所以直接子元素 Js部分我写的程序，大致思路是在html代码里设置onclick属性，然后函数内容在js里写，不同的panel传入参数不一样 定位类名有两个以上的标签document.getElementsByClassName(panel${num} panel-open)； 1234567891011// 点击panel 12345，给对应的panel添加.panel-open属性function clickOpen(num){ const panelNumIf = document.getElementsByClassName(`panel${num} panel-open`); const panelNum = document.getElementsByClassName(`panel${num}`); // console.log(panelNumIf[0]) if (panelNumIf[0]) panelNumIf[0].classList.remove('panel-open'); else panelNum[0].classList.add('panel-open');//添加panel-open类属性 console.log(`panel${num} panel-open`); }; 别人的程序，大致思路是遍历5个Panel，监控是否有点击事件，有的话就运行toggleOpen函数，该函数里 this.classList.toggle(‘open’)表示如果this有open类名，则删除，没有则加上。 e.propertyName获取transitionend的属性名，e.propertyName.includes(‘flex’)包含flex字段的属性名 12345678910111213const panels = document.querySelectorAll('.panel');function toggleOpen() { console.log('Hello'); this.classList.toggle('open');}function toggleActive(e) { console.log(e.propertyName); if (e.propertyName.includes('flex')) { this.classList.toggle('open-active'); }}panels.forEach(panel =&gt; panel.addEventListener('click', toggleOpen));panels.forEach(panel =&gt; panel.addEventListener('transitionend', toggleActive)); 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/17/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Flex-Panel-05/"},{"title":"","text":"【原生javascript项目】 Fun dictionary 06 作者：©Iaine 万一简介：30-day vanilla js coding challenge (30 Day Challenge)是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。目的是帮助人们用纯 JavaScript 来写东西，不借助框架和库，也不使用编译器和引用。本项目属于第6天项目，为了更有挑战性，我尝试实现了 单词查找 的功能。 Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/funDictionary/ 项目描述在输入框中输入一个单词，会实时匹配现有词库中所有包含该字段的单词（以一定的样式展示），每个单词中，会高亮显示出文本输入框中输入的字段。词库为json数据，在加载页面时，异步获取而来。 项目主要知识点包括： 异步操作 数组Array对象的一些方法 正则表达式 CSS transform的一些属性 项目过程html部分设置input标签用来输入单词，ul标签（列表标签）用来展示搜索的结果 JS部分 空数组直接赋值给一个dict变量，用来存储json数据中的词库 使用fetch 方法从网络中异步获取资源，解析 JSON 数据，存入数组dict 利用 filter() 方法查找单词wordToMatch，筛选的条件是正则表达式，如果string的match(regex)方法返回不是空，则filter函数返回词库中所有wordToMatch字段的单词 运用 filter() 过滤数组数据 创建正则表达式，构造过滤条件 match方法匹配 编写匹配输入的函数。在Html中显示匹配的单词，利用map方法按照原始数组元素顺序依次处理元素。 获取匹配数据 替换关键词放入高亮的标签 构造 HTML 标签数据 将匹配值的 HTML 标签放入 &lt;ul&gt; 中 编写展示匹配结果的函数 获取匹配数据 利用map方法依次处理元素，替换关键词放入高亮的标签，返回html标签数据 将匹配值的 HTML 标签放入 &lt;ul&gt; 中 获取两个主要 HTML 元素（&lt;input&gt;，&lt;ul&gt;），给 &lt;input&gt; 添加事件监听（change, keyup） CSS部分CSS**transform**属性允许旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。 项目知识点异步操作概念：程序执行任务时分两段进行，执行第一段任务后，执行其他任务，其他任务执行完后接着执行第二段任务。 异步操作的方法： 回调函数多重嵌套 缺点：出现多重嵌套，代码很容易乱成一团，无法管理，出现callback hell。 示例: 读取A文件之后，再读取B文件，之后再回到读取A文件后的操作。 12345fs.readFile(fileA, function (err, data) { fs.readFile(fileB, function (err, data) { // ... });}); Promise 它不是新的语法功能，而是一种新的写法。代码从横向发展，变成纵向发展。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function(data){ console.log(data.toString());}).then(function(){ return readFile(fileB);}).then(function(data){ console.log(data.toString());}).catch(function(err) { console.log(err);}); 参考文档：https://wiki.jikexueyuan.com/project/es6/async.html#:~:text=%E6%89%80%E8%B0%93%22%E5%BC%82%E6%AD%A5%22%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4,%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B0%B1%E5%8F%AB%E5%81%9A%E5%BC%82%E6%AD%A5%E3%80%82 fetch属于Fetch API的一个全局方法。需要接受 url 作为参数，返回值是一个 Promise 对象。若请求成功，这个对象包含了（对应 Request 的）Response，但这只是一个 HTTP 响应。 一个基本的 fetch 请求设置代码如下： 123fetch('http://example.com/movies.json') .then(response =&gt; response.json()) .then(data =&gt; console.log(data)); 这里通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 fetch() 到的资源路径，然后返回一个包含响应结果的 promise（一个 Response 对象）。 当然它只是一个 HTTP 响应，而不是真的 JSON。为了获取JSON的内容，我们需要使用 json() 方法（该方法返回一个将响应 body 解析成 JSON 的 promise）。 对象转换为数组获取的资源data为对象类型， ``{a: ‘The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).’, ab: ‘The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.’, aback: ‘Backward against the mast;-said of the sails when …uddenly checked, baffled, ordiscomfited. Dickens.’, abaft: ‘Behind; toward the stern from; as, abaft the wheelhouse. Abaftthe beam. See under Beam.’, abalone: ‘A univalve mollusk of the genus Haliotis. The shel…oast of California, clingingclosely to the rocks.’, …}` 想要转换为数组： [0:{a: 'The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).'} 1:{ab: 'The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.'}] 代码参考链接：https://juejin.cn/post/6844903602478120967 12345data =&gt; Object.keys(data).forEach(v =&gt; { let o = {}; o[v] = data[v]; dict.push(o);}) Object.keys方法是JavaScript中用于遍历对象属性的一个方法 。它传入的参数是一个对象，返回的是一个数组，数组中包含的是该对象所有的属性名。 正则表达式概念：匹配字符串的字符组合模式 创建一个正则表达式有两种方法： 1 使用正则表达式字面量，包含在斜杠之间 2 调用RegExp对象的构造函数 知识参考链接：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions 正则表达式可以被用于 RegExp 的 exec 和 test (en-US) 方法以及 String 的 match (en-US)、replace、search (en-US) 和 split (en-US) 方法。其中match方法是一个在字符串中执行查找匹配的String方法，返回一个数组，在未匹配到时会返回 null。 12345678// 匹配单词 function findWords(wordToMatch,dict){ return dict.filter(word =&gt;{ const regex = new RegExp(wordToMatch,'gi');// g:global,i:intensive if (Object.keys(word)[0].match(regex)) return word[Object.keys(word)[0]]; }) }; 一些数组和对象方法17个实用的JavaScript数组和对象的方法：https://segmentfault.com/a/1190000015301183 .filter()创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 .map()创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 .reduce()对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。 .forEach()对数组的每个元素执行一次提供的函数。 .some()判断数组中的某些元素是否通过由提供的函数实现的测试。 .every()检查是否数组中的每个值都满足条件。 .includes()检查是否一个数组包含一个确定的值。 Array.from()这是一个可以从其他数组或者字符串中创造新array的方法。 Objects.values()返回一个由给定对象自己的所有可枚举属性值的数组。 Objects.keys()返回一个由给定对象的自身可枚举属性组成的数组。 Object.entries()返回一个由一个给定对象的键值对组成的数组。 Array spread在数组中使用扩展运算符（…）可以展开数组中的元素。 Object spread扩展对象允许为一个没有更改的对象添加新的属性和方法（换句话说，创建了一个新对象) Object.freeze()防止修改现有的对象属性或者向对象添加新的属性和值。 Object.seal()停止将任何新属性添加到对象，但仍允许更改现有属性。 Object.assign()允许将对象组合在一起。 想把我的技术文章写好一点，特意参考其他优秀人的文档，感谢未枝丫，我觉得他的文档写的不错，特意模仿，顺便挂上他的JS30挑战项目链接。 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/04/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91%20Fun%20dictionary%2006/"},{"title":"【原生javascript项目】 Fun dictionary 06","text":"作者：©Iaine 万一简介：30-day vanilla js coding challenge (30 Day Challenge)是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。目的是帮助人们用纯 JavaScript 来写东西，不借助框架和库，也不使用编译器和引用。本项目属于第6天项目，为了更有挑战性，我尝试实现了 单词查找 的功能。 Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/funDictionary/ 项目描述在输入框中输入一个单词，会实时匹配现有词库中所有包含该字段的单词（以一定的样式展示），每个单词中，会高亮显示出文本输入框中输入的字段。词库为json数据，在加载页面时，异步获取而来。 项目主要知识点包括： 异步操作 数组Array对象的一些方法 正则表达式 CSS transform的一些属性 项目过程html部分设置input标签用来输入单词，ul标签（列表标签）用来展示搜索的结果 JS部分 空数组直接赋值给一个dict变量，用来存储json数据中的词库 使用fetch 方法从网络中异步获取资源，解析 JSON 数据，存入数组dict 利用 filter() 方法查找单词wordToMatch，筛选的条件是正则表达式，如果string的match(regex)方法返回不是空，则filter函数返回词库中所有wordToMatch字段的单词 运用 filter() 过滤数组数据 创建正则表达式，构造过滤条件 match方法匹配 编写匹配输入的函数。在Html中显示匹配的单词，利用map方法按照原始数组元素顺序依次处理元素。 获取匹配数据 替换关键词放入高亮的标签 构造 HTML 标签数据 将匹配值的 HTML 标签放入 &lt;ul&gt; 中 编写展示匹配结果的函数 获取匹配数据 利用map方法依次处理元素，替换关键词放入高亮的标签，返回html标签数据 将匹配值的 HTML 标签放入 &lt;ul&gt; 中 获取两个主要 HTML 元素（&lt;input&gt;，&lt;ul&gt;），给 &lt;input&gt; 添加事件监听（change, keyup） CSS部分CSS**transform**属性允许旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。 项目知识点异步操作概念：程序执行任务时分两段进行，执行第一段任务后，执行其他任务，其他任务执行完后接着执行第二段任务。 异步操作的方法： 回调函数多重嵌套 缺点：出现多重嵌套，代码很容易乱成一团，无法管理，出现callback hell。 示例: 读取A文件之后，再读取B文件，之后再回到读取A文件后的操作。 12345fs.readFile(fileA, function (err, data) { fs.readFile(fileB, function (err, data) { // ... });}); Promise 它不是新的语法功能，而是一种新的写法。代码从横向发展，变成纵向发展。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function(data){ console.log(data.toString());}).then(function(){ return readFile(fileB);}).then(function(data){ console.log(data.toString());}).catch(function(err) { console.log(err);}); 参考文档：https://wiki.jikexueyuan.com/project/es6/async.html#:~:text=%E6%89%80%E8%B0%93%22%E5%BC%82%E6%AD%A5%22%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4,%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B0%B1%E5%8F%AB%E5%81%9A%E5%BC%82%E6%AD%A5%E3%80%82 fetch属于Fetch API的一个全局方法。需要接受 url 作为参数，返回值是一个 Promise 对象。若请求成功，这个对象包含了（对应 Request 的）Response，但这只是一个 HTTP 响应。 一个基本的 fetch 请求设置代码如下： 123fetch('http://example.com/movies.json') .then(response =&gt; response.json()) .then(data =&gt; console.log(data)); 这里通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 fetch() 到的资源路径，然后返回一个包含响应结果的 promise（一个 Response 对象）。 当然它只是一个 HTTP 响应，而不是真的 JSON。为了获取JSON的内容，我们需要使用 json() 方法（该方法返回一个将响应 body 解析成 JSON 的 promise）。 对象转换为数组获取的资源data为对象类型， ``{a: ‘The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).’, ab: ‘The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.’, aback: ‘Backward against the mast;-said of the sails when …uddenly checked, baffled, ordiscomfited. Dickens.’, abaft: ‘Behind; toward the stern from; as, abaft the wheelhouse. Abaftthe beam. See under Beam.’, abalone: ‘A univalve mollusk of the genus Haliotis. The shel…oast of California, clingingclosely to the rocks.’, …}` 想要转换为数组： [0:{a: 'The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).'} 1:{ab: 'The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.'}] 代码参考链接：https://juejin.cn/post/6844903602478120967 12345data =&gt; Object.keys(data).forEach(v =&gt; { let o = {}; o[v] = data[v]; dict.push(o);}) Object.keys方法是JavaScript中用于遍历对象属性的一个方法 。它传入的参数是一个对象，返回的是一个数组，数组中包含的是该对象所有的属性名。 正则表达式概念：匹配字符串的字符组合模式 创建一个正则表达式有两种方法： 1 使用正则表达式字面量，包含在斜杠之间 2 调用RegExp对象的构造函数 知识参考链接：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions 正则表达式可以被用于 RegExp 的 exec 和 test (en-US) 方法以及 String 的 match (en-US)、replace、search (en-US) 和 split (en-US) 方法。其中match方法是一个在字符串中执行查找匹配的String方法，返回一个数组，在未匹配到时会返回 null。 12345678// 匹配单词 function findWords(wordToMatch,dict){ return dict.filter(word =&gt;{ const regex = new RegExp(wordToMatch,'gi');// g:global,i:intensive if (Object.keys(word)[0].match(regex)) return word[Object.keys(word)[0]]; }) }; 一些数组和对象方法17个实用的JavaScript数组和对象的方法：https://segmentfault.com/a/1190000015301183 .filter()创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 .map()创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 .reduce()对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。 .forEach()对数组的每个元素执行一次提供的函数。 .some()判断数组中的某些元素是否通过由提供的函数实现的测试。 .every()检查是否数组中的每个值都满足条件。 .includes()检查是否一个数组包含一个确定的值。 Array.from()这是一个可以从其他数组或者字符串中创造新array的方法。 Objects.values()返回一个由给定对象自己的所有可枚举属性值的数组。 Objects.keys()返回一个由给定对象的自身可枚举属性组成的数组。 Object.entries()返回一个由一个给定对象的键值对组成的数组。 Array spread在数组中使用扩展运算符（…）可以展开数组中的元素。 Object spread扩展对象允许为一个没有更改的对象添加新的属性和方法（换句话说，创建了一个新对象) Object.freeze()防止修改现有的对象属性或者向对象添加新的属性和值。 Object.seal()停止将任何新属性添加到对象，但仍允许更改现有属性。 Object.assign()允许将对象组合在一起。 想把我的技术文章写好一点，特意参考其他优秀人的文档，感谢未枝丫，我觉得他的文档写的不错，特意模仿，顺便挂上他的JS30挑战项目链接。 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/06/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Fun-dictionary-06/"}],"tags":[{"name":"原生javascript项目","slug":"原生javascript项目","link":"/myblog.github.io/tags/%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE/"}],"categories":[{"name":"30个原生javascript项目","slug":"30个原生javascript项目","link":"/myblog.github.io/categories/30%E4%B8%AA%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE/"}]}
{"pages":[],"posts":[{"title":"【python】清理重复图片","text":"引言本文解释如何编写python脚本，实现重复图片清理的功能。 正文MD5,Message-Digest Algorithm，信息摘要算法，是一种信息加密算法，可以把任意长度的数据转换为一个长度固定的数据串（通常是16进制的字符串表示）。一个图片文本的本质是一个数据串，所以要想清理重复图片，就是要匹配到相同的数据串的两张图片，使用DM5的目的是将图片的数据串统一，如果两张图片经过MD5算法变换后的数据串相同，则可判断这两种图片重复。 以计算一个字符串的MD5值为例，代码如下： 12345import hashlibmd5 = hashlib.md5()md5.update('how to use md5 in python hashlib?'.encode('utf-8'))print(md5.hexdigest()) 计算结果为 1d26a53750bc40b38b65a520292f69306 参考网站：廖雪峰老师博客中摘要算法简介 本文的脚本的思路如下：1 遍历文件夹下的图片文件2 把图片文件记录到一个字典变量中3 生成所有图片文件的MD5值4 把MD5值存放到一个新的字典变量中5 判断如果已经存放，则该图片为重复图片，删除即可 选取文件夹，遍历文件夹下所有的文件123456inpath = &quot;G:/最新/照片/2018-2019年照片备份/2021年&quot;for path,dir,filelist in os.walk(inpath): for filename in filelist: # print(filename) allfile.append(os.path.join(path,filename)) 获取MD5值123456fd = open(file,'rb')md5 = hashlib.md5()md5.update(fd.read())fd.close()return md5.hexdigest() 根据MD5值比较123456for photo in allfile: md5sum = getmd5(photo) if md5sum not in md5list: md5list.append(md5sum) else: identicallist.append(photo) 删除重复照片12for idenPhoto in identicallist: os.remove(idenPhoto) 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/09/02/%E3%80%90python%E3%80%91%E6%B8%85%E7%90%86%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87/"},{"title":"【程序】我是如何建立我的第一个博客网站的？","text":"写在前面我从大二开始喜欢上写程序，也从那开始自学了很多编程语言。当我第一次接触到前端开发的时候，那些由多个不同后缀名组成的项目，让我觉得又新奇（第一次见这种编程语言，太有特色了），同时又恐惧（这么多个编程语言组成，我能学会吗）。 大二是我人生阶段最迷茫的一段时间，不想上课，不想和人交往。但是我生来好像就有股向上的劲头，即使每天很颓废，也告诫自己做点有用的事情，做点有用的事情。所以我那段时间学了很多编程语言，虽然是迷迷糊糊学了很多语言，走了很多弯路。 好在我也勉勉强强地学了前端开发，我记得那段时间我先是在网上看了一个教学视频，然后就开始自己动手捣鼓做起了第一个个人网站，花了一天一夜的时间。 大三开始我稳定地在实验室跟着一个老师做科研，便没有时间再去学写程序。 大四基本上是在做创新创业比赛，更没有时间写程序了。 但是大二以后的整个过程，我总是偶尔地问自己：当初我为何要学写这么多程序？我大二整整一年的时间都花在自学程序上，感觉就这么放弃有点太不值得？自学程序有用吗以后？ 现在我也不知道学的程序有没有用，但是就是因为当初花了一年时间起步，不甘心没有一点收获地戛然而止。所以我，到了大四暑假的末尾，研一马上要开学，要重新拾起我以前学的东西，好好做下去，希望能做出点东西。 自学编程的时候听到最多、最有用的建议就是要多做实战，而对于前端开发来讲，第一个要做的实战就是建立自己的个人网站，第二个就是建立个人博客。所以在建立好自己的第一个网站，一年后，也就是现在，我开始建个人博客，并且立下不倒的flag，这个网站将会见证我一点一滴的成长（未来我的生活琐事，学习曲线等奖全部记录记录在这里），是我人生中一笔宝贵的财富，我一定会好好经营。 正文一、找资料一般开始一个新东西，第一步肯定是找资料，毕竟光想是想不出来的。我找的第一个资料就是B站Up主CodeSheep的一个视频手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo：https://www.bilibili.com/video/BV1Yb411a7ty 在看这个视频的过程中，我有很多疑惑（为什么要下载node.js,在cmd下建文件夹是怎么回事等等），所以也会找其他资料使用hexo+github搭建免费个人博客详细教程：https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.htmlhexo5分钟免费搭建个人博客教程：https://www.jianshu.com/p/722fe57ef163 结合视频，以及文本资料，我的很多疑惑都消除了，接下来我便可以自己动手尝试了。 二、下载软件，准备环境1.安装好node.js（最好下载Windows 安装包 (.msi)，在安装过程中会配置好路径，用zip文件还要自己手动配置，特别容易报错） 和 Git 2.在das窗口下输入命令 node -v和 npm -v，检验hexo运行环境 3.git安装完成后的检验操作是：鼠标右键。会出现git GUI here 和git bash here 三、使用hexo框架搭建静态博客1.安装 hexo 框架 1npm install -g hexo 2.在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\\程序\\html_codes\\janiceBlog，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 3.cmd窗口下切换到janiceBlog文件夹路径，然后输入一下代码： 1hexo init # 初始化 hexo会自动下载一些文件到这个目录，包括node_modules 12hexo g # 生成hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。hexo s是开启本地预览服务，打开浏览器访问http://localhost:4000即可看到内容 4.修改主题可以再官网选一个好看的主题以yilia主题为例，在博客路径下，输入一下命令: 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布 四、上传到github1.配置_config.yml中有关deploy的部分： 1234deploy: type: git repository: git@github.com:janice143/iainsBlog.git branch: master 2.打开博客文件夹，右键选择git bash here，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会(部署这个命令一定要用git bash,不要在cmd下，不然会报错) 五、上传到GitHub出现一些错误错误1： hexo + github pages搭建博客，本地server成功，部署到github上之后样式加载不出来解决：需要修改根目录_config.yml文件中的url地址和根目录 123456##If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://janice143.github.io/myblog.github.io/root: /myblog.github.iopermalink: :year/:month/:day/:title.htmlpermalink_defaults: url 是GitHub pages给我们分配的网址root是搭建该博客的仓库名 最后重新部署上传就可以了 123hexo cleanhexo ghexo d 错误2：修改默认头像解决：在主题的yilia文件夹的img文件夹里放上头像图片，然后修改yilia文件夹下的_config.yml文件 12#你的头像urlavatar: /myblog.github.io/img/me.JPG 六、写博客1.定位到我们的博客目录，执行命令： 1hexo new “博客名自己取” 2.markdown格式编写规则参考：http://www.mdeditor.com/","link":"/myblog.github.io/2020/09/11/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%EF%BC%9F/"},{"title":"【原生javascript项目】Real time clock 02","text":"引言本文利用javascript写一个实时显示时间的时钟特效网页。 网址为(https://janice143.github.io/realTImeClock/) 正文1网页布局与功能 网页主体为一个时钟，具有表盘（12个数字）和三个指针（时针、分针、秒针）。 2实现原理一、 html代码 使用一个类名为clock为的div容器，里面包含时针.hour-hand,分针.minute-hand,秒针second-hand，以及12个数字。 12345678910111213141516171819202122&lt;div class=&quot;clock&quot;&gt; &lt;div class=&quot;hour-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;minute-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;second-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;number&quot;&gt; &lt;span class=&quot;num12&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;num1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;num2&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;num3&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;num4&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;num5&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;num6&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;num7&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;num8&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;num9&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;num10&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;num11&quot;&gt;11&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 二、css代码 1 先让时钟显示在页面的中部（垂直居中，水平居中），这可以用个在clock的上一级词main中设置flex容器。 12345678#main{ display: flex; min-height: 100vh; align-items: center; justify-content: center;} 2 时钟的表盘的样式 1234567.clock{ width: 300px; height: 300px; border-radius: 300px; border: 20px solid white; position: relative;} 3 指针的样式 指针旋转的特效是由transfrom：rotate(deg)实现的（本文这里是通过js代码后面再设置的）。transform-origin默认是50%，元素会绕着中间旋转，设置成100%后，元素绕着一端旋转。transition-timing-function是设置过渡的时间函数特效，不设置是默认均匀地过渡。 1234567891011121314151617.hand{ width: 120px; height: 6px; background-color: blueviolet; position:absolute; top:148px; right: 148px; transform-origin: 100%; transition:all 0.05s; transition-timing-function: cubic-bezier(0.1, 2.7, 0.58, 1);}.hour-hand{ width: 100px;}.second-hand{ height: 4px;} 4 12个数字的样式 先给数字设置相对定位，相对于上一级.number。然后再给每个数字设置相应的top和left. 数字位置算法为： num=2; top=135sin((num-3)30/180pi)+135； left=135cos((num-3)30/180pi)+135 （num为1-12的数字） 1234567891011.number{ width: 300px; height:300px; font-size: 15px; position:absolute; top:0px; right: 0px;} 三、 javascript代码 分别获取时针、分钟、秒针的类名，然后通过当前时间给三个指针分配正确的旋转角度。 1 秒针： parseInt(second/60*360)+90; 2 分针： parseInt(minute/(60)*360+second/10)+90; 3 时针：parseInt(hour/(12)*360+minute/(60)*30)+90; +90度是因为设置指针css样式的时候，指针都在指在9点钟的位置，+90度可让指针从12点为起始点旋转。 设置为指针的角度后，利用定时器每隔一秒刷新指针的位置，这样就可以达到实时显示的效果。 当指针转弯一圈后，重新运行设置时间函数 setDate()重置指针的角度。 123456789101112131415161718192021222324252627// 获取指针的transform样式，从而让其旋转 const secondHand = document.querySelector('.second-hand'); const minuteHand = document.querySelector('.minute-hand'); const hourHand = document.querySelector('.hour-hand'); const audio = document.querySelector('audio'); // 获取当前时间，从时间里设置指针 function setDate(){ const time = new Date(); const second = time.getSeconds(); const secondDeg = parseInt(second/60*360)+90; secondHand.style.transform = `rotate(${secondDeg}deg)`; const minute= time.getMinutes(); const minuteDeg = parseInt(minute/(60)*360+second/10)+90; minuteHand.style.transform = `rotate(${minuteDeg}deg)`; const hour= time.getHours(); const hourDeg = parseInt(hour/(12)*360+minute/(60)*30)+90; hourHand.style.transform = `rotate(${hourDeg}deg)`; } // 设置定时器美隔一秒时间进行刷新页面 setInterval(setDate,1000); // setDate(); // 当指针转一圈后，重置度数 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/12/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Real-time-clock-02/"},{"title":"【原生javascript项目】Image Procession with Javascipt 03","text":"引言本文利用javascripts更新css变量，实现一个简易的图像处理网页。对于图像处理部分，本网页可调节图像的边框宽度、模糊度以及边框颜色值。 网址为(https://janice143.github.io/imageProcessionwithJS/) 正文1 页面布局 页面分为三部分：标题、三个input组成的控件、图像 通过调节三个Input的值，可以实现对外边距、模糊值和颜色的改变。 一、html代码 1 标题 123456&lt;h2&gt;利用&lt;span class=&quot;text-color&quot;&gt;JS&lt;/span&gt;更新CSS自定义变量&lt;/h2&gt; &lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt;&lt;/div&gt; 2 三个input值 12345678910&lt;div class=&quot;controlers&quot;&gt; &lt;label for=&quot;spacing&quot;&gt;外边距:&lt;/label&gt; &lt;input id=&quot;spacing&quot; type=&quot;range&quot; name=&quot;spacing&quot; value=&quot;10&quot; data-unit=&quot;px&quot;&gt; &lt;label for=&quot;blur&quot;&gt;模糊值:&lt;/label&gt; &lt;input id=&quot;blur&quot; type=&quot;range&quot; name=&quot;blur&quot; value=&quot;10&quot; data-unit=&quot;px&quot;&gt; &lt;label for=&quot;color&quot;&gt;底色:&lt;/label&gt; &lt;input id=&quot;color&quot; type=&quot;color&quot; name=&quot;color&quot; value=&quot;#fecc00&quot;&gt;&lt;/div&gt; data-unit=”px”是自己设置的dataset(数据集合)。input的type类型和对应效果如图。 input的id名字一般和name一样。 3 图像 1&lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt; 二、css代码 1 css变量 变量声明：在选择器里（任何选择器），变量名前面要加两根连词线（--）。本文里在:root根元素里声明，这是全局变量的声明方式，保证任何选择器都可以使用。变量名大小写敏感。 12345678img{ margin-top:50px; width:600px; height: 375px; padding: var(--spacing);/* var函数获取变量 */ background-color: var(--color); filter:blur(var(--blur));} 读取变量：利用var()函数读取 12345 :root{ --color:#fecc00; --spacing:10px; --blur:10px;} css变量参考网址：（https://www.ruanyifeng.com/blog/2017/05/css-variables.html） 三、javascript代码 1 suffix中文意思为 后缀。在js代码中，设置了一个suffix变量，这是因为spacing和blur的值在css中需要加上px单位，而color的值没有，所以使用了||逻辑运算。 2 this.dataset需要注意一下，在html代码中，我们设置了自定义了data-unit数据，this.dataset会取出所有自定义的数据集，比如你可以在Html中设置data-key(回想起前几天的js程序）,data-name,data-poo任何数据名字，因为是自定义。this.dataset.unit是本文在html代码中提前设置好的。 3 document.documentElement用来获取当前文档的直接子节点，对于Html文档而言，一般是。 4 style.setProperty(propertyName, value);给css样式某个属性名propertyName赋一个新值value。 5 --${this.name}为模板字面量，可以嵌入表达式的字符串字面量，${}表示一个占位符。一般的字符串是用单引号或者双引号标注的，这些字符串之间没有任何区别，而模板字面量则可以通过一个占位符来进行插值，模板字面量用反引号``实现。 6 箭头函数优点：剪短、this指向函数定义生效时所在对象。 函数声明：关键字、函数名、参数、函数体 123function functionName ([arg1 [,arg2 [...,argn]]]) { // functionBody 函数体} 没有函数名时，函数为匿名函数 1234const square = function (number) { return number * number;};// 相当于箭头函数：number=&gt;number*number; 具名函数由函数名，而且函数内部可以代指本身（迭代函数使用） 123const factorial = function fac(n) { return n &lt; 2 ? 1 : n * fac(n - 1);};console.log(factorial(3));var x = square(4);// x 得到的值为16 箭头函数；如果函数体只有一个表达式，可以不用{}符号 123const fn = () =&gt; { // do something}; 1234567// 获取Input的value，并且将value赋值给cssconst inputs = document.querySelectorAll('.controlers input');function updateValue(){ const suffix = this.dataset.unit || ''; // 给blur和spacing加单位 document.documentElement.style.setProperty(`--${this.name}`,this.value + suffix);}inputs.forEach(input=&gt;input.addEventListener('change',updateValue)); 结论完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/13/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Image-Procession-with-Javascipt-03/"},{"title":"【python】定时健康打卡网站打卡发送邮箱","text":"引言本文介绍如何编写python脚本，实现网站自动、定时健康打卡功能，打卡成功后截取当前屏幕信息，并通过发送邮件告知对方已经打卡成功。 正文思路：1 package 安装2 实现网站打卡功能3 保存当前网站截图4 发送邮件5 定时运行程序 package 安装Selenium安装 1pip install selenium ChromeDriver下载：下载与本机安装的Chrome浏览器的版本相同的ChromeDriver.exe，并放在python安装路径下的scripts路径下。 实现网站打卡功能打开浏览器，进入网站搜索 123browser = webdriver.Chrome()browser.get('这里填你要打卡的网站地址')time.sleep(2) 通过find_element_by_xpath来定位用户名和密码的输入框，并输入用户名和密码 1234uid = '你的用户名'pwd = '密码'browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[4]/input&quot;).send_keys(uid)browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[5]/input&quot;).send_keys(pwd) 通过find_element_by_xpath来定位登录输入框，并点击回车键 1browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[7]/input&quot;).send_keys(Keys.ENTER) 点击健康打卡 123click_btn = browser.find_element_by_xpath(&quot;//*[@id='apply-content']/div[2]/ul[1]/li[2]&quot;)ActionChains(browser).click(click_btn).perform()# time.sleep(2) 点击填报 12click_btn2 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[4]/button&quot;)ActionChains(browser).click(click_btn2).perform() 点击 我知晓 12click_btn3 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[51]/div[1]/input&quot;)ActionChains(browser).click(click_btn3).perform() 点击上报 12click_btn4 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[52]&quot;)ActionChains(browser).click(click_btn4).perform() 截屏并保存，保存当前网站截图打卡成功后，我想保留当前网页的截图，作为打卡成功的凭证 1browser.get_screenshot_as_file(&quot;success.png&quot;) 退出浏览器 1browser.quit() 发送邮件通过发送邮件的方式，通知对方已经成功打卡。 准备用于发送信息、接收信息的邮箱 123MAIL_USER = &quot;邮箱地址&quot; # 用于发送通知的邮箱MAIL_PASS = &quot;授权码&quot; # 授权码，注意不是邮箱登录密码！！mail_to = &quot;接收信息的邮箱&quot; 发送带有图片附件images和正文mail_text的邮件 12345678910111213141516msg = MIMEMultipart()mail_text = &quot;已经成功打卡！&quot;mail_body = MIMEText(mail_text)# 设置邮件主题、发送方和接收方msg['Subject'] = &quot;每日健康打卡通知&quot;msg['From'] = MAIL_USERmsg['To'] = mail_tomsg.attach(mail_body)# 添加截图附件fp = open(&quot;success.png&quot;, 'rb')images = MIMEImage(fp.read())fp.close()images.add_header('Content-Disposition', 'attachment', filename='success.png')msg.attach(images) 登陆并发送邮件(我这里是用163邮箱) 123456smtp = smtplib.SMTP()smtp.connect('smtp.163.com')smtp.login(MAIL_USER, MAIL_PASS)smtp.sendmail(MAIL_USER, mail_to, msg.as_string())smtp.quit() 定时运行程序通过使用Win10自带的“任务计划程序”来设置运行编写的.py脚本，设置步骤如下： 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/08/20/%E3%80%90python%E3%80%91%E5%AE%9A%E6%97%B6%E5%81%A5%E5%BA%B7%E6%89%93%E5%8D%A1%E7%BD%91%E7%AB%99%E6%89%93%E5%8D%A1%E5%8F%91%E9%80%81%E9%82%AE%E7%AE%B1/"},{"title":"【原生javascript项目】Piano-Kit-01","text":"引言本文介绍如何用javascripty语法写一个简单的琴键(drum ang piano)网页，通过敲击特定键盘（音键），可以发出不同音调。 网址为(https://janice143.github.io/musicKit.github.io/) 正文1网页布局与功能 网页整体分为3个部分： 1是最顶上居中排布的乐器切换(Drum Kit, Piano Kit)组块，选中响应的kit，背景图和琴键切换为响应的内容，同时kit字体变为白色； 2是页面居中排布的琴键； 3是背景图。 琴键可以通过鼠标点击或者按下响应的键盘来操作，可以发出对应的音效（黄色字体表示音效的名称）。琴键被点击按下后，加以一定的css动画（黄色高亮边框）来区分。 2实现原理一、 html代码 1 乐器切换组块： 1234&lt;div id=&quot;switch&quot;&gt; &lt;a class=&quot;drum chosen&quot; href=&quot;#&quot; onclick=&quot;addChosenDrum()&quot;&gt;Drum Kit&lt;/a&gt; &lt;a class=&quot;piano&quot; href=&quot;#&quot; onclick=&quot;addChosen()&quot;&gt;Piano Kit&lt;/a&gt;&lt;/div&gt; 2 Drum Kit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=&quot;pianoKit&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key1 key&quot; &gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(65)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;A&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;DO&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key2 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(83)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;S&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;RE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key3 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(68)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;D&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;MI&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key4 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(70)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;F&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;FA&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key5 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(71)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;G&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SOL&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key6 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(72)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;H&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;LA&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(74)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;J&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SI&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;audio data-key=&quot;65&quot; src=&quot;sounds/1.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;83&quot; src=&quot;sounds/2.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;68&quot; src=&quot;sounds/3.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;70&quot; src=&quot;sounds/4.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;71&quot; src=&quot;sounds/5.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;72&quot; src=&quot;sounds/6.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;74&quot; src=&quot;sounds/7.MP3&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 3 Piano Kit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;div id=&quot;drumKit&quot; class=&quot;chosen&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key1 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(65)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;A&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;CLAP&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key2 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(83)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;S&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;HIHAT&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key3 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(68)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;D&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;KICK&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key4 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(70)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;F&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;OPENHAP&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key5 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(71)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;G&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;BOOM&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key6 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(72)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;H&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;RIDE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(74)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;J&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SNARE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;75&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(75)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;K&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;TOM&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;76&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(76)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;L&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;TINK&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;audio data-key=&quot;65&quot; src=&quot;sounds/clap.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;83&quot; src=&quot;sounds/hihat.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;68&quot; src=&quot;sounds/kick.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;70&quot; src=&quot;sounds/openhat.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;71&quot; src=&quot;sounds/boom.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;72&quot; src=&quot;sounds/ride.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;74&quot; src=&quot;sounds/snare.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;75&quot; src=&quot;sounds/tom.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;76&quot; src=&quot;sounds/tink.wav&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 二、css代码 1 实现顶部的切换组块（Drum Kit, Piano Kit)固定在窗口的某个位置，不占位置，脱离标准文档流；居中排布 1234position: fixed;left:0; right:0; margin:0 auto; 2 实现琴键居中排布：用Flex 布局实现垂直、水平居中。 任何一个容器都可以指定为 Flex 布局（flex容器），display: flex即可实现。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”Item”。 容器具有6个属性： · flex-direction:水平主轴的方向 · flex-wrap:如果主轴拍不下，可以用这个属性来设置换行的形式 · flex-flow:合并了flex-direction 和flex-wrap的功能，用这个属性可以同时设置这两个属性。 · justify-content:定义了item在主轴（水平方向上）的对齐方式 ·align-items：定义了item在垂直方向上的对齐方式 · align-content：定义了多跟轴线的对齐方式 123456789#drumKit,#pianoKit{ /* background-color: red; */ /* 在需要垂直居中的父元素上，设置display:flex和align-items：center。要求：父元素必须显示设置height值 */ display: flex; flex:1; min-height: 90vh; /*vh 就是当前屏幕可见高度的100% align-items: center; /*子元素水平居中*/ justify-content: center; /*子元素垂直居中*/} 90vh表示占窗口（当前页面窗口）大小的90%。 3 键盘被点击时，js会添加playing类，其css布局为 12345.playing{ transform: scale(1.1); border-color: #ffc600; box-shadow: 0 0 1rem #ffc600;} 4 drum kit 和piano kit被选中时，js会添加chosen类名。设置css代码让选中字体变为白色以区分 123#switch .chosen{ color:white;} 三、 javascript代码 1 切换键盘(drum kit, piano kit) 对于drum kit：点击drum，添加.chosen，同时去掉piano kit 的.chosen类名；显示drum琴键，隐藏piano琴键；显示响应背景background-image。 12345678910111213141516171819202122232425262728293031// 点击a标签，切换键盘:点击piano键盘，添加chosen class，去掉drum的class; 显示对应的piano键盘;在对应的键盘中添加chosen，这样audio也可以对应 function addChosen(){ const chosen = document.getElementsByClassName(&quot;piano&quot;); const notChosen = document.getElementsByClassName(&quot;drum&quot;); chosen[0].classList.add('chosen'); notChosen[0].classList.remove('chosen'); const notChosenKit = document.getElementById(&quot;drumKit&quot;); notChosenKit.classList.remove('chosen'); notChosenKit.style.display = &quot;none&quot;; const chosenKit = document.getElementById(&quot;pianoKit&quot;); chosenKit.style.display = &quot;flex&quot;; chosenKit.classList.add('chosen'); // 换钢琴壁纸 const wallpaper = document.getElementsByTagName(&quot;html&quot;); wallpaper[0].style.backgroundImage=&quot;url(./pianoback.jpg)&quot;; } function addChosenDrum(){ const chosen = document.getElementsByClassName(&quot;drum&quot;); const notChosen = document.getElementsByClassName(&quot;piano&quot;); chosen[0].classList.add('chosen'); notChosen[0].classList.remove('chosen'); const notChosenKit = document.getElementById(&quot;pianoKit&quot;); notChosenKit.classList.remove('chosen'); notChosenKit.style.display = &quot;none&quot;; const chosenKit = document.getElementById(&quot;drumKit&quot;); chosenKit.style.display = &quot;flex&quot;; chosenKit.classList.add('chosen'); // 换鼓壁纸 const wallpaper = document.getElementsByTagName(&quot;html&quot;); wallpaper[0].style.backgroundImage=&quot;url(./drumback.jpg)&quot;; } 2 键盘敲击琴键，用keycode标注，给对应琴键添加.playing类名。设置audio.play发出音效。 1234567891011// 点击键盘字母时，对应的键添加class属性function playSound(e){ const audio = document.querySelector(`.chosen audio[data-key=&quot;${e.keyCode}&quot;]`); // console.log(audio); if (!audio) return; const key = document.querySelector(`.chosen div[data-key=&quot;${e.keyCode}&quot;]`); key.classList.add('playing');//添加playing类属性 audio.currentTime = 0; //音频重头播放 audio.play();} 3 如果连续敲击多个琴键，多个琴键都会显示过渡特效（黄色Border,放大1.2倍），为了让最后一个琴键之前的琴键过滤样式去掉，可以利用transitionend事件，让已经过渡的琴键去掉.playing类名。 12345678910// 去掉playing 类属性function removeTransition(e){ if (e.propertyName !='transform') return; this.classList.remove('playing');}const keys = document.querySelectorAll('.key');keys.forEach(key=&gt;key.addEventListener('transitionend',removeTransition));window.addEventListener('keydown',playSound); 4 鼠标点击也可以实现琴键发出音效。设置onclick事件，传入keycode参数。 1234567891011function clickPlaySound(keycode){ // data-key=keycode; const audio = document.querySelector(`.chosen audio[data-key=&quot;${keycode}&quot;]`); if (!audio) return; const key = document.querySelector(`.chosen div[data-key=&quot;${keycode}&quot;]`); key.classList.add('playing');//添加playing类属性 audio.currentTime = 0; //音频重头播放 audio.play(); // console.log(audio); }; 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Piano-Kit-01/"},{"title":"【原生javascript项目】数组操作 04","text":"引言本文介绍一下数组操作的一些常用方法。 正文1创建数组1234567const people = ['Bernhard, Sandra', 'Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd', 'Beckett, Samuel', 'Blake, William', 'Berger, Ric', 'Beddoes, Mick', 'Beethoven, Ludwig','Belloc, Hilaire', 'Begin, Menachem', 'Bellow, Saul', 'Benchley, Robert', 'Blair, Robert', 'Benenson, Peter', 'Benjamin, Walter', 'Berlin, Irving','Benn, Tony', 'Benson, Leana', 'Bent, Silas', 'Berle, Milton', 'Berry, Halle', 'Biko, Steve', 'Beck, Glenn', 'Bergman, Ingmar', 'Black, Elk', 'Berio, Luciano','Berne, Eric', 'Berra, Yogi', 'Berry, Wendell', 'Bevan, Aneurin', 'Ben-Gurion, David', 'Bevel, Ken', 'Biden, Joseph', 'Bennington, Chester', 'Bierce, Ambrose','Billings, Josh', 'Birrell, Augustine', 'Blair, Tony', 'Beecher, Henry', 'Biondo, Frank']; 2 获取数组长度1console.log(people.length); 3循环123people.forEach(function(item,index){ console.log(item,index);}) 4 数据尾部添加一个元素12let newLength = people.push('Wheeler, Ben');// newLength的结果是people的长度，不是新添加的元素内容console.log(people.length); 5 从尾部删除一个元素12let last = people.pop();console.log(people.length); 6 从头部删除一个元素12let first = people.shift();console.log(people.length); 7 从提添加一个新元素12let firstItem = people.unshift('Bernhard, Sandra');console.log(people); 8 寻找下标12let pos = people.indexOf('Blair, Tony');console.log(pos); 9 根据下标删除元素12let removeItem = people.splice(pos,1);//参数1表示Pos下标后多少个console.log(removeItem); 10 复制数组1234// 复制数组 1let newPeople1 = people; //people和newPeople1指向同一个内存// 复制数组 2let newPeople2 = people.slice(); // people和newPeople1指向不同一个内存 11 Index超出数组长度12people[100] = 'bbb';console.log(people); 12 Array.prototype.filter() 过滤12const fifteen = inventors.filter(inventor=&gt;(inventor.year&gt;=1500 &amp;&amp; inventor.year &lt; 1600));console.table(fifteen); 13 Array.prototype.map()12345const fullNames = inventors.map(inventor =&gt; (inventor.first + ' ' + inventor.last));const fullNames2 = inventors.map(inventor =&gt; `${inventor.first} ${inventor.last}`);console.log(fullNames);console.log(fullNames2); 14 Array.prototype.sort()12345678910// 升序const ordered = inventors.sort((a,b) =&gt; a.year &gt; b.year ? 1 : -1);console.table(ordered);// 降序const oldest = inventors.sort(function(a,b){ const lastInventor = a.passed - a.year; const nextInventor = b.passed - b.year; return lastInventor &gt; nextInventor ? -1:1;});console.table(oldest); 15 Array.prototype.reduce() 结果返回单个值123456// Array.prototype.reduce() 结果返回单个值const totalYears = inventors.reduce((total,inventor) =&gt; { return total + (inventor.passed - inventor.year);}, 0); // 0表示返回的单个值再加上0console.log(totalYears); 结论完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/15/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C-04/"},{"title":"【原生javascript项目】 Flex Panel 05","text":"引言本文介绍一个动态放映网页，知识点主要涉及到flex容器，以及元素点击事件。 效果网站：https://janice143.github.io/flexPanel/ 正文一、html部分主要为5个div元素将网页分为5块，横向排列。每一个div元素中有上中下三个p标签，对应3段话。 123456789101112131415161718192021222324252627&lt;div class=&quot;panels&quot;&gt; &lt;div class=&quot;panel1 panel&quot; onclick=&quot;clickOpen(1)&quot;&gt; &lt;p&gt;Hey&lt;/p&gt; &lt;p&gt;Let's&lt;/p&gt; &lt;p&gt;Dance&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel2 panel&quot; onclick=&quot;clickOpen(2)&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;Take&lt;/p&gt; &lt;p&gt;Receive&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel3 panel&quot; onclick=&quot;clickOpen(3)&quot;&gt; &lt;p&gt;Experience&lt;/p&gt; &lt;p&gt;It&lt;/p&gt; &lt;p&gt;Today&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel4 panel&quot; onclick=&quot;clickOpen(4)&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;All&lt;/p&gt; &lt;p&gt;You can&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel5 panel&quot; onclick=&quot;clickOpen(5)&quot;&gt; &lt;p&gt;Life&lt;/p&gt; &lt;p&gt;In&lt;/p&gt; &lt;p&gt;Motion&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 二、css部分css代码主要要实现5个div元素均匀横向排列，每个div元素内有对应的背景图片、3个p标签的文本。P标签的文本在每一个div元素中也是左右居中、上下均匀排列。主要是利用了flex容器来实现。 1 flex容器参考网站：https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器的属性： flex-direction：项目的排列方向 flex-wrap：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 flex-flow：flex-direction属性和flex-wrap属性的简写形式 justify-content：项目在主轴上的对齐方式 align-items：项目在交叉轴上如何对齐 align-content：定义了多根轴线的对齐方式 项目的属性： order：项目的排列顺序，数值越小，排列越靠前 flex-grow：定义项目的放大比例，默认为0 flex-shrink：项目的缩小比例，默认为1 flex-basis： 项目占据的主轴空间 flex：是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 2 css字体1234&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Amatic+SC&quot;&gt;text-transform: uppercase;font-family: 'Amatic SC',cursive;text-shadow: 0 0 4px rgba(0,0,0,0.72),0 0 14px rgba(0,0,0,0.45); 3过渡样式12345transition:font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),background 0.2s;transform:translateY(-100%); 4 背景图片1234567background-size: cover;background-position: center;.panel1 { background-image:url(https://source.unsplash.com/gYl-UtwNg_I/1500x1500); }.panel2 { background-image:url(https://source.unsplash.com/rFKUFzjPYiQ/1500x1500); }.panel3 { background-image:url(https://images.unsplash.com/photo-1465188162913-8fb5709d6d57?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;w=1500&amp;h=1500&amp;fit=crop&amp;s=967e8a713a4e395260793fc8c802901d); }.panel4 { background-image:url(https://source.unsplash.com/ITjiVXcwVng/1500x1500); }.panel5 { background-image:url(https://source.unsplash.com/3MNzGlQM7qs/1500x1500); } 5其他CSS选择器 * 将匹配文档的所有元素；&gt; 组合器选择前一个元素的直接子代的节点。 .panel &gt; *选择类名为panel的所以直接子元素 Js部分我写的程序，大致思路是在html代码里设置onclick属性，然后函数内容在js里写，不同的panel传入参数不一样 定位类名有两个以上的标签document.getElementsByClassName(panel${num} panel-open)； 1234567891011// 点击panel 12345，给对应的panel添加.panel-open属性function clickOpen(num){ const panelNumIf = document.getElementsByClassName(`panel${num} panel-open`); const panelNum = document.getElementsByClassName(`panel${num}`); // console.log(panelNumIf[0]) if (panelNumIf[0]) panelNumIf[0].classList.remove('panel-open'); else panelNum[0].classList.add('panel-open');//添加panel-open类属性 console.log(`panel${num} panel-open`); }; 别人的程序，大致思路是遍历5个Panel，监控是否有点击事件，有的话就运行toggleOpen函数，该函数里 this.classList.toggle(‘open’)表示如果this有open类名，则删除，没有则加上。 e.propertyName获取transitionend的属性名，e.propertyName.includes(‘flex’)包含flex字段的属性名 12345678910111213const panels = document.querySelectorAll('.panel');function toggleOpen() { console.log('Hello'); this.classList.toggle('open');}function toggleActive(e) { console.log(e.propertyName); if (e.propertyName.includes('flex')) { this.classList.toggle('open-active'); }}panels.forEach(panel =&gt; panel.addEventListener('click', toggleOpen));panels.forEach(panel =&gt; panel.addEventListener('transitionend', toggleActive)); 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/17/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Flex-Panel-05/"},{"title":"【原生javascript项目】 Fun dictionary 06","text":"作者：©Iaine 万一简介：30-day vanilla js coding challenge (30 Day Challenge)是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。本项目属于第6天项目，为了更有挑战性，我尝试实现了 单词查找 的功能。 Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/funDictionary/ 项目描述在输入框中输入一个单词，会实时匹配现有词库中所有包含该字段的单词（以一定的样式展示），每个单词中，会高亮显示出文本输入框中输入的字段。词库为json数据，在加载页面时，异步获取而来。 项目主要知识点包括： 异步操作 数组Array对象的一些方法 正则表达式 CSS transform的一些属性 项目过程html部分设置input标签用来输入单词，ul标签（列表标签）用来展示搜索的结果 JS部分 空数组直接赋值给一个dict变量，用来存储json数据中的词库 使用fetch 方法从网络中异步获取资源，解析 JSON 数据，存入数组dict 利用 filter() 方法查找单词wordToMatch，筛选的条件是正则表达式，如果string的match(regex)方法返回不是空，则filter函数返回词库中所有wordToMatch字段的单词 运用 filter() 过滤数组数据 创建正则表达式，构造过滤条件 match方法匹配 编写匹配输入的函数。在Html中显示匹配的单词，利用map方法按照原始数组元素顺序依次处理元素。 获取匹配数据 替换关键词放入高亮的标签 构造 HTML 标签数据 将匹配值的 HTML 标签放入 &lt;ul&gt; 中 编写展示匹配结果的函数 获取匹配数据 利用map方法依次处理元素，替换关键词放入高亮的标签，返回html标签数据 将匹配值的 HTML 标签放入 &lt;ul&gt; 中 获取两个主要 HTML 元素（&lt;input&gt;，&lt;ul&gt;），给 &lt;input&gt; 添加事件监听（change, keyup） CSS部分CSS**transform**属性允许旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。 项目知识点异步操作概念：程序执行任务时分两段进行，执行第一段任务后，执行其他任务，其他任务执行完后接着执行第二段任务。 异步操作的方法： 回调函数多重嵌套 缺点：出现多重嵌套，代码很容易乱成一团，无法管理，出现callback hell。 示例: 读取A文件之后，再读取B文件，之后再回到读取A文件后的操作。 12345fs.readFile(fileA, function (err, data) { fs.readFile(fileB, function (err, data) { // ... });}); Promise 它不是新的语法功能，而是一种新的写法。代码从横向发展，变成纵向发展。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function(data){ console.log(data.toString());}).then(function(){ return readFile(fileB);}).then(function(data){ console.log(data.toString());}).catch(function(err) { console.log(err);}); 参考文档：https://wiki.jikexueyuan.com/project/es6/async.html#:~:text=%E6%89%80%E8%B0%93%22%E5%BC%82%E6%AD%A5%22%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4,%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B0%B1%E5%8F%AB%E5%81%9A%E5%BC%82%E6%AD%A5%E3%80%82 fetch属于Fetch API的一个全局方法。需要接受 url 作为参数，返回值是一个 Promise 对象。若请求成功，这个对象包含了（对应 Request 的）Response，但这只是一个 HTTP 响应。 一个基本的 fetch 请求设置代码如下： 123fetch('http://example.com/movies.json') .then(response =&gt; response.json()) .then(data =&gt; console.log(data)); 这里通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 fetch() 到的资源路径，然后返回一个包含响应结果的 promise（一个 Response 对象）。 当然它只是一个 HTTP 响应，而不是真的 JSON。为了获取JSON的内容，我们需要使用 json() 方法（该方法返回一个将响应 body 解析成 JSON 的 promise）。 对象转换为数组获取的资源data为对象类型， ``{a: ‘The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).’, ab: ‘The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.’, aback: ‘Backward against the mast;-said of the sails when …uddenly checked, baffled, ordiscomfited. Dickens.’, abaft: ‘Behind; toward the stern from; as, abaft the wheelhouse. Abaftthe beam. See under Beam.’, abalone: ‘A univalve mollusk of the genus Haliotis. The shel…oast of California, clingingclosely to the rocks.’, …}` 想要转换为数组： [0:{a: 'The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).'} 1:{ab: 'The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.'}] 代码参考链接：https://juejin.cn/post/6844903602478120967 12345data =&gt; Object.keys(data).forEach(v =&gt; { let o = {}; o[v] = data[v]; dict.push(o);}) Object.keys方法是JavaScript中用于遍历对象属性的一个方法 。它传入的参数是一个对象，返回的是一个数组，数组中包含的是该对象所有的属性名。 正则表达式概念：匹配字符串的字符组合模式 创建一个正则表达式有两种方法： 1 使用正则表达式字面量，包含在斜杠之间 2 调用RegExp对象的构造函数 知识参考链接：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions 正则表达式可以被用于 RegExp 的 exec 和 test (en-US) 方法以及 String 的 match (en-US)、replace、search (en-US) 和 split (en-US) 方法。其中match方法是一个在字符串中执行查找匹配的String方法，返回一个数组，在未匹配到时会返回 null。 12345678// 匹配单词 function findWords(wordToMatch,dict){ return dict.filter(word =&gt;{ const regex = new RegExp(wordToMatch,'gi');// g:global,i:intensive if (Object.keys(word)[0].match(regex)) return word[Object.keys(word)[0]]; }) }; 一些数组和对象方法17个实用的JavaScript数组和对象的方法：https://segmentfault.com/a/1190000015301183 .filter()创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 .map()创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 .reduce()对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。 .forEach()对数组的每个元素执行一次提供的函数。 .some()判断数组中的某些元素是否通过由提供的函数实现的测试。 .every()检查是否数组中的每个值都满足条件。 .includes()检查是否一个数组包含一个确定的值。 Array.from()这是一个可以从其他数组或者字符串中创造新array的方法。 Objects.values()返回一个由给定对象自己的所有可枚举属性值的数组。 Objects.keys()返回一个由给定对象的自身可枚举属性组成的数组。 Object.entries()返回一个由一个给定对象的键值对组成的数组。 Array spread在数组中使用扩展运算符（…）可以展开数组中的元素。 Object spread扩展对象允许为一个没有更改的对象添加新的属性和方法（换句话说，创建了一个新对象) Object.freeze()防止修改现有的对象属性或者向对象添加新的属性和值。 Object.seal()停止将任何新属性添加到对象，但仍允许更改现有属性。 Object.assign()允许将对象组合在一起。 想把我的技术文章写好一点，特意参考其他优秀人的文档，感谢未枝丫，我觉得他的文档写的不错，特意模仿，顺便挂上他的JS30挑战项目链接。 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/06/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Fun-dictionary-06/"},{"title":"【原生javascript项目】Canvas 08","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第8天项目，为了更有挑战性，我实现了 移动端绘图 、画笔样式选择的功能。Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/myCanvas/ （画了个嗅嗅，一不小心暴露自己是个魔法师啦，哈哈） 项目描述利用html5 中的canvas实现的画板。在电脑端可利用鼠标移动点击进行绘图，在移动端可以通过触摸移动实现绘图。绘图的笔颜色、粗细可以调节，选中橡皮擦可对局部区域进行修改，清屏按钮可以一键清屏。 项目重点 canvas window.innerWidth lineJoin、lineWidth、lineCap strokeColor beginPath、moveTo、lineTo、stroke() 鼠标事件 mousemove: e.offsetX, e.offsetY mouseup mouseout mousedown 触摸事件 touchmove touchend touchcancel touchstart touch坐标计算的坐标偏移问题 input标签的change事件 this.value this.name this.checked 滑块input线性过渡变成非线性过渡 css的flex容器属性 display:flex align-items: center 竖直居中 justify-content: center 水平居中 项目过程html部分 三个input控件 颜色 type=”color” 粗细 type=”range” 橡皮擦 type=”checkbox” canvas标签设置画布 清屏按钮 type=”button” Js部分 获取canvas标签，并设定宽度和高度；获取四个input元素 利用getContext()获取渲染上下文，存储在变量ctx中。 在二维渲染上下文中，左上点坐标为(0,0)，向右（x轴）向下（y轴）为正 设置初始值 初始化画笔颜色（ctx.StrokeStyle）粗细（ctx.lineWidth），橡皮擦不选中(eraserChecked = false)； 设置lineCap(线的末端形状）为圆形，lineJoin（两条线段连接处形状）为圆形 编写updateValue()函数 三个控件input发生改变时，触发事件，调用该函数，更新画笔三个初始值。 编写draw()函数 设定一个用于标记绘画状态的变量，画或者不画（true or false) 判断是鼠标事件还是触摸事件，返回当前鼠标点和触摸点的坐标 赋值新的画笔参数 绘制前调用beginPath()，设定路径起点、终点 编写clearCanvas()函数 清屏的原理就是在画布上画满一个白色矩阵 所有input的监听事件，控件中的change事件，清屏是click事件 CSS部分使用over-flow:hidden来设置页面不动，这点在移动端触摸时显得必不可少。 项目知识点Canvas 创建 Canvas 元素 1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; 通过 JavaScript 来绘制 12var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d'); 基本样式属性 颜色：strokeStyle：线条描边的颜色，fillStyle：填充的颜色 线型：lineCap：笔触的形状；lineJoin：线条相较的方式；lineWidth：线条的宽度 路径绘制 beginPath()：新建一条路径 stroke()：绘制轮廓 moveTo()：绘制操作的起点 lineTo()：路径的终点 触摸屏端坐标偏移问题使用鼠标事件在canvas画布上画画，非常容易就能获取到画布上的坐标，使用（e.offsetX，e.offsetY）就行。但是对于移动端的触摸屏，必须利用【页面上的坐标】-【画布左上角的坐标】=【画布上的坐标】公式去计算当前触摸位置坐标。 changedTouches[0].clientX表示当前触摸点在页面上的坐标，e.target.offsetLeft表示画布偏离页面左上角的位置。 12x = e.changedTouches[0].clientX -e.target.offsetLeft;y = e.changedTouches[0].clientY-e.target.offsetTop; JS30的第8个项目圆满完成啦，虽然对原项目做了一些改进，但是整体上也实现了一些我自己的独特功能。PS：发现自己真的很喜欢编程，fun with front end development.希望自己能力越来越强，实现自己的程序员梦想。 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Canvas-08/"},{"title":"【原生javascript项目】Go list 10","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第10天的“待办清单”项目，我增加了 双击删除任务 、添加任务的功能。Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/goList/ 项目描述利用一些 checkbox 类型的 input 元素，通过在js中实现特定功能，而设计的待办清单网页。在网页中，可以通过点击checkbox来标记任务状态，通过按住shift键可以对任务实现多项check。也可以通过点击添加来增加任务，完成的任务可以通过双击实现删除。 项目重点 类型为checkbox的input元素的点击事件，回调函数为clickCheck e.shiftKey this.checked 标记上一次点击的input，以及多选内部的Input 类型为text的input元素的change事件，回调函数为displayTask 使用createElement创建元素 使用append来在指定结点后添加html 输入文本回车后情况文本，this.value = ‘’ 监听双击事件，移除任务 checkbox后面的文本双击事件，回调函数为removeTask e.path[1].remove() 项目过程html部分 输入文本框input 定位在文本框上的div元素，点击后display: none 四个类名为task-item是checkbox和任务文本p 新添任务的占位标签，新添加的任务将会append在这里 Js部分 获取类型为checkbox的所有input，遍历点击事件 点击事件为clickCheck 多选操作的原理 123456789101112if(e.shiftKey &amp;&amp; this.checked) inputChecks.forEach(inputCheck =&gt; { console.log(inputCheck === this || inputCheck === lastChecked); if (inputCheck === this || inputCheck === lastChecked) { inBetween = !inBetween; // console.log('Starting to check them in between!'); } // console.log('行内是否',inBetween); if (inBetween) { inputCheck.checked = true; } }) 获取所有p元素，遍历双击事件 双击事件为removeTask 找到对应的任务路径，remove即可 123function removeTask(e){ console.log(e.path[1].remove());} 获取类名为add-icon的元素，监听点击事件，点击隐藏 使页面元素隐藏和显示可以有两种方式： 方式1：设置元素style属性中的display 123var t = document.getElementById('test');//选取id为test的元素t.style.display = 'none'; // 隐藏选择的元素t.style.display = 'block'; // 以块级样式显示 方式2：设置元素style属性中的visibility 123var t = document.getElementById('test');t.style.visibility = 'hidden'; // 隐藏元素t.style.visibility = 'visible'; // 显示元素 二者的区别在于设置display隐藏后不占用原来的位置，而visibility隐藏后元素位置任然被占用。 获取类型为text的input元素，监听change事件 change事件调用displayTask 动态插入html 使用createElement创建元素 使用append挂载元素 监听双击事件 123456789101112131415161718function displayTask(){ // 使用createElement创建元素 const newTaskItem = document.createElement('div'); newTaskItem.className = 'new-task-item'; const html = `&lt;div class=&quot;task-item&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;p&gt;${this.value}&lt;/p&gt;&lt;/div&gt;`; newTaskItem.innerHTML = html; newTask.append(newTaskItem); // console.log(newTask); // console.log(html); this.value = '' newTaskItem.addEventListener('dblclick',removeTask)} CSS部分 :checked 选择器 紧邻兄弟组合器：A+ B 组合器选择相邻元素，即后一个元素B紧跟在前一个A之后，并且共享同一个父节点 添加删除线 text-decoration: line-through; 项目知识点DOM 树DOM为文档对象模型，每个 HTML 标签都是一个对象。 DOM 将 HTML 表示为标签的树形结构。标签被称为 元素节点（或者仅仅是元素），并形成了树状结构：&lt;html&gt; 在根节点，&lt;head&gt; 和 &lt;body&gt; 是其子项，等。元素内的文本形成 文本节点，被标记为 ＃text。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。 利用JS修改文档 创建一个元素（DOM节点） document.createElement(tag)创建一个新 元素节点（element node） document.createTextNode(text)创建一个 文本节点 创建 div 分为 3 个步骤： 12345678// 1. 创建 &lt;div&gt; 元素let div = document.createElement('div');// 2. 将元素的类设置为 &quot;alert&quot;div.className = &quot;alert&quot;;// 3. 填充消息内容div.innerHTML = &quot;&lt;strong&gt;Hi there!&lt;/strong&gt; You've read an important message.&quot;; 这时已经创建了该元素。但到目前为止，它还只是在一个名为 div 的变量中，尚未在页面中。所以我们无法在页面上看到它。 append挂载元素 为了让 div 显示出来，我们需要将其插入到 document 中的某处。 append：document.body.append(div)。 node.append(...nodes or strings) —— 在 node 末尾 插入节点或字符串， node.prepend(...nodes or strings) —— 在 node 开头 插入节点或字符串， node.before(...nodes or strings) —— 在 node 前面 插入节点或字符串， node.after(...nodes or strings) —— 在 node 后面 插入节点或字符串， node.replaceWith(...nodes or strings) —— 将 node 替换为给定的节点或字符串。 JS30的第10个项目圆满完成啦，虽然对原项目做了一些改进，但是整体上也实现了一些我自己的独特功能。PS：中间跳了第7和9个项目，如果有时间我后面会补上滴！ 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/09/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Go-list-10/"},{"title":"【原生javascript项目】Video player 11","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第11天的“自定义视频播放器”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/videoPlayer/ 项目描述利用video标签，以及一些div标签，在js中设置视频的播放控件，包括暂停/播放，声音调节，视频进度调节，视频播放率，跳过/退后。 项目重点 video对象的各种属性、方法和事件 paused play() pause() currentTime volume playbackRate HTML DOM offsetWidth 属性 获取元素的宽度，包含内边距（padding）和边框（border）: HTML5 data-* 自定义属性 this.dataset. data- 项目过程html部分 video标签标记视频文件 div标签和button标签实现的一些视频控件，类名为.controlers .progress进度条，.progress_filled进度条填充颜色 .player_button播放按钮 声音滑块 播放速度滑块 前进/后退按钮 Js部分 获取标签 编写自定义函数 播放按键 12const method = video.paused ? 'play' : 'pause';video[method](); 更新播放键的按键 12const icon = this.paused ? '►' : '❚ ❚';toggle.textContent = icon; 前进/后退 1video.currentTime += parseFloat(this.dataset.skip); 更新滑块的值 1video[this.name] = this.value; 更新进度条（填充颜色） 12const percent = (video.currentTime / video.duration) * 100;progressBar.style.flexBasis = `${percent}%`; 鼠标移动进度条 12const scrubTime = (e.offsetX / progress.offsetWidth) * video.duration;video.currentTime = scrubTime; 添加监听事件 视频的click,play,pause,timeupdata事件 播放按钮、前进后退按钮的click事件 滑块的change,mousemove事件 进度条的click,mousemove,mousedown,mouseup事件 CSS部分 flex容器的项目属性 flex-basis：项目占据的主轴空间（main size） flex 属性选择器 input[type=range] 项目知识点data-*自定义数据属性，可通过所属元素的 HTMLElement 接口访问，确切地说是HTMLElement.dataset ， HTMLElement.dataset[&quot;testValue&quot;] 属性访问。 注*：data-后面的命名规则 该名称不能以xml开头，无论这些字母是大写还是小写； 该名称不能包含任何分号； 该名称不能包含A至Z的大写字母 data后面的命名中有-，如 data-test-value ，可通过 HTMLElement.dataset.testValue ( 或者是HTMLElement.dataset[&quot;testValue&quot;]) 来访问，任何短线符号都会被下个字母的大写替代(驼峰拼写)。 JS30的第11个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/18/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Video-player-11/"},{"title":"【原生javascript项目】Secret code sequence 12","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第12天的“字符序列检测”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/secretCode/ 键盘输入 happy 2022 即可触发彩蛋。 项目描述通过判断键盘输入的字符串中是否含有指定字符串序列，开启网页中的隐藏彩蛋。本项目的彩蛋是 从网页 Cornify.com 中加载一个 JS 文件，调用其中的 cornify_add() 方法时，随机在页面出加载独角兽的图标和p标签。 项目重点 window的keyup事件 window.addEventListener('keyup',) e.key 数组操作 .push() .splice() .length .join() .includes() 项目过程html部分 p标签标记一段提示的文字 Js部分 声明一个变量用来存储按下的字符串序列数组 声明一个变量用来存储已知的指定字符串序列 window的键盘监听事件 将字符串指定规则切分 1pressCode.splice(-secretCode.length - 1, pressCode.length - secretCode.length) 判断是否包含指定字符串 1if (pressCode.join('').includes(secretCode)){} 随机在页面中加载独角兽图标 1cornify_add(); 项目知识点js中的splice方法的使用说明splice方法可以用来对js的数组进行删除，添加，替换等操作。 删除。第一个参数为起始位置（如果为负数，表示倒数），第二个参数为要删除几个。 array.splice(index,num) 插入。第一个参数（插入位置），第二个参数（0），第三个参数（插入的项）。 array.splice(index,0,insertValue) 替换。第一个参数（起始位置），第二参数（删除项数），第三参数（插入任意数量的项）。 array.splice(index,num,insertValue) JS30的第12个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/20/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Secret-code-sequence-12/"},{"title":"【原生javascript项目】Slide in on scroll 13","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第13天的“图片随屏幕滚动而滑入滑出”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/sliderIn/ 项目描述本项目为一个图文浏览网页，其中，当浏览到图片时（屏幕滚动到图片上），图片具有滑入特效，浏览完毕后，图片滑出。滑入滑出特效由css的translateX()实现，触发特效有javascript控制。 项目重点 window的scroll事件 window.addEventListener('scroll') 一些位置（像素值） window.scrollY 文档当前垂直滚动的像素数 window.innerHeight viewport部分的高度 sliderImage.offsetTop 当前元素顶部相对于其 offsetParent 元素的顶部的距离 未枝丫博客有图解 debounce 的作用（函数防抖） 降低事件监听的频率，使用了 Lodash 中的 debounce 方法 项目过程html部分 p标签的文字 img标签的图片 JS部分 监听window的scroll事件 触发checkSlide函数 图片滑入条件：屏幕滚动位置以及屏幕高度之和 &gt; 图片顶部距离页面距离以及图片半高；屏幕滚动位置 &lt; 图片底部距离 1234const slideInAt = (window.scrollY + window.innerHeight);const imageBottom = sliderImage.offsetTop + sliderImage.height;const isHalfShown = slideInAt &gt; (sliderImage.offsetTop + sliderImage.height / 2);const isNotScrolledPast = window.scrollY &lt; imageBottom; 函数防抖 由于每次滚动都触发监听事件，会降低 JavaScript 运行性能，所以用 debounce 函数来降低触发的次数 1234567891011121314function debounce(func, wait = 20, immediate = true) { var timeout; return function() { var context = this, args = arguments; var later = function() { timeout = null; if (!immediate) func.apply(context, args); }; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); };}; CSS部分 屏幕滚动之前，图片的状态是：不透明度为0（隐藏），x方向偏移30%（相对于图片大小），缩放95%。 1234567.align-right.slide-in {transform: translateX(30%) scale(0.95);}.slide-in.active {opacity: 1;transform: translateX(0%) scale(1);} 触发特效，图片的状态是：不透明度为1，x方向偏移0%（相对于图片大小），缩放1。 1234.slide-in.active { opacity: 1; transform: translateX(0%) scale(1);} 项目补充元素浮动作用能够实现让多个元素排在问一行,并且给这些元素设置宽度与高度。 背景在标准文档流中的元素只有两种：块级元素和行内元素。让多个元素排在同一行：行内元素的特性；给这些元素设置宽高:块级元素的特性。如果想让一些元素既要有块级元素的特点也要有行内元素的特点，只能让这些元素脱离标准文档流（脱标），浮动可以让元素脱离标准文档流，可以实现让多个元素排在同一行并且可以设置宽高。 实现浮动通过浮动属性来实现，float这个属性有两个值left向左浮动，向左移动、right向右浮动，向右移动。 浮动元素的特性 浮动元素脱离标准文档流不再占用空间； 我们可以把浮动元素理解为“漂” 浮动元素的层级比标准文档流里面的元素层级要高,会将标准文档流中的元素给压盖住 行内素浮动后，变成块状元素 清除浮动：只要有浮动那么必须有清除浮动1 为什么要清除浮动? 因为经过浮动元素会影响到下面的元素的排版布局，浮动元素的父元素没有将浮动元素包裹，只要清除了浮动，就不会影响到浮动元素的下面进行排版布局，浮动元素的父元素会将浮动元素从视觉上包裹着。 2 清除浮动有以下三种方法: 给浮动元素的父元素设置一个固定的高度 使用清除浮动的样式属性 clear.（clear:left清除左浮动, clear: right:;清除右浮动 clear: both两者都清除）,这个属性一般用在最后一个浮动元素的下面,在最后一个浮动元素的下面（不是子级，而是并列下一行）新建一个空白的div,这个div什么内容都不要放,只做一件事件，就是清除浮动 使用 overflow: hidden这个属性来清除浮动 注意*：使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围 JS30的第13个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/30/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Slide-in-on-scroll-13/"},{"title":"【原生javascript项目】Reference VS copy 14","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第14天的“JS中引用和复制区别”项目。Have fun with the website! ♪(^∇^*) 项目描述本项目主要是在javascript中对比引用和复制变量的区别，效果在console（控制台）中显示。 项目重点 对于基础类型的值，存储的是值 number string boolean 对于复杂类型的值，存储的是引用（指针） arr object regx 对于复杂类型的值，如果实现复制 arr Array.prototype.slice() Array.prototype.concat() ES6 扩展语法 Array.from() 对象 Object.assign() JSON 转换 项目过程JS部分 首先从 String、Number、Boolean 类型的值开始。 12345let age = 100;let age2 = age;console.log(age, age2); // 100 100age = 200;console.log(age, age2); // 200 100 改动age不会影响age2。 对于数组 123456const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];const team = players;console.log(players, team);team[3] = 'Lux';console.log(players, team); // [&quot;Wes&quot;, &quot;Sarah&quot;, &quot;Ryan&quot;, &quot;Lux&quot;] [&quot;Wes&quot;, &quot;Sarah&quot;, &quot;Ryan&quot;, &quot;Lux&quot;] 对数组进行和Number类型相同的复制操作，发现改动team会改变players。 结论：基础类型（number,string,boolean）将内容直接存储在栈中（大小固定位置连续的存储空间），记录的是该数据类型的值，即直接访问，基础类型赋值是复制（copy）； 复杂类型（object即广义的对象类型（arr,object,regx））将内容存储在堆中，堆所对应的栈中记录的是指针（堆的地址），外部访问时先引出地址，再通过地址去找到值所存放的位置。复杂类型赋值是地址引用。 数组的复制 方法一 Array.prototype.slice() 123const team2 = players.slice();team2[3] = 'Lux2';console.log(players, team2); 方法二 Array.prototype.concat() 123const team3 = [].concat(players);team3[3] = 'Lux3';console.log(players, team3); 方法三 ES6 扩展语法 123const team4 = [...players];team4[3] = 'Lux4';console.log(players, team4); 方法四 Array.from() 123const team5 = Array.from(players);team5[3] = 'Lux5';console.log(players, team5); 对象的复制 方法一 Object.assign() 123456const person = { name: 'Wes Bos', age: 80 };const cap2 = Object.assign({}, person, { number: 99, age: 12 });console.log(cap2); // Object {name: &quot;Wes Bos&quot;, age: 12, number: 99} 方法二 JSON 转换 12345678910111213const wes = { name: 'Wes', age: 100, social: { twitter: '@wesbos', facebook: 'wesbos.developer' }};const dev = Object.assign({}, wes);const dev2 = JSON.parse(JSON.stringify(wes));console.log(wes);console.log(dev);console.log(dev2); 项目补充ES6扩展运算符符号：... 作用：将数组或对象进行展开 例如，对于数组arr=[1,2,3] console.log(…arr)相当于for循环把arr中每个元素打印一下。 参考博客1 js 值引用和值复制 2 对象引用和复制 3 总结 ES6 扩展运算符（…） 4 未枝丫的JS30博客 JS30的第14个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/31/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Reference-VS-copy-14/"},{"title":"【原生javascript项目】Local storage 15","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第15天的“JS window属性： localStorage ”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/localStorage/ 项目描述本项目是一个可添加项目的点菜清单，刷新网页时，菜单信息不会清空。实现该功能的主要技术是JavaScript Window 对象的localStorage属性。 项目重点 localStorage localStorage.setItem localStorage.getItem JS取消默认行为 event.preventDefault reset() 方法 把表单中的元素重置为默认值 JSON 的方法 JSON.stringify JSON.parse 项目过程HTML部分 网页logo &lt;svg&gt;标签 菜品清单内容 标题&lt;h2&gt; 菜单项目&lt;ul&gt; 添加菜品表单&lt;form&gt; 1234567891011&lt;div class=&quot;wrapper&quot;&gt; &lt;h2&gt;LOCAL TAPAS&lt;/h2&gt; &lt;p&gt;&lt;/p&gt; &lt;ul class=&quot;plates&quot;&gt; &lt;li&gt;Loading Tapas...&lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;add-items&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;item&quot; placeholder=&quot;Item Name&quot; required&gt; &lt;input type=&quot;submit&quot; value=&quot;+ Add Item&quot;&gt; &lt;/form&gt; &lt;/div&gt; CSS部分 菜品项目添加后默认复选框⬜️没有checked 1234.plates input + label:before {content: &quot;⬜️&quot;;margin-right: 10px;} 菜品项目checked后方框变成其他图标 123.plates input:checked + label:before {content: &quot;🌮&quot;;} JS部分 form表单中若有type 属性是 “submit”的元素，则具有submit 事件 1234function addItem(){ console.log('hello')}addItems.addEventListener('submit', addItem); 当点击form中的提交按钮时，会提交表单并且刷新页面（可在控制台中看出闪现hello），这种默认行为可以通过 e.preventDefault来阻止 123function addItem(e){ e.preventDefault();} 下面开始正式编写addItem函数，用来获取form中添加的元素，然后放到items变量中存储起来 this.querySelector('[name=item]')选择type为text元素的值（输入框输入的内容） 构造一个对象 item 来存储这个信息 把item push到提前创建的items（所有菜单）中 1234567const text = (this.querySelector('[name=item]')).value;// 构造一个对象 item 来存储这个信息item = { text, // ES6中对 text: text, 的简写 done:false // 标记有没有checked}items.push(item); 执行populateList(items, itemsList)函数，把新添加的菜品显示到页面中 更新localStorage中的items数据 重置输入框的值 123populateList(items, itemsList);localStorage.setItem('items', JSON.stringify(items));this.reset(); 编写populateList函数，实现将items中的信息挂载到DOM树上 &lt;input&gt;标签实现的复选框 data-index属性标记菜品序号 &lt;label&gt;标签记录菜单的文字 12345678910function populateList(plates = [], platesList) { platesList.innerHTML = plates.map((plate, i) =&gt; { return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=${i} id=&quot;item${i}&quot; ${plate.done ? 'checked' : ''} /&gt; &lt;label for=&quot;item${i}&quot;&gt;${plate.text}&lt;/label&gt; &lt;/li&gt; `; }).join('');} 程序写到这里基本完成，但是仔细观察会发现，如果checked每个菜品，刷新页面后，这个状态会被刷新（不被保留），这是因为我们并没有更新items中done的值 所以还需编写toggleDone函数，通过菜品click事件触发 e.target.dataset.index可以获取利用data-index属性标记菜品序号 !items[index].done否操作 更新localStorage和HTML页面 12345678910function toggleDone(e) { if (!e.target.matches('input')) return; // skip this unless it's an input // console.log(e.target) const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; localStorage.setItem('items', JSON.stringify(items)); populateList(items, itemsList); }itemsList.addEventListener('click', toggleDone); 项目补充HTML &lt;input&gt; 标签的 required 属性required 属性规定必需在提交之前填写输入字段 JS-preventDefault() 取消默认行为语法：event.preventDefault() 该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。 常用情景： 如果 type 属性是 “submit”，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。 标签在form表单中时，click事件默认会提交表单刷新页面，调用可方法，可避免刷新页面 a 标签点击时，会跳转url，采用如下方式，可防止链接打开 URL： 常用情景的知识点来源于博客 JSON.parse和JSON.stringifyJSON对象在所有现代浏览器中都适用，他有两个非常有用的方法是parse()和stringify(). JSON.parse() 把一个JSON字符串转变成JS对象 1234let userStr = '{&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;}';let userObj = JSON.parse(userStr);console.log(userObj);// {name: 'Sammy', email: 'sammy@example.com', plan: 'Pro'} JSON.parse() 第二个参数可以是一个自定义函数，具有返回值 123456789let userStr = '{&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;}';let userObj = JSON.parse(userStr, (key, value) =&gt; { if (typeof value === 'string') { return value.toUpperCase(); } return value;});console.log(userObj);// {name: 'SAMMY', email: 'SAMMY@EXAMPLE.COM', plan: 'PRO'} JSON.stringify() 把一个JS对象转变成JSON字符串 12345678let userObj = { name: &quot;Sammy&quot;, email: &quot;sammy@example.com&quot;, plan: &quot;Pro&quot;};let userStr = JSON.stringify(userObj);console.log(userStr);// {&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;} JSON.stringify()可以有两个额外参数 一个replacer参数（是一个自定义函数，函数名为replacer) 123456789101112131415let userObj = { name: &quot;Sammy&quot;, email: &quot;sammy@example.com&quot;, plan: &quot;Pro&quot;};function replacer(key, value) { console.log(typeof value); if (key === 'email') { return undefined; } return value;}let userStrReplacer = JSON.stringify(userObj, replacer);console.log(userStrReplacer);// {&quot;name&quot;:&quot;Sammy&quot;,&quot;plan&quot;:&quot;Pro&quot;} 一个是space参数（是 String 或者 Number 值），用来控制间距 如果是Number，缩进为空格数(1-10) 如果是String，缩进为该字符串 123456JSON.stringify({ uno: 1, dos: 2 }, null, '\\t');// returns the string:// '{// &quot;uno&quot;: 1,// &quot;dos&quot;: 2// }' map()和forEach()的区别和理解两个方法都可以实现元素遍历，但是map方法可以用返回值，而forEach方法没有返回值 参考博客 JS-preventDefault() 取消默认行为 How To Use JSON.parse() and JSON.stringify() Example of using JSON.stringify() with localStorage map()和forEach()的区别和理解 JS30的第15个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/04/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Local-storage-15/"},{"title":"【原生javascript项目】Mouse Move Shadow 16","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第16天的“文字阴影随鼠标移动”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/mouseMoveShadow/ 项目描述本项目实现的是一个文字阴影随鼠标位置移动的特效。其中文字阴影是通过添加CSS的text-shadow属性实现的，为了让文字阴影随鼠标位置移动，需要获取当前鼠标的位置，通过一些转化变成对应的文字阴影位置。 项目重点 CSS的text-shadow属性 text-shadow: 10px 10px 0 rgba(0,0,0,1), 10px 20px 0 rgba(200,0,0,1); HTMLElement的一些只读属性 offsetWidth offsetHeight offsetLeft offsetTop 鼠标事件的一些属性 offsetX offsetY 项目过程HTML部分 类名为hero的div元素 h1标签，加了contenteditable属性，表示浏览网页的用户可以编辑 CSS部分 让网页主题内容水平、垂直居中 123display: flex;justify-content: center;align-items: center; 让文字具有阴影（后面再JS中会修改） 12345h1 { text-shadow: 10px 10px 0 rgba(0,0,0,1); /* text-shadow: 10px 10px 0 rgba(0,0,0,1), 10px 20px 0 rgba(200,0,0,1); */ font-size: 100px;} JS部分 首先创建三个变量，一个指向类名为hero的元素，一个指向h1元素，最后一个变量walk用来存储文字阴影距离原文字最大距离的一半。 监听hero上的mouseover的事件，回调函数为shadow 回调函数要实现的是，获取鼠标移动事件的位置offsetX和offsetY，通过一些公式将这两个位置变成新的位置信息，然后修改CSS样式上的text-shadow属性。 首先设置变量width和height存储hero元素的宽高信息 设置变量x和y存储鼠标移动事件的位置信息 12const { offsetWidth: width, offsetHeight: height } = hero;let { offsetX: x, offsetY: y } = e; 这里的写法采用了ES6的**解构赋值写法**，语句let { offsetX: x, offsetY: y } = e;等同于let x = e.offsetX; let y = e.offsetY; offsetX/offsetY：鼠标位置（相对于最近父元素的坐标） offsetWidth/offsetHeight：元素的宽高（width+padding+border） 转换的公式如下所示，其中x/width是一个比例系数 12const xWalk = Math.round((x / width * walk) - (walk / 2));const yWalk = Math.round((y / height * walk) - (walk / 2)); 利用JS修改CSS中的text-shadow属性，具体来说有四个文字阴影，分布在text的四个角落 123456text.style.textShadow = `${xWalk}px ${yWalk}px 0 rgba(255,0,255,0.7),${xWalk * -1}px ${yWalk}px 0 rgba(0,255,255,0.7),${yWalk}px ${xWalk * -1}px 0 rgba(0,255,0,0.7),${yWalk * -1}px ${xWalk}px 0 rgba(0,0,255,0.7)`; 程序写到这里会出现一个bug，当鼠标移动到h1时，文字阴影没有在文字中聚焦，这是因为鼠标移动到h1时，offsetX表示的是相对于h1的位置；当鼠标移动在hero上时，offsetX表示的是相对于hero的位置。 所以还需要添加在shadow函数中，首先需要做个条件判断 1234if (this !== e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop;} 写到这里程序就大体完成啦！具体代码我放在了github上。 项目补充JavaScript中event.target与this区别this一直指向函数的调用者，在本程序中，鼠标无论移动到hero上还是h1上，console.log(this)显示的一直是 123&lt;div class=&quot;hero&quot;&gt; &lt;h1 contenteditable style=&quot;text-shadow: rgba(255, 0, 255, 0.7) 241px 101px 0px, rgba(0, 255, 255, 0.7) -241px 101px 0px, rgba(0, 255, 0, 0.7) 101px -241px 0px, rgba(0, 0, 255, 0.7) -101px 241px 0px;&quot;&gt;🔥WOAH!&lt;/h1&gt;&lt;/div&gt; 而event.target指向的是触发该事件的目标节点，在本程序中，鼠标移动到hero上，显示内容和上述一样，但是移动到h1上时，显示内容为 1&lt;h1 contenteditable style=&quot;text-shadow: rgba(255, 0, 255, 0.7) 241px 101px 0px, rgba(0, 255, 255, 0.7) -241px 101px 0px, rgba(0, 255, 0, 0.7) 101px -241px 0px, rgba(0, 0, 255, 0.7) -101px 241px 0px;&quot;&gt;🔥WOAH!&lt;/h1&gt; 因此，this与event.target的区别为当含有事件冒泡时，this一直指向该函数的调用者，而event.target则指向触发该事件的目标节点 ES6 解构赋值解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。 以前，为变量赋值，只能直接指定值。 123var a = 1;var b = 2;var c = 3; ES6允许写成下面这样。 1var [a, b, c] = [1, 2, 3]; 上述为数组赋值。 对于对象赋值，可以写成在这样 1var { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; 如果变量名与属性名不一致，必须写成下面这样 1234let obj = { first: 'hello', last: 'world' };let { first: f, last: l } = obj;f // 'hello'l // 'world' 参考博客 ES6 变量的解构赋值 JavaScript中event.target与this区别 JS30的第16个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/10/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Mouse-Move-Shadow-16/"},{"title":"【原生javascript项目】Sort without Articles 17","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第17天的“去除冠词排序”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/sortWithoutArticles/ 项目描述本项目首先给定了一个内容为band名字的列表bands，在JS中，对列表进行特殊的排序操作，得到新的列表最终以列表的形式显示到网页中。 其中特殊的排序操作，具体来说，是先去除列表元素中”a, an, the”的前缀，然后按照字母排序。排序的列表还是原列表，无需使列表元素去除特定前缀。 项目重点 字符串的一些方法 String.prototype.replace() String.prototype.trim() 数组的一些方法 Array.prototype.sort() 正则表达式 /^(a |the |an )/i 项目过程HTML部分 id 属性为bands的ul元素，列表内容在JS中添加 JS部分 首先提供一个已知列表bands 将列表bands内容显示到网页中 1document.querySelector('#bands').innerHTML = bands.map(band =&gt; `&lt;li&gt;${band}&lt;/li&gt;`).join(''); 显示已经实现，下一步我们需要对bands进行一些操作，得到的新列表再按照上述方法显示到网页中。注意：无需对原列表bands进行操作，也就是不用改变bands的值 去除前缀 123function strip(bandName){ return bandName.replace(/^(a |the |an )/i,'').trim();} 排序 12345const sortedBands = bands.sort( function(a,b){ return strip(a) &gt; strip(b) ? 1 : -1 }) 程序写到这里就已经ok啦！本项目需要注意的是最后显示的内容还是原bands中的元素，但是排序方式要求去掉前缀后排序。 如果项目要求最后显示的内容是去除前缀的元素，那么下面的程序提供了一个实现思路： 去除前缀 123456// 先将bands元素中开头为a|the|an的去掉前缀，返回新的bandsfunction newBands(bands){ return bands.map(band =&gt; { return band.replace(/^(a |the |an )/i,'').trim(); })} 排序 1const sortedBands = newBands(bands).sort() 项目补充String.prototype.replace()replace(pattern,replacement) 方法返回一个新字符串，该字符串由replacement替换部分或所有的pattern匹配项后的新字符串。 pattern可以是一个字符串或者一个正则表达式，replacement可以是一个字符串或者一个每次匹配都要调用的回调函数。 如果pattern是字符串，则仅替换第一个匹配项。 原字符串不会改变。 语法1str.replace(regexp|substr, newSubStr|function) String.prototype.trim()从一个字符串的两端删除所有空白字符。 Array.prototype.sort()1arr.sort([compareFunction]) 主要讲讲有compareFunction的情况，该函数具有两个参数a,b。 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 例如比较数字，compareFunction函数可以简单的以 a 减 b，如下的函数将会将数组升序排列 1234567function compareNumbers(a, b) { return a - b;}// 也可以这样些function compareNumbers(a, b) { return a &gt; b ? 1 : -1;} 正则表达式的特殊字符 ^匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。 例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 参考博客 正则表达式中的特殊字符 JS30的第17个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/14/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Sort-without-Articles-17/"},{"title":"【原生javascript项目】Time with Redece 18","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第18天的“利用reduce进行时间累加”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/18%20timeWithReduce/index.html 项目描述项目首先在html中提供了若干个属性名为data-time的列表元素，data-time的值以00:00（分：秒）的格式显示。要求在JS中计算出data-time的总值，并且用？时？分？秒的格式显示结果。 项目重点 Array.from() timeNode.dataset.time .split(':') .map(parseFloat) .reduce() Math.floor() 项目过程HTML部分 若干个li标签，添加了data-time属性 JS部分JS的整体思路是先获取所有的data-time的值，然后将所有值转化成秒，并且计算出的总秒数。根据总秒数得到对应的时、分、秒。 为了显示最后的结果，在本项目中国通过创建一个p元素来实现。 获取所有的data-time元素，转化成数组，并存储在timeNodes变量中 1const timeNodes = Array.from(document.querySelectorAll('[data-time]')); 从timeNodes中可以得到data-time的值 123const seconds = timeNodes.map( timeNode =&gt; timeNode.dataset.time) 将每个data-time的值转化成秒 1234567.map( timeCode =&gt; { const [min, sec] = timeCode.split(':').map(parseFloat) // console.log(typeof(min),sec) return (min*60)+sec }) 利用reduce方法累加得到总秒数 123.reduce( (total,vidSecond) =&gt; total + vidSecond) 根据总秒数，计算出时、分、秒 123456let leftSec = seconds;const hour = Math.floor(leftSec/3600);leftSec = leftSec % 3600;const min = Math.floor(leftSec/60);leftSec = leftSec % 60; 新建一个p元素，添加显示内容，最后挂载到网页上，显示结果 1234567891011function display(hour,min,leftSec){ // 使用createElement创建元素 const newTaskItem = document.createElement('p'); newTaskItem.className = 'total-time'; const html = ` 总播放时间为：${hour}小时${min}分${leftSec}秒。`; newTaskItem.innerHTML = html; document.querySelector('ul').before(newTaskItem);} 项目补充Array.from：将一个伪数组对象转化成数组。 .split()：将一个String对象分割成子字符串数组 parseFloat(string)将字符串解析为浮点数 如果 parseFloat 在解析过程中遇到了正号（+）、负号（- ）、数字（0-9）、小数点（.）、或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。 第二个小数点的出现也会使解析停止。 参数首位和末位的空白符会被忽略。 如果字符串的第一个字符不能被解析成为数字，则返回 NaN。 parseFloat 也可以解析并返回 Infinity。 reduce方法语法1arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) initialValue为作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 示例123[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue){ return accumulator + currentValue;}); // 10 JS30的第18个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/15/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Time-with-Redece-18/"},{"title":"【原生javascript项目】WebCam Fun 19","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第19天的“网络摄像头”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/19%20webCamFun/index.html 项目描述通过访问网络摄像头，获取了当前摄像头拍摄的信息，作为video元素的内容。video元素中的视频信息被定时器一帧一帧绘制在canvas元素中。 提供了一个名为take photo的按钮用来抓取当前视频帧的内容，该内容最后通过通过创建a标签显示在网页中。 项目重点 mediaDevices.getUserMedia video属性和方法 video.videoWidth video.srcObject setInterval canvas.toDataURL HTML DOM setAttribute(属性名，值) canplay事件 项目过程HTML部分 最外层为类名为photobooth的div元素 作为控件的div元素：take photo按钮 canvas元素用来绘制video的视频帧 video元素用来播放从网络摄像头获取的数据流 音频audio标签 JS部分JS的大致思路是： 请求调用网络摄像头 摄像头中的数据流给video元素 在canvas上绘制video的内容 点击take photo按钮获取当前canvas上的画面，显示到网页上 编写getVideo函数：访问网络摄像头的权限,播放视频，放在video标签里 1234567891011function getVideo(){ navigator.mediaDevices.getUserMedia({ video: true, audio: false }) .then(localMediaStream =&gt; { console.log(localMediaStream); video.srcObject = localMediaStream; video.play(); }) .catch(err =&gt; { console.error(`OH NO!!!`, err); }); } 把视频信息放到canvas中 先获取视频的宽高信息，复制给canvas.width和height，保证canvas上显示视频画面完整（注意这里并不是设置canvas在网页上显示的宽高） canvas流畅显示的机制是利用定时器不断获取当前video的内容 利用ctx.drawImage实现绘制 123456789101112function paintToCanvas(){ const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; // canvas上显示的机制是利用定时器，将视频中当前帧的图像绘制在canvas上 return setInterval(() =&gt; { ctx.drawImage(video, 0, 0, width, height); }, 16);}video.addEventListener('canplay', paintToCanvas); 编写take photo的点击函数 播放音效 获取当前canvas的data，变成图片 创建元素，显示到网页中 12345678910111213function takePhoto(){ // 播放音频 snap.currentTime = 0; snap.play(); // 获取当前canvas的data，变成图片 const data = canvas.toDataURL('image/jpeg'); const link = document.createElement('a'); link.href = data; link.setAttribute('download', 'handsome'); link.innerHTML = `&lt;img src=&quot;${data}&quot; alt=&quot;Handsome Man&quot; /&gt;`; strip.insertBefore(link, strip.firstChild);} 项目补充HTML 音频/视频 DOM canplay 事件当浏览器能够开始播放指定的音频/视频时，触发canplay 事件 常用CSS的长度单位（相对/绝对） 单位 名称 em 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width rem 根元素的字体大小 vw 视窗宽度的1% vh 视窗高度的1% px 像素 navigator.mediaDevices.getUserMedia提示用户允许一个媒体输入（视频、音频等），媒体输入会产生一个mediaStream包换了媒体信息。该方法返回一个promise 示例 1234567navigator.mediaDevices.getUserMedia(constraints).then(function(stream) { /* use the stream */}).catch(function(err) { /* handle the error */}); 其中constrains参数可为{ audio: true, video: true } X:after 选择器在元素内部的后面插入内容。常用来清楚浮动clear-fix。 123456789101112.clearfix:after { content: &quot;&quot;; display: block; clear: both; visibility: hidden; font-size: 0; height: 0; } .clearfix { *display: inline-block; _height: 1%; } 原理是使用:after伪类元素来在元素后增加一个空间，然后清除它。 overflow-xoverflow-x 属性规定是否对内容的左/右边缘进行裁剪，如果溢出元素内容区域的话。 overflow-y 属性对上/下边缘的裁剪。 a:nth-child(5n+1)选择第1、6、11…个a标签 利用canvas操纵video获取到video的每一帧内容后，绘制在canavs上。这是显示的第一步，除此之外，还可以做一些进阶，比如将每一帧画面。 1let pixels = ctx.getImageData(0, 0, width, height); JavaScript 定时器 setTimeout()：指定多久时间运行回调函数 123setTimeout(() =&gt; { // 2 秒之后运行}, 2000) setTimeout 会返回定时器的 id。 通常不使用它，但是可以保存此 id，并在要删除此安排的函数执行时清除它： 12345const id = setTimeout(() =&gt; { // 应该在 2 秒之后运行}, 2000)// 改变主意了clearTimeout(id) setInterval()：指定多少时间间隔运行一次回调函数 123setInterval(() =&gt; {// 每 2 秒运行一次}, 2000) 问题：这里如何清除定时器呢？每次触发video的canplay事件，会执行paintToCanvas函数，而该函数可以返回定时器的id。如果要清除该定时器，怎么清除呢？ 参考博客 30个你必须记住的CSS选择符 探索 JavaScript 定时器 JS设置定时器和清除定时器 JS30的第19个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/16/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91WebCam-Fun-19/"},{"title":"【原生javascript项目】Speech Detetion 20","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第20天的“语音检测”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/20%20speechDetection/index.html 项目描述本项目是一个语音识别系统，网页首先会向用户请求麦克风权限，允许后可识别出用户的speech（语言为每个英语en-US')，并显示在网页中。 本项目用到的语音识别系统是Web Speech API，只能在 Chrome浏览器上使用，而且功能也一直在完善中，因此，本项目只是提供一种语音识别系统的解决思路，以便参考。 项目重点 Web Speech API SpeechRecognition 接口 SpeechRecognition.interimResults SpeechRecognition.lang SpeechRecognition.start() new SpeechRecognition() result事件 e.results result.transcript e.results[0].isFinal p.textContent end事件 项目过程HTML部分只有一个div元素，可编辑contenteditable 1&lt;div class=&quot;words&quot; contenteditable&gt;&lt;/div&gt; JS部分JS的大致思路是： 添加Chrome support 定义语音识别实例 开启语音识别功能 监听result事件，实时获取捕获到的speech，并通过创建元素的方法显示到网页中 监听end事件，当语音捕获结束后，重新开启语音识别功能 Chrome support SpeechRecognition 接口只能在 Chrome浏览器上使用，，因此需要适配Chrome浏览器的对象以及未来其他浏览器也能使用的一些修正 1window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 定义语音识别实例 1const recognition = new SpeechRecognition(); 创建一个p元素，后面可以讲识别到的语音放进去 123const p = document.createElement('p');const words = document.querySelector('.words');words.appendChild(p); 打开语音识别功能，监听result事件，实时获取捕获到的speech，并显示到网页中 1234567891011121314recognition.addEventListener('result',e =&gt; { const transcript = Array.from(e.results) .map(result =&gt; result[0]) .map(result =&gt; result.transcript) .join(''); p.textContent = transcript; // console.log(e.results[0].transcript) if (e.results[0].isFinal) { p = document.createElement('p'); words.appendChild(p); }});recognition.start(); // 打开语音功能 监听end事件，当语音捕获结束后，重新开启语音识别功能 1recognition.addEventListener('end', recognition.start); 项目补充Web Speech API 语音识别和语音输出主要的语音识别接口是SpeechRecognition 接口，只能在 Chrome浏览器上使用 SpeechRecognition 接口的一些属性： SpeechRecognition.interimResults：设置语音识别系统是否返回中间结果，还是最终结果 SpeechRecognition.lang: 设置语音识别系统的语言 innerText、textContent和innerHTML三者的区别innerText、textContent和innerHTML可以设置标签中的文本内容。 不同点 innerHTML可以将内容中的标签为标签，而其他两个则不行，只是纯文本 innerText，textContent获取的是该标签和该标签下子标签中的文本内容 12345678910111213141516171819202122232425&lt;div id=&quot;mylinks&quot;&gt; This is my &lt;b&gt;link collection&lt;/b&gt;: &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;www.borland.com&quot;&gt;Bye bye &lt;b&gt;Borland&lt;/b&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;www.microfocus.com&quot;&gt;Welcome to &lt;b&gt;Micro Focus&lt;/b&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; const dv = document.getElementById(&quot;mylinks&quot;); console.log(dv.textContent); // This is my link collection: // Bye bye Borland // Welcome to Micro Focus console.log(dv.innerText); // This is my link collection: // Bye bye Borland // Welcome to Micro Focus console.log(dv.innerHTML); // This is my &lt;b&gt;link collection&lt;/b&gt;: // &lt;ul&gt; // &lt;li&gt;&lt;a href=&quot;www.borland.com&quot;&gt;Bye bye &lt;b&gt;Borland&lt;/b&gt; &lt;/a&gt;&lt;/li&gt; // &lt;li&gt;&lt;a href=&quot;www.microfocus.com&quot;&gt;Welcome to &lt;b&gt;Micro Focus&lt;/b&gt;&lt;/a&gt;&lt;/li&gt; // &lt;/ul&gt; &lt;/script&gt; let var const区别var 声明会变量提升 let 块级作用域，声明不会变量提升 const 块级作用域声明的变量为常量，值不可修改 更多内容见参考博客[2-4] CSS position 值 relative 相对自己原来（正常文档流）的位置 absolute 脱离文档流，相对于最近的已定位父元素 fixed 脱离文档流，相对于浏览器窗口是固定位置 sticky 基于用户的滚动位置来定位。行为就像 relative，而当页面滚动超出目标区域时，它的表现就像 fixed，固定在目标位置。 static HTML 元素的默认值，即没有定位，遵循正常的文档流对象。 参考博客 innerText、textContent和innerHTML三者的区别 一看就懂的var、let、const三者区别 var、let和const的区别详解 块作用域 JS30的第20个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/22/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Speech-Detetion-20/"},{"title":"【原生javascript项目】Geolocation 21","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第21天的“地理位置”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/21%20geoLocation/index.html 项目描述本项目是一个可视化的指南，利用网络地址位置Web Geolocation API获取的地理位置和速度。 本项目的JS代码相对比较简单，但是由于电脑一般没有速度及方向传感器，所以实际的功能并没显示出来，只是提供了一种实现途径。 项目重点 Geolocation.watchPosition() API .coords.speed .coords.heading CSS radial-gradient background-attachment设置背景图是否固定不到 项目过程HTML部分 svg图片元素 h1元素 类名为speed-value span标签 类名为speed-unit span标签 CSS部分 设置背景图片 radial-gradient由圆心向外的径向的颜色渐变 1radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 0 1px JS部分JS的大致思路是： 请求调用Geolocation接口 获取当前的地理位置信息data 显示速度信息 data.coords.speed 改变页面中指南针的朝向 data.coords.heading 具体代码如下： 12345678navigator.geolocation.watchPosition((data) =&gt; { console.log(data); speed.textContent = data.coords.speed; arrow.style.transform = `rotate(${data.coords.heading}deg)`;}, (err) =&gt; { console.error(err);}); 项目补充Geolocation接口 ：获取设备的地理位置信息方法 1：Geolocation.getCurrentPosition() 获取当前的位置信息 方法 2：Geolocation.watchPosition() 返回位置变化后的最新信息 方法 3：Geolocation.clearWatch() 删除使用watchPosition()后的句柄 JS30的第21个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/24/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Geolocation-21/"},{"title":"【原生javascript项目】Link Highlighter 22","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第22天的“链接高亮显示”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/22%20linkHighlighter/index.html 项目描述本项目页面主要有一个导航栏菜单和正文内容组成。页面实现的效果是：当鼠标进入a标签时，背景颜色以白色高亮显示，当鼠标移到下一个a标签时，白色高亮块上一个a标签中移动下来。 项目重点 Element.getBoundingClientRect() window.scrollY mouseenter事件 项目过程HTML部分 nav标签包裹的导航栏菜单 ul标签 5个li标签，为菜单内容 类名为wrapper的div标签包含了正文内容 链接用a标签标记，在JS中要实现高亮显示 CSS部分使用如下技巧将外边距和内边距重置为零 123*, *:before, *:after { box-sizing: inherit;} 高亮块的CSS样式，基本思路是加上绝对定位（相对于最近定位的父元素定位，在这里父元素是body），通过在JS中改变top和left以及width和height属性，来呈现不同链接选中的状态。 123456789101112.highlight{ transition: all 0.2s; border-bottom: 2px solid white; position: absolute; top: 0; background: white; left: 0; z-index: -1; border-radius: 20px; display: block; box-shadow: 0 0 10px rgba(0,0,0,0.2);} JS部分JS的大致思路是： 获取链接标签，以及创建span标签，用来添加highlight样式 1234const triggers = document.querySelectorAll('a');const highlight = document.createElement('span');highlight.classList.add('highlight');document.body.appendChild(highlight); 获取当前鼠标进入的链接元素的位置信息 修改类名为highlight的样式 给a标签添加鼠标进入mouseenter事件 获取链接标签，以及创建span标签，用来添加highlight样式 1234567891011121314function highlightter(){ const link = this.getBoundingClientRect(); console.log(link); const linkCoordinates ={ width:link.width, height:link.height, top:link.top+window.scrollY, left:link.left+window.scrollX }; highlight.style.width = `${linkCoordinates.width}px`; highlight.style.height = `${linkCoordinates.height}px`; highlight.style.transform = `translate(${linkCoordinates.left}px,${linkCoordinates.top}px)`;}triggers.forEach(a =&gt; a.addEventListener('mouseenter', highlightter)); 项目补充Element.getBoundingClientRect()返回一个DOMRect对象，包含了元素的大小、相对于视口的位置信息。 DOMRect相关只读属性 Attribute Description height 矩形盒子的高度 width 矩形盒子的宽度 top Y 轴，相对于视口原点（viewport origin）顶部 left X 轴，相对于视口原点左侧 bottom Y 轴，相对于视口原点底部 right X 轴，相对于视口原点右侧 x 盒子左上角位置的X轴横坐标 y 盒子左上角位置的Y轴横坐标 window.scrollY鼠标滑动的垂直距离 window.scrollX 鼠标滑动的水平距离 mousemove, mouseenter 和mouseover区别mousemove：鼠标指针进入div以及其子元素时触发； mouseenter：鼠标指针进入div时触发； mouseover：鼠标每次滑过div时触发 点击此链接体验三者的效果 👉 体验 JS30的第22个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/25/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Link-Highlighter-22/"},{"title":"【原生javascript项目】Speech Synthesis 23","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第23天的“语音合成”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/23%20speechSynthesis/index.html 项目描述利用SpeechSynthesisUtterance接口等实现的语音合成项目，其中设有rate和pitch滑块可改变朗读速度和音高，stop和speech按钮用来控制朗读的开始和暂停。朗读的文本内容可以在文本框中自行输入。 项目重点 SpeechSynthesisUtterance接口 speechSynthesisUtterance.lang SpeechSynthesisUtterance.pitch SpeechSynthesisUtterance.rate SpeechSynthesisUtterance.text ``SpeechSynthesisUtterance.name` SpeechSynthesis接口 voiceschanged事件 SpeechSynthesis.getVoices() speechSynthesis.cancel() SpeechSynthesis.speak() 项目过程HTML部分 h1标签 select多选菜单 123&lt;select name=&quot;voice&quot; id=&quot;voices&quot;&gt; &lt;option value=&quot;&quot;&gt;Select A Voice&lt;/option&gt;&lt;/select&gt; 两个范围input控件，用来调控rate和speed 1234&lt;label for=&quot;rate&quot;&gt;Rate:&lt;/label&gt;&lt;input name=&quot;rate&quot; type=&quot;range&quot; min = 0 max = &quot;3&quot; value=&quot;1&quot; step=&quot;0.1&quot;&gt;&lt;label for=&quot;pitch&quot;&gt;Rate:&lt;/label&gt;&lt;input name=&quot;pitch&quot; type=&quot;range&quot; min=&quot;0&quot; max=&quot;2&quot; step=&quot;0.1&quot;&gt; 输入文本框，朗读内容 1&lt;textarea name=&quot;text&quot;&gt;Hey, my name is Iaine, nice to meet you&lt;/textarea&gt; 两个按钮，用来暂停朗读和开始朗读 12&lt;button id=&quot;stop&quot;&gt;Stop&lt;/button&gt;&lt;button id=&quot;speak&quot;&gt;Speak&lt;/button&gt; JS部分JS的大致思路是： 使用相应WebAPI接口获得浏览器支持的语言种类列表，填充至下拉菜单中； 在文本域中输入对应语言的文字，点击speak按钮后浏览器会阅读输入的文字； 在浏览器阅读时，点击stop按钮，浏览器会停止阅读； 拖动rate和pitch滑块可改变阅读速度和音高。 取得speechSynthesis对象，获取浏览器支持朗读语言，将所有选项动态添加至下拉列表 1234567891011const speechSynthesis = window.speechSynthesis;let voices=[];function populateVoices(){ voices = this.getVoices(); voicesDropdown.innerHTML = voices .map(voice =&gt; `&lt;option value=&quot;${voice.name}&quot;&gt;${voice.name} (${voice.lang})&lt;/option&gt;`) .join(''); console.log(voices)} speechSynthesis.addEventListener('voiceschanged', populateVoices); 设置下拉列表当前显示的语言，选择好语言后触发朗读 12345678910111213const voicesDropdown = document.querySelector('[name = &quot;voice&quot;]');function setVoice(){ msg.voice = voices.find(voice =&gt; voice.name === this.value); toggle();}// 发出语音function toggle(startOver = true) { speechSynthesis.cancel(); if (startOver) { speechSynthesis.speak(msg); }}voicesDropdown.addEventListener('change', setVoice); 点击speech按钮朗读，stop按钮停止 1234const speakButton = document.querySelector('#speak');const stopButton = document.querySelector('#stop');speakButton.addEventListener('click', toggle);stopButton.addEventListener('click', () =&gt; toggle(false)); 构建SpeechSynthesisUtterance实例，添加pitch,text, speed,name属性 123456789101112const msg = new SpeechSynthesisUtterance();msg.text = document.querySelector('[name=&quot;text&quot;]').value;const options = document.querySelectorAll('[type=&quot;range&quot;],[type = &quot;text&quot;]');function setOption(){ msg[this.name] = this.value; toggle();}options.forEach(option =&gt; option.addEventListener('change', setOption));function updateText(){ msg.text = document.querySelector('[name=&quot;text&quot;]').value;}document.querySelector('[name=&quot;text&quot;]').addEventListener('change', updateText); 项目补充SpeechSynthesisUtterance接口属于 Web Speech API 的一个接口，可以发出speech请求。 构造器1SpeechSynthesisUtterance.SpeechSynthesisUtterance() 返回一个新的 SpeechSynthesisUtterance 实例对象。 属性 SpeechSynthesisUtterance.lang (en-US) 获取或设置朗读的语言 SpeechSynthesisUtterance.pitch (en-US) 获取或设置朗读的音调 SpeechSynthesisUtterance.rate (en-US) 获取或设置朗读的速率 SpeechSynthesisUtterance.text (en-US) 获取或设置朗读的文本内容 SpeechSynthesisUtterance.voice 获取或设置朗读的voice SpeechSynthesisUtterance.volume (en-US) 获取或设置朗读的音量 SpeechSynthesis 接口属于 Web Speech API 的一个控制speech服务的接口，可以返回设备合成声音的信息，开始或者暂停speech等。 只读属性SpeechSynthesis.paused ：SpeechSynthesis对象是否暂停状态 SpeechSynthesis.pending ： utterance queue 是都还有没有余留没有读的 utterance。 SpeechSynthesis.speaking：一个utterance是否在被读的阶段 方法 SpeechSynthesis.cancel() 移除utterance queue队列中所有的utterances SpeechSynthesis.getVoices() 返回现有设备所有可用的voices的 SpeechSynthesisVoice 对象 SpeechSynthesis.pause() 把 SpeechSynthesis 对象放在暂停状态 SpeechSynthesis.resume() 把 SpeechSynthesis 对象放在重新打开状态 SpeechSynthesis.speak() 在utterance queue队列中增加一个utterance 事件voiceschanged 在SpeechSynthesis.getVoices()方法返回的SpeechSynthesisVoice 对象变化的时候触发 注意：SpeechSynthesisUtterance接口和SpeechSynthesis接口的关系 二者都属于Web Speech API 接口 前者是设置朗读的配置参数，包括语言，速度，语调，内容等 后者是控制朗读的行为，包括获取浏览器支持的朗读语言，文本朗读，暂停，停止等 CSS知识补充 :nth-of-type()伪类选择器，匹配相同类型（也就是相同标签）的元素 和:nth-child区别在于后者不是同类。 calc()方法 允许计算 JS30的第23个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/25/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Speech-Synthesis-23/"},{"title":"【原生javascript项目】Sticky Nav 24","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第246天的“粘贴导航栏”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/24%20stickyNav/index.html 项目描述本项目主要亮点在于实现导航栏的位置粘贴固定，此外，当鼠标滚动导航栏（本来）消失时，除了要固定导航栏，还要加一点其他样式。 技术要点是通过scroll事件中，判断窗口位置和当前导航栏的位置，如果前者大于或等于后者，则通过添加一个类名'fixed-nav'（其样式事先在CSS中完善），来实现上述两亮点。 当前者小于后者，则移除'fixed-nav'类名。 项目重点 scroll事件 window.scrollY &gt;= topOfNav nav.offsetTop document.body.classList.add() document.body.classList.remove() position: fixed 项目过程HTML部分 header标题 nav导航栏菜单 .site-wrap正文 JS部分JS的大致思路是： 监听页面滚动事件 判断页面当前滚动位置，如果大于等于导航栏距离窗口顶部位置时，则通过添加类名 否则移除类名 该类名的样式在CSS中设置好，原理在于position设置为fix 12345678910111213const nav = document.querySelector('#main');let topOfNav = nav.offsetTop;function fixNav() { if (window.scrollY &gt;= topOfNav) { // document.body.style.paddingTop = nav.offsetHeight + 'px'; document.body.classList.add('fixed-nav'); } else { document.body.classList.remove('fixed-nav'); document.body.style.paddingTop = 0; }}window.addEventListener('scroll', fixNav); 项目补充text-align: justify均匀分布，有点像word软件的“两端对齐”。 JS30的第24个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/26/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Sticky-Nav-24/"},{"title":"【原生javascript项目】Event Capture 25","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第25天的“语音合成”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/25%20eventCapture/index.html 项目描述本项目主要目的是理解事件的捕获、传播、冒泡、单次触发等机制。首先提供3个尺寸颜色不一的&lt;div&gt;元素，通过点击事件来理解上述内容。 项目重点 capture once 项目过程JS部分 冒泡 当点击某个div时，自该div起以及其外层的div也将监听到点击事件。 例如，点击第3个div（最内层的），控制台显示的结果是three,two,one。 12345const divs = document.querySelectorAll('div');function textLog(){ console.log(this.classList.value);}divs.forEach(div=&gt;div.addEventListener('click',textLog)); 捕获 点击某个div时，从不具体的div元素到最具体的元素（被点击的元素）从上到下监听到点击事件。 例如，点击第3个div（最内层的），控制台显示的结果是one,two,three。 123divs.forEach(div=&gt;div.addEventListener('click',textLog,{ capture: true })); 停止事件继续传递 在冒泡的基础上，加上e.stopPropagation();来设置不再继续传播 1234567function textLog(e){ console.log(this.classList.value); e.stopPropagation();}divs.forEach(div=&gt;div.addEventListener('click',textLog,{ capture: false})); Once：允许事件触发一次，之后相当于removeEventListener。 1234567function textLog(e){ console.log(this.classList.value);}divs.forEach(div=&gt;div.addEventListener('click',textLog,{ capture: false, once:true})); 项目补充事件冒泡事件开始由最精确的元素触发，逐级向上传播到其他节点 事件捕获事件由不太具体的节点传播到最具体的节点 参考博客 事件流 JS30的第25个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/27/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Event-Capture-25/"},{"title":"【原生javascript项目】Strip follow along nav 26","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第26天的“内容悬浮显示”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/26%20stripAlongNav/index.html 项目描述本项目的网页主题是一个菜单栏，通过鼠标mouseenter进入每个菜单项目时，会显示出相应的隐藏扩展内容，当从一个菜单进入另一个菜单时，扩展内容的显示会有一个从上一个菜单平移到当前菜单的动态效果。 本项目的难点在于适应大小的动态显示和平移效果。由于扩展内容包含的类型各不相同，而且显示要有一个从上一个菜单平移到当前菜单的动态效果，要做到用通用化的操作，根据扩展内容的具体大小动态显示出，是一件值得思考的事情。 项目重点 getBoundingClientRect() 项目过程HTML部分 第一个菜单及其扩展内容 包含a标签标记的标题；类名为dropdown,dropdown1的下拉菜单（一张图片和描述文本） 123456789&lt;li&gt; &lt;a href=&quot;#&quot;&gt;About Me&lt;/a&gt; &lt;div class=&quot;dropdown dropdown1&quot;&gt; &lt;div class=&quot;bio&quot;&gt; &lt;img src=&quot;https://logo.clearbit.com/wesbos.com&quot;&gt; &lt;p&gt;Wes Bos sure does love web development. He teaches things like JavaScript, CSS and BBQ. Wait. BBQ isn't part of web development. It should be though!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/li&gt; 第二个菜单及其扩展内容 包含a标签标记的标题；类名为dropdown,dropdown2的下拉菜单（类型相同的列表） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;li&gt; &lt;a href=&quot;#&quot;&gt;Courses&lt;/a&gt; &lt;ul class=&quot;dropdown courses&quot;&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;RFB&lt;/span&gt; &lt;a href=&quot;https://ReactForBeginners.com&quot;&gt;React For Beginners&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;ES6&lt;/span&gt; &lt;a href=&quot;https://ES6.io&quot;&gt;ES6 For Everyone&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;NODE&lt;/span&gt; &lt;a href=&quot;https://LearnNode.com&quot;&gt;Learn Node&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;STPU&lt;/span&gt; &lt;a href=&quot;https://SublimeTextBook.com&quot;&gt;Sublime Text Power User&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;WTF&lt;/span&gt; &lt;a href=&quot;http://Flexbox.io&quot;&gt;What The Flexbox?!&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;GRID&lt;/span&gt; &lt;a href=&quot;https://CSSGrid.io&quot;&gt;CSS Grid&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;LRX&lt;/span&gt; &lt;a href=&quot;http://LearnRedux.com&quot;&gt;Learn Redux&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;CLPU&lt;/span&gt; &lt;a href=&quot;http://CommandLinePowerUser.com&quot;&gt;Command Line Power User&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;MMD&lt;/span&gt; &lt;a href=&quot;http://MasteringMarkdown.com&quot;&gt;Mastering Markdown&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; 第三个菜单及其扩展内容 包含a标签标记的标题；类名为dropdown,dropdown3的下拉菜单（类型相同的列表） 123456789&lt;li&gt; &lt;a href=&quot;#&quot;&gt;Other Links&lt;/a&gt; &lt;ul class=&quot;dropdown dropdown3&quot;&gt; &lt;li&gt;&lt;a class=&quot;button&quot; href=&quot;http://twitter.com/wesbos&quot;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;button&quot; href=&quot;http://facebook.com/wesbos.developer&quot;&gt;Facebook&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;button&quot; href=&quot;http://wesbos.com&quot;&gt;Blog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;button&quot; href=&quot;http://wesbos.com/courses&quot;&gt;Course Catalog&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; 白背景 123&lt;div class=&quot;dropdownBackground&quot;&gt; &lt;span class=&quot;arrow&quot;&gt;&lt;/span&gt;&lt;/div&gt; CSS部分 trigger-enter类名。效果是显示下拉菜单，但是此时下拉菜单的不透明度还是为0，所以还是看不到下拉菜单 123.trigger-enter .dropdown { display: block;} trigger-enter-active类名。效果是将下拉菜单的不透明度设置为1 123.trigger-enter-active .dropdown { opacity: 1;} dropBackgorund类名。设置背景图片的样式，也是本项目难点的实现机制，通过移动背景白版，来实现一个动态平移的过程。 12345678910111213.dropdownBackground { width: 100px; height: 100px; position: absolute; background: #fff; border-radius: 4px; box-shadow: 0 50px 100px rgba(50,50,93,.1), 0 15px 35px rgba(50,50,93,.15), 0 5px 15px rgba(0,0,0,.1); transition: all 0.3s, opacity 0.1s, transform 0.2s; transform-origin: 50% 0; display: flex; justify-content: center; opacity: 0;} open类名。将背景图片的不透明度设置为1 123.dropdownBackground.open { opacity: 1;} JS部分 鼠标进入导航栏项目时。 给对应的项目添加类名trigger-enter，随后150ms，添加类名trigger-enter-active。 白背景也要同时显示，所以添加类名open 利用getBoundingClientRect()属性获取元素的宽高和位置信息。这是本项目的难点的实现机制，根据下拉菜单大小动态显示。 白背景的显示位置是相对于已定位的nav元素，所以其top位置是下拉菜单的top位置减去nav的top位置。 12345678910111213141516171819202122232425const triggers = document.querySelectorAll('.cool &gt; li');const background = document.querySelector('.dropdownBackground');const nav = document.querySelector('.top');function handleEnter() { this.classList.add('trigger-enter'); setTimeout(() =&gt; this.classList.contains('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 150); background.classList.add('open'); const dropdown = this.querySelector('.dropdown'); const dropdownCoords = dropdown.getBoundingClientRect(); const navCoords = nav.getBoundingClientRect(); const coords = { height: dropdownCoords.height, width: dropdownCoords.width, top: dropdownCoords.top - navCoords.top, left: dropdownCoords.left - navCoords.left }; background.style.setProperty('width', `${coords.width}px`); background.style.setProperty('height', `${coords.height}px`); background.style.setProperty('transform', `translate(${coords.left}px, ${coords.top}px)`);}triggers.forEach(trigger =&gt; trigger.addEventListener('mouseenter', handleEnter)); 鼠标移除导航栏菜单时。删除类名trigger-enter，trigger-enter-active，open。 12345function handleLeave() { this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open');}triggers.forEach(trigger =&gt; trigger.addEventListener('mouseleave', handleLeave)); 项目补充getBoundingClientRect()返回DOMRect对象，包含元素的大小和相对视口的位置信息。 1domRect = element.getBoundingClientRect(); will-change: opacity提醒浏览器该元素的opacity特性将会改变 A &gt; B匹配A的所有直接后代B JS30的第26个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/27/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Strip-follow-along-nav-26/"},{"title":"【原生javascript项目】Click and drag 27","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第26天的“内容悬浮显示”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/27%20clickAndDrag/index.html 项目描述本项目为一个横向条幅，实现的特效是鼠标点击实现横向拖拽。 项目重点 e.pageX .scrollLeft .offsetLeft e.preventDefault() 项目过程JS部分编程思路为 监听最外层items元素的mousedown事件，触发后添加active类名，此类名具有一定的CSS特效。记录此时的起点startX 以及 左边滚动的位置scrollLeft。 监听鼠标移动mousemove事件，给scrollLeft赋值，即可调整元素在水平方向滚动的位置。 鼠标离开mouseleave和不点击mouseup事件触发时，去掉active类名。 mousedown事件 123456slider.addEventListener('mousedown', (e) =&gt; {isDown = true;slider.classList.add('active');startX = e.pageX - slider.offsetLeft;scrollLeft = slider.scrollLeft;}); mousemove事件 12345678slider.addEventListener('mousemove', (e) =&gt; {if (!isDown) return; // stop the fn from runninge.preventDefault();const x = e.pageX - slider.offsetLeft;const walk = (x - startX) * 3;slider.scrollLeft = scrollLeft - walk;}); mouseleave和不点击mouseup事件 123456789slider.addEventListener('mouseleave', () =&gt; {isDown = false;slider.classList.remove('active');});slider.addEventListener('mouseup', () =&gt; {isDown = false;slider.classList.remove('active');}); 项目补充一些CSS样式 overflow属性：控制元素溢出时的特性，主要有一下几个值 visible 默认值，溢出也是可见的，没有被裁剪 hidden 溢出的内容被裁剪，并且看不到 scroll 溢出的内容被裁剪，但是可以添加滑块scrollbar看到溢出内容 auto 有点像scroll white-space空格处理 normal表示合并空格，多个相邻空格合并成一个空格 nowrap不换行，经常和overflow,text-overflow一起使用 pre保留空格不换行，有几个空格算几个空格显示 pre-wrap的作用是保留空格 user-select：禁止用户用鼠标在页面上选中文字、图片等，也就是，让页面内容不可选 JS30的第27个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/03/05/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Click-and-drag-27/"},{"title":"【原生javascript项目】Video Speed Controller 28","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第27天的“视频播放速度控制器”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/28%20VideoSpeedController/index.htm **本项目的笔记内容选自 大史不说话**，他本人是JS30社区里的知名参与者，他的全部笔记在这里。 本项目的笔记在这里。 挑战任务初始文档index-start.html中提供了一个视频播放区域（使用的是H5原生的控制器）以及一个表示播放速度的滑块区域，本次的编程任务需要实现的效果是当鼠标拖动滑块时，实时改变视频播放的速度。 实现效果[](https://github.com/soyaine/JavaScript30/blob/master/28 - Video Speed Controller/effect.png) 编程思路本次的编程任务难度系数较低，在右侧速度条上监听鼠标点击事件，调整滑块的高度来表示不同的填充百分比，即不同的播放速度，将速度赋值给video对象的playbackRate属性即可实时改变播放速度。难点在于高度的百分比转换。 过程指南本篇实现较为简单，不再分步骤讲解，示例代码如下： 1234567891011121314151617const speed = document.querySelector(&quot;.speed&quot;);const speedBar = speed.querySelector(&quot;.speed-bar&quot;);const video = document.querySelector(&quot;.flex&quot;);function changeSpeed(e) { const height = e.offsetY;//获取滑块的高度 const percentage = e.offsetY / speed.offsetHeight; const min = 0.5; const max = 5; //依据自定义播放速度范围和滑块高度百分比确定播放速率 const playbackRate = percentage * (max - min) + min; speedBar.style.height = Math.round(percentage*100) + '%'; speedBar.textContent = playbackRate.toFixed(2) + '×'; video.playbackRate = playbackRate;}speed.addEventListener('click',changeSpeed); JS30的第28个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Video-Speed-Controller-28/"},{"title":"【原生javascript项目】Countdown Timer 29","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第28天的“倒计时计时器”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/29%20CountdownTimer/index.htm **本项目的笔记内容选自 大史不说话**，他本人是JS30社区里的知名参与者，他的全部笔记在这里。 本项目的笔记在这里。 挑战任务初始文档index-start.html中提供了一个倒计时控制器，从html文档的结构可以看出，顶部的按钮可以用来增加倒计时时间，常用的时间间隔已将参数绑定在data-time属性上;display类用来显示计时的结果。本次编程挑战的任务是通过javascript代码基于当前时间生成一个倒计时，将结束时间和剩余时间分别显示在diaplay__time-left类标签和display__end-time类标签上。 实现效果[](https://github.com/soyaine/JavaScript30/blob/master/29 - Countdown Timer/effect.png) 编程思路监听按点击事件click来为倒计时增加时间，使用setInterval函数每秒执行判断函数，若倒计时事件到，则清除当前计时器，若时间未到，则计算并刷新页面上应该显示的时间。 过程指南1.定义变量及获取需要操作的DOM元素的引用。 12345678const endTime = document.querySelector(&quot;.display__end-time&quot;);const leftTime = document.querySelector(&quot;.display__time-left&quot;);const buttons = document.querySelectorAll(&quot;button&quot;);const date = new Date();var left = 0;//剩余时间var end = 0;//结束时间var timer;//interval计时器leftTime.innerHTML = left;//未操作时，剩余时间显示0 2.为button绑定点击事件，当按钮点击时执行对应的回调函数。 1234const arr = Array.from(buttons);arr.map(function(item){ item.addEventListener('click',clickAction);}); 3.监听表单的提交事件,注意表单的调用方式。 12345document.customForm.addEventListener('submit',function(e){ e.preventDefault(); updateTime(this.minutes.value*60); updateTimer();}); 4.点击后的回调函数中取得点击按钮传递的秒数，调用updateTime()函数更新页面显示结果，并调用updateTimer()来更新计时器相关动作. 12345678function clickAction(e){ let deltaTime; deltaTime = this.dataset.time;//取得data-time属性的值 updateTime(deltaTime); //点击后更新计时器 updateTimer();} 5.updateTime()函数用来更新和页面相关的显示信息。 123456 function updateTime(delta){ left = left + parseInt(delta,0); end = date.getTime() + left*1000; leftTime.innerHTML = left; endTime.innerHTML =new Date(end).toLocaleTimeString();} 6.updateTimer()函数用来执行和设定每秒检查计时器是否需要继续工作的逻辑判断。 1234567891011121314151617function updateTimer(){ //清除以前的timer,如果不清除，新生成的定时器会和以前的定时器叠加在一起，均会生效。 if(timer){ clearInterval(timer); } // 设置新的Timer timer = setInterval(function(){ if(left == 0){ endTime.innerHTML = 'End'; clearInterval(timer); }else{ left -= 1; leftTime.innerHTML = left; }},1000);} 延伸思考本次代码中前后会定义定时器和清除定时器，另一种做法是定时器一直工作不清除，对应的按钮和表单只修改时间，不用调整定时器，当值发生变化后，下一秒定时器检测时就会开始倒计时，这样代码逻辑上会有所简化，感兴趣的朋友可以自行练习。 JS30的第29个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Countdown-Timer-29/"},{"title":"【原生javascript项目】Whack A Mole 30","text":"","link":"/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Whack-A-Mole-30/"},{"title":"【原生javascript项目】JS30-总结","text":"作者：©iaineisalsoyan简介：Atypical frond-end developer. 非典型前端开发者。 完整指南在 GitHub，喜欢请 Star 哦♪(^∇^*) Have fun with the website! ♪(^∇^*) 项目简介30 Day Challenge是 Wes Bos 设计的一个 30 天原生JS编程挑战。 项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。目的是在不借助框架、库、编译器和引用的情况下，帮助初学者理解纯JavaScript语言。 项目内容 Drum kit（架子鼓模拟器） JS and CSS Clock （网页时钟） CSS Variables （CSS变量） Array Cardio Day1 （数组操作1） Flex Panel Gallery （Flex画廊面板） Type Ahead （异步输出） Array Cardio Day2 （数组操作2） Fun with HTML5 Canvas（有趣的HTML5画布） Dev Tools Domination （） Hold Shift and Check Checkboxes （计划清单） Custom Video Player （自定义视频播放器） Key Sequence Detection （字符串序列彩蛋检测） Slide in on Scroll （滚动鼠标滚轮滑动显示） JavaScript References VS Copying （引用与拷贝） Local Storage （本地存储） Mouse Move Shadow （随鼠标移动的文字阴影） Sort with Articles （去掉冠词排列） Adding up Times with Reduce （用Reduce实现时间累加器） Webcam Fun （有趣的网络摄像头） Speech Detection （语音识别） Geolocation （地理位置信息获取） Follow along Link Highlighter （链接高亮显示） Speech Synthesis （语音合成） Sticky Nav （固定的导航栏） Event Capture, Propagation, Bubbling and Once（事件捕捉，传播，冒泡与Once方法） Stripe Follow along Nav （导航栏跟随移动显示特效） Click and Drag （点击并拖拽） Video Speed Controller （视频速度控制器） Countdown Timer （倒计时计时器） Whack A Mole（打地鼠小游戏） 用VUE实现的JS30查看index-VUE.html文件 Drum kit（架子鼓模拟器） JS and CSS Clock （网页时钟） CSS Variables （CSS变量） Flex Panel Gallery （Flex画廊面板） Type Ahead （异步输出） Fun with HTML5 Canvas（有趣的HTML5画布） Hold Shift and Check Checkboxes （计划清单） Custom Video Player （自定义视频播放器） Whack A Mole（打地鼠小游戏） 社区内容#JavaScript30Feel free to submit a PR adding a link to your own recaps, guides or reviews! Arjun Khode’s blog about summaries for each day, including fixed glitches, bugs and extra features Nitish Dayal’s Text Guides are great for those who like reading over watching Meredith Underell’s Quick Lessons Learned Rowan Weismiller’s Recaps + Lessons Learned Thorsten Frommen shares how he solved the exercises before viewing the answers Soyaine 写的中文指南包含了过程记录和难点解释 Ayo Isaiah’s Recaps and Lessons Learned Adriana Rios shares her alternative solutions Michael Einsohn publishes each challenge after watching the video once Mike Ekkel Yusef Habib lessons and tricks learned, and a gh-page to see working all the mini-projects. Amelie Yeh 30 lessons notes with things I’ve learned, and those important recaps. and directly view my demos here 🇹🇼😄 Winar的JavaScript30天挑战，记录练习过程，重难点和其他的解决方案。🎨 Rayhatron - walkthroughs, recaps and lessons learned. Andrei Dobra Full repo with lessons learned and a gh-page with all the exercises. 从零到壹全栈部落,春哥发起的从零到壹全栈部落，旨在带领大家一起学习，一起输出，文档化，代码化，中文视频化，全栈部落口号：输出是最好的学习方式。 Usmaan Ali’s summary of the technical skills learned from each project. He’s also posting them as separate blog posts here Axel‘s lessons learned and a showcase with the projects. Chris 中文實戰，目標描述、過程紀錄。 Muhammad D. Ramadhan’s blog. He shamlesly mixed his personal life with 30 day JavaScript challenge so as to increase his learning retention. He also summarised the challenge on one single page. Do not read his blog! Lee Keitel’s Blog includes summaries of each lesson, what I learned from each one, and my thoughts about the topic taught and using them in the future. Dustin Hsiao 包含了各篇介紹、 效果Demo、各篇詳解及記錄過程，附上部分延伸閱讀及gh-page。 GuaHsu - 紀錄各篇練習過程與心得，並嘗試擴充部分練習，也做了一個包含全部練習的介紹站🇹🇼 Daniela‘s completed challenges on GitHub Pages and Codepen :raised_hands: :muscle: :+1: Dmitrii Pashutskii’s code of all challenges on GitHub with Pages and review blog posts Abid Hasan’s completion of all challenges. This was awesome!! Learned so much! :+1: Yusong Notes Records Yusong JS 30 days note and demo :star2: Ding’s Implementation code and online demo Herminio Torres lessons and tricks learned, and a gh-page to see working all the mini-projects. Dmytro Borysovskyi says many thanks to for the course to Wes 🤝 It was incredible challenge 👌 The full repository with code available here and demos can be reached by the link to gh-pages 👍👍👍 Kizito‘s follow along repo with completed challenges and notes. VannTile‘s repository and GitHub Pages showcase. Thank you for a great ⌨️ experience. Alex Kim completed all the challenges. You can check them out at github pages. Mikhail Thomas created JS30++ to add another level of challenge ontop of this already great course. Ramon Morcillo finished this awesome challenge!. You can see the showcase of his implementations on this link. Santiago Escobar‘s repository and GitHub Pages showcase. Harry Xie 紀錄 30 天的練習筆記在 此連結. Van Ribeiro’s about demos and recaps. On GitHub Repo there’s a summary about what was learned and researched. Mugilan is currently doing this challenge. Check out his Repo and the Live Demo. Eshan Vohra is currently doing this challenge. Check out my repo here. RegusAl is currently doing this challenge. Check out my repo here. Ayush Gupta’s implementation of JavaScript30 challenge with some add-ons &amp; updated design. filipkowal Fix to flex panels (5th day) so the panels deactivate when clicked on another one. Mo. Saif’snote on lessons learned and a gh-pages showcase for the projects. Stiaannel’s implementation of the Javascript30 challenge, with small design changes and a couple of extra features. 其他方法实现的JS30Here are some links of people who have done the tutorials, but in a different language or framework: Thomas Mattacchione JavaScript 30 written in ClojureScript Dave Follett’s blog series, A New Vue on #JavaScript30, where he explores re-implementing #JavaScript30 projects using Vue. Akinjide Bankole used Node.js with Jade to solve the exercises Adrien Poly a modest attempt to convert Drum Kit, Video Player, Local Tapas, TypeHead to Stimulus JS framework in a Rails App. Bogdan Lazar all the JavaScript 30 written in TypeScript Will Wager another TypeScript implementation! marcoSven solution suggestion for 10 - Hold Shift and Check Checkboxes ALMaclaine Javascript 30 written in Dart 2.0.","link":"/myblog.github.io/2022/03/12/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91JS30-%E6%80%BB%E7%BB%93/"},{"title":"【Github】配置连接github","text":"复制代码配置身份，不正确会影响贡献度统计 12git config --global user.email &quot;A175A174@gmail.com&quot;git config --global user.name &quot;A175A174&quot; 配置 ssh 链接，一路回车，打开提示目录下 id_rsa.pub复制到 https://github.com/settings/keys 点击 New sshKey，Title 可以不写 1ssh-keygen -t rsa -C &quot;A175A174@email.com&quot; 验证 ssh 是否成功Hi A175A174! You’ve successfully authenticated, but GitHub does not provide shell access 1ssh -T git@github.com","link":"/myblog.github.io/2021/08/20/%E3%80%90Github%E3%80%91%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5github/"},{"title":"【LeetCode】N 皇后问题","text":"问题描述N 皇后问题是指在 n * n 的棋盘上要摆 n 个皇后。 要求：任何两个皇后不同行，不同列也不在同一条斜线上，求给一个整数 n ，返回 n 皇后的摆法数。 例如12345输入：8返回值：92输入：4返回值：2 题解思路看懂此题解之前，需要会做 【BM55 没有重复项数字的全排列】。 如果BM55已经会做了，下面开始看本题解。 👇👇👇大概思路 n个皇后分别在1，2,3…n行的不同列处，列的下标用数组arr表示 要确定皇后的位置，其实就是确定列的位置，因为行已经固定了 进一步讲，也就是如何摆放 数组arr[0,1,2,3,…,n-1] 如果没有【不在同一条斜线上】要求，这题其实只是单纯的全排列问题，代码很容易些出来 但是对于【不在同一条斜线上】要求，全排列得到的res结果有些并不能用，比如说皇后的列位置不能这样排列：[0,1,2,3…,n-1] 所以现在问题变成了，在全排列的基础上，根据N皇后的问题，去除一些结果 下面开始声明一些变量 arr n个皇后的列位置 res n皇后排列结果 ruler 记录对应的列位置是否已经占用（也是是否有皇后），如果有，那么设为1，没有设为0 setPos 哈希集合，标记正斜线（从左上到右下）位置，如果在相同正斜线上，坐标(x,y)满足 y-x 都相同 setCon 哈希集合，标记反正斜线（从y右上到左下）位置，如果在相同反斜线上，坐标(x,y)满足 x+y 都相同 大致的代码思路如下所示 123456789101112131415arr = [0,1,2,3,...,n-1]res = []ruler = [n]setPos = new Set()setPos = new Set()backtrack(路径, arr): if 满足结束条件: result.add(路径) return for 选择 in 选择列表(arr): 做选择 backtrack(路径, arr) 撤销选择 return res.length 一些解释首先，N 个皇后肯定得在不同行，不同列处（由题意 “任何两个皇后不同行，不同列” 可知）。 要实现这个方案，其实思路和 BM55 全排列一样。把N个皇后的列坐标定义成数组arr = [0,1,2,...,n-1]。然后全排列该数组即可，得到的排列方式res的长度，就是排列方案的总数。 但是N皇后问题，还需要满足N 皇后不在同一条斜线上。这就更复杂了一点，需要对斜线位置进行判断。 怎么判断呢？ 如果setPos里不包含正斜线位置，setCon里不包含反斜线位置，那么就是我们要的【满足结束条件】。 在回溯函数里，我们先确定第0排皇后的列位置，然后回溯递归，确定第1排的皇后的列位置。 所以每次回溯，坐标(x,y)其实是(row,i) 最终的代码12345678910111213141516171819202122232425262728const arr= Array.from({length:n},(item, index)=&gt; index) // 列的位置let res = [];let ruler = new Array(n).fill(0);//用来记录num的皇后下落后，对角线位置，如果在对角线位置，那么为1，否则0let setPos = new Set();//标记正对角线let setCon = new Set();// 标记反对角线const backTrace = (row,path)=&gt;{ if(path.length === n){ res.push(path.slice()); return;} for(let i=0;i&lt;n;i++){ // i表示列 if(ruler[i] == 0 &amp;&amp; !setPos.has(i-row) &amp;&amp; !setCon.has(i + row)){ path.push(arr[i]); ruler[i] = 1 setPos.add(i - row) setCon.add(i + row) backTrace(row+1,path); path.pop(); ruler[i] = 0; setPos.delete(i - row) setCon.delete(i + row) } }}backTrace(0,[])return res.length;","link":"/myblog.github.io/2022/03/18/%E3%80%90LeetCode%E3%80%91N-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"title":"【前端面试基础——HTML】图片懒加载 01","text":"作者：©Iaineisalsoyan 嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！ Have fun with the website! ♪(^∇^*) 什么是图片懒加载浏览网页的时候，滑动页面到能看到图片的时候再加载图片。 该功能实际可以拆分成两点： 判断图片出现在了当前视口（因为这个时候需要显示图片） 控制图片的加载 一些思考🤔 类似功能在JS30的项目里做过。参考【原生javascript项目】Slide in on scroll 13 我们现在回忆一下该项目的技术点。当时做该项目的时候，主要通过Scroll事件+位置计算实现了，另外加了函数防抖功能。其中位置计算主要包括屏幕高度（视口高度）、屏幕滚定位置、图片顶部距页面距离、图片半高、图片底部位置。 当屏幕滚动位置+屏幕高度之和 &gt; 图片顶部距页面距离+半高之和，移入图片；当屏幕滚动位置&lt;图片底部距离，移出图片。 window的scroll事件 window.addEventListener('scroll') 一些位置（像素值） window.scrollY 文档当前垂直滚动的像素数 window.innerHeight viewport部分的高度 sliderImage.offsetTop 当前元素顶部相对于其 offsetParent 元素的顶部的距离 debounce 的作用（函数防抖） 降低事件监听的频率，使用了 Lodash 中的 debounce 方法 解决方案🔖🔖🔖 速看在这里！！！ 判断图片出现在当前视口 scrollY, offsetTop,innerHeight+ Scroll事件 getBoundingClientRect API + Scroll事件 控制图片的加载 DataSet API 一步到位的方法 IntersectionObserver API 1 判断图片出现在当前视口 位置计算 + Scroll事件 这里出现的意思可以特指能看到图片一半的高度。 1234const slideInAt = (window.scrollY + window.innerHeight);const imageBottom = sliderImage.offsetTop + sliderImage.height;const isHalfShown = slideInAt &gt; (sliderImage.offsetTop + sliderImage.height / 2);const isNotScrolledPast = window.scrollY &lt; imageBottom; 知识点：scrollY, offsetTop,innerHeight getBoundingClientRect API + Scroll事件 该方法返回元素的大小及其相对于视口的位置。有top,left,bottom,right等属性。 1img.getBoundingClientRect().top &lt; document.documentElement.clientHeight; // 视口高度 the document.documentElement property gives you the html element, while the document.body property gives you the body element. 2 控制图片的加载 DataSet API 1&lt;img data-src=&quot;shanyue.jpg&quot; /&gt; 首先设置一个临时 Data 属性 data-src，控制加载时使用 src 代替 data-src，可利用 DataSet API 实现 1img.src = img.datset.src 3 一步到位的方法 IntersectionObserver API 异步监听元素是否到了当前视口或者其他元素 一个能够监听元素是否到了当前视口的事件，一步到位 12345678910111213const observer = new IntersectionObserver((changes) =&gt; { // changes: 目标元素集合 changes.forEach((change) =&gt; { // intersectionRatio if (change.isIntersecting) { const img = change.target; img.src = img.dataset.src; observer.unobserve(img); } });});observer.observe(img); LazyLoading 属性 1&lt;img src=&quot;shanyue.jpg&quot; loading=&quot;lazy&quot; /&gt; 不过目前浏览器兼容性不太好。 4 其他优化 window.scroll 事件可以加防抖节流。一般使用 lodash.throttle 。 1_.throttle(func, [(wait = 0)], [(options = {})]);","link":"/myblog.github.io/2022/03/24/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94HTML%E3%80%91%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD-01/"}],"tags":[{"name":"原生javascript项目","slug":"原生javascript项目","link":"/myblog.github.io/tags/%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE/"},{"name":"JS30;30个原生javascript项目","slug":"JS30-30个原生javascript项目","link":"/myblog.github.io/tags/JS30-30%E4%B8%AA%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE/"},{"name":"JavaScript","slug":"JavaScript","link":"/myblog.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","link":"/myblog.github.io/tags/HTML/"}],"categories":[{"name":"30个原生javascript项目","slug":"30个原生javascript项目","link":"/myblog.github.io/categories/30%E4%B8%AA%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE/"},{"name":"LeetCode","slug":"LeetCode","link":"/myblog.github.io/categories/LeetCode/"},{"name":"前端面试基础","slug":"前端面试基础","link":"/myblog.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"}]}
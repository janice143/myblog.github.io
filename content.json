{"pages":[],"posts":[{"title":"【python】清理重复图片","text":"引言本文解释如何编写python脚本，实现重复图片清理的功能。 正文MD5,Message-Digest Algorithm，信息摘要算法，是一种信息加密算法，可以把任意长度的数据转换为一个长度固定的数据串（通常是16进制的字符串表示）。一个图片文本的本质是一个数据串，所以要想清理重复图片，就是要匹配到相同的数据串的两张图片，使用DM5的目的是将图片的数据串统一，如果两张图片经过MD5算法变换后的数据串相同，则可判断这两种图片重复。 以计算一个字符串的MD5值为例，代码如下： 12345import hashlibmd5 = hashlib.md5()md5.update('how to use md5 in python hashlib?'.encode('utf-8'))print(md5.hexdigest()) 计算结果为 1d26a53750bc40b38b65a520292f69306 参考网站：廖雪峰老师博客中摘要算法简介 本文的脚本的思路如下：1 遍历文件夹下的图片文件2 把图片文件记录到一个字典变量中3 生成所有图片文件的MD5值4 把MD5值存放到一个新的字典变量中5 判断如果已经存放，则该图片为重复图片，删除即可 选取文件夹，遍历文件夹下所有的文件123456inpath = &quot;G:/最新/照片/2018-2019年照片备份/2021年&quot;for path,dir,filelist in os.walk(inpath): for filename in filelist: # print(filename) allfile.append(os.path.join(path,filename)) 获取MD5值123456fd = open(file,'rb')md5 = hashlib.md5()md5.update(fd.read())fd.close()return md5.hexdigest() 根据MD5值比较123456for photo in allfile: md5sum = getmd5(photo) if md5sum not in md5list: md5list.append(md5sum) else: identicallist.append(photo) 删除重复照片12for idenPhoto in identicallist: os.remove(idenPhoto) 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/09/02/%E3%80%90python%E3%80%91%E6%B8%85%E7%90%86%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87/"},{"title":"【程序】我是如何建立我的第一个博客网站的？","text":"写在前面我从大二开始喜欢上写程序，也从那开始自学了很多编程语言。当我第一次接触到前端开发的时候，那些由多个不同后缀名组成的项目，让我觉得又新奇（第一次见这种编程语言，太有特色了），同时又恐惧（这么多个编程语言组成，我能学会吗）。 大二是我人生阶段最迷茫的一段时间，不想上课，不想和人交往。但是我生来好像就有股向上的劲头，即使每天很颓废，也告诫自己做点有用的事情，做点有用的事情。所以我那段时间学了很多编程语言，虽然是迷迷糊糊学了很多语言，走了很多弯路。 好在我也勉勉强强地学了前端开发，我记得那段时间我先是在网上看了一个教学视频，然后就开始自己动手捣鼓做起了第一个个人网站，花了一天一夜的时间。 大三开始我稳定地在实验室跟着一个老师做科研，便没有时间再去学写程序。 大四基本上是在做创新创业比赛，更没有时间写程序了。 但是大二以后的整个过程，我总是偶尔地问自己：当初我为何要学写这么多程序？我大二整整一年的时间都花在自学程序上，感觉就这么放弃有点太不值得？自学程序有用吗以后？ 现在我也不知道学的程序有没有用，但是就是因为当初花了一年时间起步，不甘心没有一点收获地戛然而止。所以我，到了大四暑假的末尾，研一马上要开学，要重新拾起我以前学的东西，好好做下去，希望能做出点东西。 自学编程的时候听到最多、最有用的建议就是要多做实战，而对于前端开发来讲，第一个要做的实战就是建立自己的个人网站，第二个就是建立个人博客。所以在建立好自己的第一个网站，一年后，也就是现在，我开始建个人博客，并且立下不倒的flag，这个网站将会见证我一点一滴的成长（未来我的生活琐事，学习曲线等奖全部记录记录在这里），是我人生中一笔宝贵的财富，我一定会好好经营。 正文一、找资料一般开始一个新东西，第一步肯定是找资料，毕竟光想是想不出来的。我找的第一个资料就是B站Up主CodeSheep的一个视频手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo：https://www.bilibili.com/video/BV1Yb411a7ty 在看这个视频的过程中，我有很多疑惑（为什么要下载node.js,在cmd下建文件夹是怎么回事等等），所以也会找其他资料使用hexo+github搭建免费个人博客详细教程：https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.htmlhexo5分钟免费搭建个人博客教程：https://www.jianshu.com/p/722fe57ef163 结合视频，以及文本资料，我的很多疑惑都消除了，接下来我便可以自己动手尝试了。 二、下载软件，准备环境1.安装好node.js（最好下载Windows 安装包 (.msi)，在安装过程中会配置好路径，用zip文件还要自己手动配置，特别容易报错） 和 Git 2.在das窗口下输入命令 node -v和 npm -v，检验hexo运行环境 3.git安装完成后的检验操作是：鼠标右键。会出现git GUI here 和git bash here 三、使用hexo框架搭建静态博客1.安装 hexo 框架 1npm install -g hexo 2.在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\\程序\\html_codes\\janiceBlog，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 3.cmd窗口下切换到janiceBlog文件夹路径，然后输入一下代码： 1hexo init # 初始化 hexo会自动下载一些文件到这个目录，包括node_modules 12hexo g # 生成hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。hexo s是开启本地预览服务，打开浏览器访问http://localhost:4000即可看到内容 4.修改主题可以再官网选一个好看的主题以yilia主题为例，在博客路径下，输入一下命令: 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布 四、上传到github1.配置_config.yml中有关deploy的部分： 1234deploy: type: git repository: git@github.com:janice143/iainsBlog.git branch: master 2.打开博客文件夹，右键选择git bash here，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会(部署这个命令一定要用git bash,不要在cmd下，不然会报错) 五、上传到GitHub出现一些错误错误1： hexo + github pages搭建博客，本地server成功，部署到github上之后样式加载不出来解决：需要修改根目录_config.yml文件中的url地址和根目录 123456##If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://janice143.github.io/myblog.github.io/root: /myblog.github.iopermalink: :year/:month/:day/:title.htmlpermalink_defaults: url 是GitHub pages给我们分配的网址root是搭建该博客的仓库名 最后重新部署上传就可以了 123hexo cleanhexo ghexo d 错误2：修改默认头像解决：在主题的yilia文件夹的img文件夹里放上头像图片，然后修改yilia文件夹下的_config.yml文件 12#你的头像urlavatar: /myblog.github.io/img/me.JPG 六、写博客1.定位到我们的博客目录，执行命令： 1hexo new “博客名自己取” 2.markdown格式编写规则参考：http://www.mdeditor.com/","link":"/myblog.github.io/2020/09/11/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%EF%BC%9F/"},{"title":"【原生javascript项目】Real time clock 02","text":"引言本文利用javascript写一个实时显示时间的时钟特效网页。 网址为(https://janice143.github.io/realTImeClock/) 正文1网页布局与功能网页主体为一个时钟，具有表盘（12个数字）和三个指针（时针、分针、秒针）。 2实现原理一、 html代码 使用一个类名为clock为的div容器，里面包含时针.hour-hand,分针.minute-hand,秒针second-hand，以及12个数字。 12345678910111213141516171819202122&lt;div class=&quot;clock&quot;&gt; &lt;div class=&quot;hour-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;minute-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;second-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;number&quot;&gt; &lt;span class=&quot;num12&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;num1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;num2&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;num3&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;num4&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;num5&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;num6&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;num7&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;num8&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;num9&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;num10&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;num11&quot;&gt;11&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 二、css代码 1 先让时钟显示在页面的中部（垂直居中，水平居中），这可以用个在clock的上一级词main中设置flex容器。 12345678#main{ display: flex; min-height: 100vh; align-items: center; justify-content: center;} 2 时钟的表盘的样式 1234567.clock{ width: 300px; height: 300px; border-radius: 300px; border: 20px solid white; position: relative;} 3 指针的样式 指针旋转的特效是由transfrom：rotate(deg)实现的（本文这里是通过js代码后面再设置的）。transform-origin默认是50%，元素会绕着中间旋转，设置成100%后，元素绕着一端旋转。transition-timing-function是设置过渡的时间函数特效，不设置是默认均匀地过渡。 1234567891011121314151617.hand{ width: 120px; height: 6px; background-color: blueviolet; position:absolute; top:148px; right: 148px; transform-origin: 100%; transition:all 0.05s; transition-timing-function: cubic-bezier(0.1, 2.7, 0.58, 1);}.hour-hand{ width: 100px;}.second-hand{ height: 4px;} 4 12个数字的样式 先给数字设置相对定位，相对于上一级.number。然后再给每个数字设置相应的top和left. 数字位置算法为： num=2; top=135sin((num-3)30/180pi)+135； left=135cos((num-3)30/180pi)+135 （num为1-12的数字） 1234567891011.number{ width: 300px; height:300px; font-size: 15px; position:absolute; top:0px; right: 0px;} 三、 javascript代码 分别获取时针、分钟、秒针的类名，然后通过当前时间给三个指针分配正确的旋转角度。 1 秒针： parseInt(second/60*360)+90; 2 分针： parseInt(minute/(60)*360+second/10)+90; 3 时针：parseInt(hour/(12)*360+minute/(60)*30)+90; +90度是因为设置指针css样式的时候，指针都在指在9点钟的位置，+90度可让指针从12点为起始点旋转。 设置为指针的角度后，利用定时器每隔一秒刷新指针的位置，这样就可以达到实时显示的效果。 当指针转弯一圈后，重新运行设置时间函数 setDate()重置指针的角度。 123456789101112131415161718192021222324252627// 获取指针的transform样式，从而让其旋转 const secondHand = document.querySelector('.second-hand'); const minuteHand = document.querySelector('.minute-hand'); const hourHand = document.querySelector('.hour-hand'); const audio = document.querySelector('audio'); // 获取当前时间，从时间里设置指针 function setDate(){ const time = new Date(); const second = time.getSeconds(); const secondDeg = parseInt(second/60*360)+90; secondHand.style.transform = `rotate(${secondDeg}deg)`; const minute= time.getMinutes(); const minuteDeg = parseInt(minute/(60)*360+second/10)+90; minuteHand.style.transform = `rotate(${minuteDeg}deg)`; const hour= time.getHours(); const hourDeg = parseInt(hour/(12)*360+minute/(60)*30)+90; hourHand.style.transform = `rotate(${hourDeg}deg)`; } // 设置定时器美隔一秒时间进行刷新页面 setInterval(setDate,1000); // setDate(); // 当指针转一圈后，重置度数 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/12/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Real-time-clock-02/"},{"title":"【原生javascript项目】Image Procession with Javascipt 03","text":"引言本文利用javascript更新css变量，实现一个简易的图像处理网页。对于图像处理部分，本网页可调节图像的边框宽度、模糊度以及边框颜色值。 网址为(https://janice143.github.io/imageProcessionwithJS/) 正文1 页面布局页面分为三部分：标题、三个input组成的控件、图像 通过调节三个Input的值，可以实现对外边距、模糊值和颜色的改变。 一、html代码 1 标题 12345&lt;h2&gt;利用&lt;span class=&quot;text-color&quot;&gt;JS&lt;/span&gt;更新CSS自定义变量&lt;/h2&gt; &lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt;&lt;/div&gt; 2 三个input值 12345678910&lt;div class=&quot;controlers&quot;&gt; &lt;label for=&quot;spacing&quot;&gt;外边距:&lt;/label&gt; &lt;input id=&quot;spacing&quot; type=&quot;range&quot; name=&quot;spacing&quot; value=&quot;10&quot; data-unit=&quot;px&quot;&gt; &lt;label for=&quot;blur&quot;&gt;模糊值:&lt;/label&gt; &lt;input id=&quot;blur&quot; type=&quot;range&quot; name=&quot;blur&quot; value=&quot;10&quot; data-unit=&quot;px&quot;&gt; &lt;label for=&quot;color&quot;&gt;底色:&lt;/label&gt; &lt;input id=&quot;color&quot; type=&quot;color&quot; name=&quot;color&quot; value=&quot;#fecc00&quot;&gt;&lt;/div&gt; data-unit=”px”是自己设置的dataset(数据集合)。 3 图像 1&lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt; 二、css代码 1 css变量 变量声明：在选择器里（任何选择器），变量名前面要加两根连词线（--）。本文里在:root根元素里声明，这是全局变量的声明方式，保证任何选择器都可以使用。变量名大小写敏感。 12345678img{ margin-top:50px; width:600px; height: 375px; padding: var(--spacing);/* var函数获取变量 */ background-color: var(--color); filter:blur(var(--blur));} 读取变量：利用var()函数读取 12345 :root{ --color:#fecc00; --spacing:10px; --blur:10px;} css变量参考网址：（https://www.ruanyifeng.com/blog/2017/05/css-variables.html） 三、javascript代码 1 suffix中文意思为 后缀。在js代码中，设置了一个suffix变量，这是因为spacing和blur的值在css中需要加上px单位，而color的值没有，所以使用了||逻辑运算。 2 this.dataset需要注意一下，在html代码中，我们设置了自定义了data-unit数据，this.dataset会取出所有自定义的数据集，比如你可以在Html中设置data-key(回想起前几天的js程序）,data-name,data-poo任何数据名字，因为是自定义。this.dataset.unit是本文在html代码中提前设置好的。 3 document.documentElement用来获取当前文档的直接子节点，对于Html文档而言，一般是。 4 style.setProperty(propertyName, value);给css样式某个属性名propertyName赋一个新值value。 5 --${this.name}为模板字面量，可以嵌入表达式的字符串字面量，${}表示一个占位符。一般的字符串是用单引号或者双引号标注的，这些字符串之间没有任何区别，而模板字面量则可以通过一个占位符来进行插值，模板字面量用反引号``实现。 6 箭头函数优点：剪短、this指向函数定义生效时所在对象。 函数声明：关键字、函数名、参数、函数体 123function functionName ([arg1 [,arg2 [...,argn]]]) { // functionBody 函数体} 没有函数名时，函数为匿名函数 1234const square = function (number) { return number * number;};// 相当于箭头函数：number=&gt;number*number; 具名函数由函数名，而且函数内部可以代指本身（迭代函数使用） 123const factorial = function fac(n) { return n &lt; 2 ? 1 : n * fac(n - 1);};console.log(factorial(3));var x = square(4);// x 得到的值为16 箭头函数；如果函数体只有一个表达式，可以不用{}符号 123const fn = () =&gt; { // do something}; 1234567// 获取Input的value，并且将value赋值给cssconst inputs = document.querySelectorAll('.controlers input');function updateValue(){ const suffix = this.dataset.unit || ''; // 给blur和spacing加单位 document.documentElement.style.setProperty(`--${this.name}`,this.value + suffix);}inputs.forEach(input=&gt;input.addEventListener('change',updateValue)); 结论完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/13/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Image-Procession-with-Javascipt-03/"},{"title":"【python】定时健康打卡网站打卡发送邮箱","text":"引言本文介绍如何编写python脚本，实现网站自动、定时健康打卡功能，打卡成功后截取当前屏幕信息，并通过发送邮件告知对方已经打卡成功。 正文思路：1 package 安装2 实现网站打卡功能3 保存当前网站截图4 发送邮件5 定时运行程序 package 安装Selenium安装 1pip install selenium ChromeDriver下载：下载与本机安装的Chrome浏览器的版本相同的ChromeDriver.exe，并放在python安装路径下的scripts路径下。 实现网站打卡功能打开浏览器，进入网站搜索 123browser = webdriver.Chrome()browser.get('这里填你要打卡的网站地址')time.sleep(2) 通过find_element_by_xpath来定位用户名和密码的输入框，并输入用户名和密码 1234uid = '你的用户名'pwd = '密码'browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[4]/input&quot;).send_keys(uid)browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[5]/input&quot;).send_keys(pwd) 通过find_element_by_xpath来定位登录输入框，并点击回车键 1browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[7]/input&quot;).send_keys(Keys.ENTER) 点击健康打卡 123click_btn = browser.find_element_by_xpath(&quot;//*[@id='apply-content']/div[2]/ul[1]/li[2]&quot;)ActionChains(browser).click(click_btn).perform()# time.sleep(2) 点击填报 12click_btn2 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[4]/button&quot;)ActionChains(browser).click(click_btn2).perform() 点击 我知晓 12click_btn3 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[51]/div[1]/input&quot;)ActionChains(browser).click(click_btn3).perform() 点击上报 12click_btn4 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[52]&quot;)ActionChains(browser).click(click_btn4).perform() 截屏并保存，保存当前网站截图打卡成功后，我想保留当前网页的截图，作为打卡成功的凭证 1browser.get_screenshot_as_file(&quot;success.png&quot;) 退出浏览器 1browser.quit() 发送邮件通过发送邮件的方式，通知对方已经成功打卡。 准备用于发送信息、接收信息的邮箱 123MAIL_USER = &quot;邮箱地址&quot; # 用于发送通知的邮箱MAIL_PASS = &quot;授权码&quot; # 授权码，注意不是邮箱登录密码！！mail_to = &quot;接收信息的邮箱&quot; 发送带有图片附件images和正文mail_text的邮件 12345678910111213141516msg = MIMEMultipart()mail_text = &quot;已经成功打卡！&quot;mail_body = MIMEText(mail_text)# 设置邮件主题、发送方和接收方msg['Subject'] = &quot;每日健康打卡通知&quot;msg['From'] = MAIL_USERmsg['To'] = mail_tomsg.attach(mail_body)# 添加截图附件fp = open(&quot;success.png&quot;, 'rb')images = MIMEImage(fp.read())fp.close()images.add_header('Content-Disposition', 'attachment', filename='success.png')msg.attach(images) 登陆并发送邮件(我这里是用163邮箱) 123456smtp = smtplib.SMTP()smtp.connect('smtp.163.com')smtp.login(MAIL_USER, MAIL_PASS)smtp.sendmail(MAIL_USER, mail_to, msg.as_string())smtp.quit() 定时运行程序通过使用Win10自带的“任务计划程序”来设置运行编写的.py脚本，设置步骤如下： 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/08/20/%E3%80%90python%E3%80%91%E5%AE%9A%E6%97%B6%E5%81%A5%E5%BA%B7%E6%89%93%E5%8D%A1%E7%BD%91%E7%AB%99%E6%89%93%E5%8D%A1%E5%8F%91%E9%80%81%E9%82%AE%E7%AE%B1/"},{"title":"【原生javascript项目】Piano-Kit-01","text":"引言本文介绍如何用javascripty语法写一个简单的琴键(drum ang piano)网页，通过敲击特定键盘（音键），可以发出不同音调。 网址为(https://janice143.github.io/musicKit.github.io/) 正文1网页布局与功能网页整体分为3个部分： 1是最顶上居中排布的乐器切换(Drum Kit, Piano Kit)组块，选中响应的kit，背景图和琴键切换为响应的内容，同时kit字体变为白色； 2是页面居中排布的琴键； 3是背景图。 琴键可以通过鼠标点击或者按下响应的键盘来操作，可以发出对应的音效（黄色字体表示音效的名称）。琴键被点击按下后，加以一定的css动画（黄色高亮边框）来区分。 2实现原理一、 html代码 1 乐器切换组块： 1234&lt;div id=&quot;switch&quot;&gt; &lt;a class=&quot;drum chosen&quot; href=&quot;#&quot; onclick=&quot;addChosenDrum()&quot;&gt;Drum Kit&lt;/a&gt; &lt;a class=&quot;piano&quot; href=&quot;#&quot; onclick=&quot;addChosen()&quot;&gt;Piano Kit&lt;/a&gt;&lt;/div&gt; 2 Drum Kit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=&quot;pianoKit&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key1 key&quot; &gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(65)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;A&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;DO&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key2 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(83)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;S&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;RE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key3 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(68)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;D&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;MI&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key4 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(70)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;F&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;FA&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key5 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(71)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;G&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SOL&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key6 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(72)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;H&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;LA&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(74)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;J&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SI&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;audio data-key=&quot;65&quot; src=&quot;sounds/1.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;83&quot; src=&quot;sounds/2.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;68&quot; src=&quot;sounds/3.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;70&quot; src=&quot;sounds/4.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;71&quot; src=&quot;sounds/5.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;72&quot; src=&quot;sounds/6.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;74&quot; src=&quot;sounds/7.MP3&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 3 Piano Kit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;div id=&quot;drumKit&quot; class=&quot;chosen&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key1 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(65)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;A&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;CLAP&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key2 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(83)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;S&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;HIHAT&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key3 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(68)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;D&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;KICK&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key4 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(70)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;F&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;OPENHAP&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key5 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(71)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;G&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;BOOM&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key6 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(72)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;H&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;RIDE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(74)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;J&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SNARE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;75&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(75)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;K&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;TOM&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;76&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(76)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;L&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;TINK&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;audio data-key=&quot;65&quot; src=&quot;sounds/clap.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;83&quot; src=&quot;sounds/hihat.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;68&quot; src=&quot;sounds/kick.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;70&quot; src=&quot;sounds/openhat.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;71&quot; src=&quot;sounds/boom.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;72&quot; src=&quot;sounds/ride.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;74&quot; src=&quot;sounds/snare.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;75&quot; src=&quot;sounds/tom.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;76&quot; src=&quot;sounds/tink.wav&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 二、css代码 1 实现顶部的切换组块（Drum Kit, Piano Kit)固定在窗口的某个位置，不占位置，脱离标准文档流；居中排布 1234position: fixed;left:0; right:0; margin:0 auto; 2 实现琴键居中排布：用Flex 布局实现垂直、水平居中。 任何一个容器都可以指定为 Flex 布局（flex容器），display: flex即可实现。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”Item”。 容器具有6个属性： · flex-direction:水平主轴的方向 · flex-wrap:如果主轴拍不下，可以用这个属性来设置换行的形式 · flex-flow:合并了flex-direction 和flex-wrap的功能，用这个属性可以同时设置这两个属性。 · justify-content:定义了item在主轴（水平方向上）的对齐方式 ·align-items：定义了item在垂直方向上的对齐方式 · align-content：定义了多跟轴线的对齐方式 123456789#drumKit,#pianoKit{ /* background-color: red; */ /* 在需要垂直居中的父元素上，设置display:flex和align-items：center。要求：父元素必须显示设置height值 */ display: flex; flex:1; min-height: 90vh; /*vh 就是当前屏幕可见高度的100% align-items: center; /*子元素水平居中*/ justify-content: center; /*子元素垂直居中*/} 90vh表示占窗口（当前页面窗口）大小的90%。 3 键盘被点击时，js会添加playing类，其css布局为 12345.playing{ transform: scale(1.1); border-color: #ffc600; box-shadow: 0 0 1rem #ffc600;} 4 drum kit 和piano kit被选中时，js会添加chosen类名。设置css代码让选中字体变为白色以区分 123#switch .chosen{ color:white;} 三、 javascript代码 1 切换键盘(drum kit, piano kit) 对于drum kit：点击drum，添加.chosen，同时去掉piano kit 的.chosen类名；显示drum琴键，隐藏piano琴键；显示响应背景background-image。 12345678910111213141516171819202122232425262728293031// 点击a标签，切换键盘:点击piano键盘，添加chosen class，去掉drum的class; 显示对应的piano键盘;在对应的键盘中添加chosen，这样audio也可以对应 function addChosen(){ const chosen = document.getElementsByClassName(&quot;piano&quot;); const notChosen = document.getElementsByClassName(&quot;drum&quot;); chosen[0].classList.add('chosen'); notChosen[0].classList.remove('chosen'); const notChosenKit = document.getElementById(&quot;drumKit&quot;); notChosenKit.classList.remove('chosen'); notChosenKit.style.display = &quot;none&quot;; const chosenKit = document.getElementById(&quot;pianoKit&quot;); chosenKit.style.display = &quot;flex&quot;; chosenKit.classList.add('chosen'); // 换钢琴壁纸 const wallpaper = document.getElementsByTagName(&quot;html&quot;); wallpaper[0].style.backgroundImage=&quot;url(./pianoback.jpg)&quot;; } function addChosenDrum(){ const chosen = document.getElementsByClassName(&quot;drum&quot;); const notChosen = document.getElementsByClassName(&quot;piano&quot;); chosen[0].classList.add('chosen'); notChosen[0].classList.remove('chosen'); const notChosenKit = document.getElementById(&quot;pianoKit&quot;); notChosenKit.classList.remove('chosen'); notChosenKit.style.display = &quot;none&quot;; const chosenKit = document.getElementById(&quot;drumKit&quot;); chosenKit.style.display = &quot;flex&quot;; chosenKit.classList.add('chosen'); // 换鼓壁纸 const wallpaper = document.getElementsByTagName(&quot;html&quot;); wallpaper[0].style.backgroundImage=&quot;url(./drumback.jpg)&quot;; } 2 键盘敲击琴键，用keycode标注，给对应琴键添加.playing类名。设置audio.play发出音效。 1234567891011// 点击键盘字母时，对应的键添加class属性function playSound(e){ const audio = document.querySelector(`.chosen audio[data-key=&quot;${e.keyCode}&quot;]`); // console.log(audio); if (!audio) return; const key = document.querySelector(`.chosen div[data-key=&quot;${e.keyCode}&quot;]`); key.classList.add('playing');//添加playing类属性 audio.currentTime = 0; //音频重头播放 audio.play();} 3 如果连续敲击多个琴键，多个琴键都会显示过渡特效（黄色Border,放大1.2倍），为了让最后一个琴键之前的琴键过滤样式去掉，可以利用transitionend事件，让已经过渡的琴键去掉.playing类名。 12345678910// 去掉playing 类属性function removeTransition(e){ if (e.propertyName !='transform') return; this.classList.remove('playing');}const keys = document.querySelectorAll('.key');keys.forEach(key=&gt;key.addEventListener('transitionend',removeTransition));window.addEventListener('keydown',playSound); 4 鼠标点击也可以实现琴键发出音效。设置onclick事件，传入keycode参数。 1234567891011function clickPlaySound(keycode){ // data-key=keycode; const audio = document.querySelector(`.chosen audio[data-key=&quot;${keycode}&quot;]`); if (!audio) return; const key = document.querySelector(`.chosen div[data-key=&quot;${keycode}&quot;]`); key.classList.add('playing');//添加playing类属性 audio.currentTime = 0; //音频重头播放 audio.play(); // console.log(audio); }; 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Piano-Kit-01/"},{"title":"【原生javascript项目】数组操作 04","text":"引言本文介绍一下数组操作的一些常用方法。 正文1创建数组1234567const people = ['Bernhard, Sandra', 'Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd', 'Beckett, Samuel', 'Blake, William', 'Berger, Ric', 'Beddoes, Mick', 'Beethoven, Ludwig','Belloc, Hilaire', 'Begin, Menachem', 'Bellow, Saul', 'Benchley, Robert', 'Blair, Robert', 'Benenson, Peter', 'Benjamin, Walter', 'Berlin, Irving','Benn, Tony', 'Benson, Leana', 'Bent, Silas', 'Berle, Milton', 'Berry, Halle', 'Biko, Steve', 'Beck, Glenn', 'Bergman, Ingmar', 'Black, Elk', 'Berio, Luciano','Berne, Eric', 'Berra, Yogi', 'Berry, Wendell', 'Bevan, Aneurin', 'Ben-Gurion, David', 'Bevel, Ken', 'Biden, Joseph', 'Bennington, Chester', 'Bierce, Ambrose','Billings, Josh', 'Birrell, Augustine', 'Blair, Tony', 'Beecher, Henry', 'Biondo, Frank']; 2 获取数组长度1console.log(people.length); 3循环123people.forEach(function(item,index){ console.log(item,index);}) 4 数据尾部添加一个元素12let newLength = people.push('Wheeler, Ben');// newLength的结果是people的长度，不是新添加的元素内容console.log(people.length); 5 从尾部删除一个元素12let last = people.pop();console.log(people.length); 6 从头部删除一个元素12let first = people.shift();console.log(people.length); 7 从提添加一个新元素12let firstItem = people.unshift('Bernhard, Sandra');console.log(people); 8 寻找下标12let pos = people.indexOf('Blair, Tony');console.log(pos); 9 根据下标删除元素12let removeItem = people.splice(pos,1);//参数1表示Pos下标后多少个console.log(removeItem); 10 复制数组1234// 复制数组 1let newPeople1 = people; //people和newPeople1指向同一个内存// 复制数组 2let newPeople2 = people.slice(); // people和newPeople1指向不同一个内存 11 Index超出数组长度12people[100] = 'bbb';console.log(people); 12 Array.prototype.filter() 过滤12const fifteen = inventors.filter(inventor=&gt;(inventor.year&gt;=1500 &amp;&amp; inventor.year &lt; 1600));console.table(fifteen); 13 Array.prototype.map()12345const fullNames = inventors.map(inventor =&gt; (inventor.first + ' ' + inventor.last));const fullNames2 = inventors.map(inventor =&gt; `${inventor.first} ${inventor.last}`);console.log(fullNames);console.log(fullNames2); 14 Array.prototype.sort()12345678910// 升序const ordered = inventors.sort((a,b) =&gt; a.year &gt; b.year ? 1 : -1);console.table(ordered);// 降序const oldest = inventors.sort(function(a,b){ const lastInventor = a.passed - a.year; const nextInventor = b.passed - b.year; return lastInventor &gt; nextInventor ? -1:1;});console.table(oldest); 15 Array.prototype.reduce() 结果返回单个值123456// Array.prototype.reduce() 结果返回单个值const totalYears = inventors.reduce((total,inventor) =&gt; { return total + (inventor.passed - inventor.year);}, 0); // 0表示返回的单个值再加上0console.log(totalYears); 结论完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/15/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C-04/"},{"title":"【原生javascript项目】 Flex Panel 05","text":"引言本文介绍一个动态放映网页，知识点主要涉及到flex容器，以及元素点击事件。 效果网站：https://janice143.github.io/flexPanel/ 正文一、html部分主要为5个div元素将网页分为5块，横向排列。每一个div元素中有上中下三个p标签，对应3段话。 123456789101112131415161718192021222324252627&lt;div class=&quot;panels&quot;&gt; &lt;div class=&quot;panel1 panel&quot; onclick=&quot;clickOpen(1)&quot;&gt; &lt;p&gt;Hey&lt;/p&gt; &lt;p&gt;Let's&lt;/p&gt; &lt;p&gt;Dance&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel2 panel&quot; onclick=&quot;clickOpen(2)&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;Take&lt;/p&gt; &lt;p&gt;Receive&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel3 panel&quot; onclick=&quot;clickOpen(3)&quot;&gt; &lt;p&gt;Experience&lt;/p&gt; &lt;p&gt;It&lt;/p&gt; &lt;p&gt;Today&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel4 panel&quot; onclick=&quot;clickOpen(4)&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;All&lt;/p&gt; &lt;p&gt;You can&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel5 panel&quot; onclick=&quot;clickOpen(5)&quot;&gt; &lt;p&gt;Life&lt;/p&gt; &lt;p&gt;In&lt;/p&gt; &lt;p&gt;Motion&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 二、css部分css代码主要要实现5个div元素均匀横向排列，每个div元素内有对应的背景图片、3个p标签的文本。P标签的文本在每一个div元素中也是左右居中、上下均匀排列。主要是利用了flex容器来实现。 1 flex容器参考网站：https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器的属性： flex-direction：项目的排列方向 flex-wrap：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 flex-flow：flex-direction属性和flex-wrap属性的简写形式 justify-content：项目在主轴上的对齐方式 align-items：项目在交叉轴上如何对齐 align-content：定义了多根轴线的对齐方式 项目的属性： order：项目的排列顺序，数值越小，排列越靠前 flex-grow：定义项目的放大比例，默认为0 flex-shrink：项目的缩小比例，默认为1 flex-basis： 项目占据的主轴空间 flex：是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 2 css字体1234&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Amatic+SC&quot;&gt;text-transform: uppercase;font-family: 'Amatic SC',cursive;text-shadow: 0 0 4px rgba(0,0,0,0.72),0 0 14px rgba(0,0,0,0.45); 3过渡样式12345transition:font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),background 0.2s;transform:translateY(-100%); 4 背景图片1234567background-size: cover;background-position: center;.panel1 { background-image:url(https://source.unsplash.com/gYl-UtwNg_I/1500x1500); }.panel2 { background-image:url(https://source.unsplash.com/rFKUFzjPYiQ/1500x1500); }.panel3 { background-image:url(https://images.unsplash.com/photo-1465188162913-8fb5709d6d57?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;w=1500&amp;h=1500&amp;fit=crop&amp;s=967e8a713a4e395260793fc8c802901d); }.panel4 { background-image:url(https://source.unsplash.com/ITjiVXcwVng/1500x1500); }.panel5 { background-image:url(https://source.unsplash.com/3MNzGlQM7qs/1500x1500); } 5其他CSS选择器 * 将匹配文档的所有元素；&gt; 组合器选择前一个元素的直接子代的节点。 .panel &gt; *选择类名为panel的所以直接子元素 Js部分我写的程序，大致思路是在html代码里设置onclick属性，然后函数内容在js里写，不同的panel传入参数不一样 定位类名有两个以上的标签document.getElementsByClassName(panel${num} panel-open)； 1234567891011// 点击panel 12345，给对应的panel添加.panel-open属性function clickOpen(num){ const panelNumIf = document.getElementsByClassName(`panel${num} panel-open`); const panelNum = document.getElementsByClassName(`panel${num}`); // console.log(panelNumIf[0]) if (panelNumIf[0]) panelNumIf[0].classList.remove('panel-open'); else panelNum[0].classList.add('panel-open');//添加panel-open类属性 console.log(`panel${num} panel-open`); }; 别人的程序，大致思路是遍历5个Panel，监控是否有点击事件，有的话就运行toggleOpen函数，该函数里 this.classList.toggle(‘open’)表示如果this有open类名，则删除，没有则加上。 e.propertyName获取transitionend的属性名，e.propertyName.includes(‘flex’)包含flex字段的属性名 12345678910111213const panels = document.querySelectorAll('.panel');function toggleOpen() { console.log('Hello'); this.classList.toggle('open');}function toggleActive(e) { console.log(e.propertyName); if (e.propertyName.includes('flex')) { this.classList.toggle('open-active'); }}panels.forEach(panel =&gt; panel.addEventListener('click', toggleOpen));panels.forEach(panel =&gt; panel.addEventListener('transitionend', toggleActive)); 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/17/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Flex-Panel-05/"},{"title":"【原生javascript项目】 Fun dictionary 06","text":"作者：©Iaine 万一简介：30-day vanilla js coding challenge (30 Day Challenge)是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。本项目属于第6天项目，为了更有挑战性，我尝试实现了 单词查找 的功能。 Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/funDictionary/ 引言在输入框中输入一个单词，会实时匹配现有词库中所有包含该字段的单词（以一定的样式展示），每个单词中，会高亮显示出文本输入框中输入的字段。词库为json数据，在加载页面时，异步获取而来。 项目主要知识点包括： 异步操作 数组Array对象的一些方法 正则表达式 CSS transform的一些属性 项目过程html部分设置input标签用来输入单词，ul标签（列表标签）用来展示搜索的结果 JS部分 空数组直接赋值给一个dict变量，用来存储json数据中的词库 使用fetch 方法从网络中异步获取资源，解析 JSON 数据，存入数组dict 利用 filter() 方法查找单词wordToMatch，筛选的条件是正则表达式，如果string的match(regex)方法返回不是空，则filter函数返回词库中所有wordToMatch字段的单词 运用 filter() 过滤数组数据 创建正则表达式，构造过滤条件 match方法匹配 编写匹配输入的函数。在Html中显示匹配的单词，利用map方法按照原始数组元素顺序依次处理元素。 获取匹配数据 替换关键词放入高亮的标签 构造 HTML 标签数据 将匹配值的 HTML 标签放入 &lt;ul&gt; 中 编写展示匹配结果的函数 获取匹配数据 利用map方法依次处理元素，替换关键词放入高亮的标签，返回html标签数据 将匹配值的 HTML 标签放入 &lt;ul&gt; 中 获取两个主要 HTML 元素（&lt;input&gt;，&lt;ul&gt;），给 &lt;input&gt; 添加事件监听（change, keyup） CSS部分CSS**transform**属性允许旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。 项目知识点异步操作概念：程序执行任务时分两段进行，执行第一段任务后，执行其他任务，其他任务执行完后接着执行第二段任务。 异步操作的方法： 回调函数多重嵌套 缺点：出现多重嵌套，代码很容易乱成一团，无法管理，出现callback hell。 示例: 读取A文件之后，再读取B文件，之后再回到读取A文件后的操作。 12345fs.readFile(fileA, function (err, data) { fs.readFile(fileB, function (err, data) { // ... });}); Promise 它不是新的语法功能，而是一种新的写法。代码从横向发展，变成纵向发展。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function(data){ console.log(data.toString());}).then(function(){ return readFile(fileB);}).then(function(data){ console.log(data.toString());}).catch(function(err) { console.log(err);}); 参考文档：https://wiki.jikexueyuan.com/project/es6/async.html#:~:text=%E6%89%80%E8%B0%93%22%E5%BC%82%E6%AD%A5%22%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4,%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B0%B1%E5%8F%AB%E5%81%9A%E5%BC%82%E6%AD%A5%E3%80%82 fetch属于Fetch API的一个全局方法。需要接受 url 作为参数，返回值是一个 Promise 对象。若请求成功，这个对象包含了（对应 Request 的）Response，但这只是一个 HTTP 响应。 一个基本的 fetch 请求设置代码如下： 123fetch('http://example.com/movies.json') .then(response =&gt; response.json()) .then(data =&gt; console.log(data)); 这里通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 fetch() 到的资源路径，然后返回一个包含响应结果的 promise（一个 Response 对象）。 当然它只是一个 HTTP 响应，而不是真的 JSON。为了获取JSON的内容，我们需要使用 json() 方法（该方法返回一个将响应 body 解析成 JSON 的 promise）。 对象转换为数组获取的资源data为对象类型， ``{a: ‘The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).’, ab: ‘The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.’, aback: ‘Backward against the mast;-said of the sails when …uddenly checked, baffled, ordiscomfited. Dickens.’, abaft: ‘Behind; toward the stern from; as, abaft the wheelhouse. Abaftthe beam. See under Beam.’, abalone: ‘A univalve mollusk of the genus Haliotis. The shel…oast of California, clingingclosely to the rocks.’, …}` 想要转换为数组： [0:{a: 'The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).'} 1:{ab: 'The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.'}] 代码参考链接：https://juejin.cn/post/6844903602478120967 12345data =&gt; Object.keys(data).forEach(v =&gt; { let o = {}; o[v] = data[v]; dict.push(o);}) Object.keys方法是JavaScript中用于遍历对象属性的一个方法 。它传入的参数是一个对象，返回的是一个数组，数组中包含的是该对象所有的属性名。 正则表达式概念：匹配字符串的字符组合模式 创建一个正则表达式有两种方法： 1 使用正则表达式字面量，包含在斜杠之间 2 调用RegExp对象的构造函数 知识参考链接：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions 正则表达式可以被用于 RegExp 的 exec 和 test (en-US) 方法以及 String 的 match (en-US)、replace、search (en-US) 和 split (en-US) 方法。其中match方法是一个在字符串中执行查找匹配的String方法，返回一个数组，在未匹配到时会返回 null。 12345678// 匹配单词 function findWords(wordToMatch,dict){ return dict.filter(word =&gt;{ const regex = new RegExp(wordToMatch,'gi');// g:global,i:intensive if (Object.keys(word)[0].match(regex)) return word[Object.keys(word)[0]]; }) }; 一些数组和对象方法17个实用的JavaScript数组和对象的方法：https://segmentfault.com/a/1190000015301183 .filter()创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 .map()创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 .reduce()对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。 .forEach()对数组的每个元素执行一次提供的函数。 .some()判断数组中的某些元素是否通过由提供的函数实现的测试。 .every()检查是否数组中的每个值都满足条件。 .includes()检查是否一个数组包含一个确定的值。 Array.from()这是一个可以从其他数组或者字符串中创造新array的方法。 Objects.values()返回一个由给定对象自己的所有可枚举属性值的数组。 Objects.keys()返回一个由给定对象的自身可枚举属性组成的数组。 Object.entries()返回一个由一个给定对象的键值对组成的数组。 Array spread在数组中使用扩展运算符（…）可以展开数组中的元素。 Object spread扩展对象允许为一个没有更改的对象添加新的属性和方法（换句话说，创建了一个新对象) Object.freeze()防止修改现有的对象属性或者向对象添加新的属性和值。 Object.seal()停止将任何新属性添加到对象，但仍允许更改现有属性。 Object.assign()允许将对象组合在一起。 想把我的技术文章写好一点，特意参考其他优秀人的文档，感谢未枝丫，我觉得他的文档写的不错，特意模仿，顺便挂上他的JS30挑战项目链接。 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/06/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Fun-dictionary-06/"},{"title":"【原生javascript项目】Canvas 08","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第8天项目，为了更有挑战性，我实现了 移动端绘图 、画笔样式选择的功能。Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/myCanvas/ （画了个嗅嗅，一不小心暴露自己是个魔法师啦，哈哈） 项目描述利用html5 中的canvas实现的画板。在电脑端可利用鼠标移动点击进行绘图，在移动端可以通过触摸移动实现绘图。绘图的笔颜色、粗细可以调节，选中橡皮擦可对局部区域进行修改，清屏按钮可以一键清屏。 项目重点 canvas window.innerWidth lineJoin、lineWidth、lineCap strokeColor beginPath、moveTo、lineTo、stroke() 鼠标事件 mousemove: e.offsetX, e.offsetY mouseup mouseout mousedown 触摸事件 touchmove touchend touchcancel touchstart touch坐标计算的坐标偏移问题 input标签的change事件 this.value this.name this.checked 滑块input线性过渡变成非线性过渡 css的flex容器属性 display:flex align-items: center 竖直居中 justify-content: center 水平居中 项目过程html部分 三个input控件 颜色 type=”color” 粗细 type=”range” 橡皮擦 type=”checkbox” canvas标签设置画布 清屏按钮 type=”button” Js部分 获取canvas标签，并设定宽度和高度；获取四个input元素 利用getContext()获取渲染上下文，存储在变量ctx中。 在二维渲染上下文中，左上点坐标为(0,0)，向右（x轴）向下（y轴）为正 设置初始值 初始化画笔颜色（ctx.StrokeStyle）粗细（ctx.lineWidth），橡皮擦不选中(eraserChecked = false)； 设置lineCap(线的末端形状）为圆形，lineJoin（两条线段连接处形状）为圆形 编写updateValue()函数 三个控件input发生改变时，触发事件，调用该函数，更新画笔三个初始值。 编写draw()函数 设定一个用于标记绘画状态的变量，画或者不画（true or false) 判断是鼠标事件还是触摸事件，返回当前鼠标点和触摸点的坐标 赋值新的画笔参数 绘制前调用beginPath()，设定路径起点、终点 编写clearCanvas()函数 清屏的原理就是在画布上画满一个白色矩阵 所有input的监听事件，控件中的change事件，清屏是click事件 CSS部分使用over-flow:hidden来设置页面不动，这点在移动端触摸时显得必不可少。 项目知识点Canvas 创建 Canvas 元素 1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; 通过 JavaScript 来绘制 12var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d'); 基本样式属性 颜色：strokeStyle：线条描边的颜色，fillStyle：填充的颜色 线型：lineCap：笔触的形状；lineJoin：线条相较的方式；lineWidth：线条的宽度 路径绘制 beginPath()：新建一条路径 stroke()：绘制轮廓 moveTo()：绘制操作的起点 lineTo()：路径的终点 触摸屏端坐标偏移问题使用鼠标事件在canvas画布上画画，非常容易就能获取到画布上的坐标，使用（e.offsetX，e.offsetY）就行。但是对于移动端的触摸屏，必须利用【页面上的坐标】-【画布左上角的坐标】=【画布上的坐标】公式去计算当前触摸位置坐标。 changedTouches[0].clientX表示当前触摸点在页面上的坐标，e.target.offsetLeft表示画布偏离页面左上角的位置。 12x = e.changedTouches[0].clientX -e.target.offsetLeft;y = e.changedTouches[0].clientY-e.target.offsetTop; JS30的第8个项目圆满完成啦，虽然对原项目做了一些改进，但是整体上也实现了一些我自己的独特功能。PS：发现自己真的很喜欢编程，fun with front end development.希望自己能力越来越强，实现自己的程序员梦想。 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Canvas-08/"},{"title":"【原生javascript项目】Go list 10","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第10天的“待办清单”项目，我增加了 双击删除任务 、添加任务的功能。Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/goList/ 项目描述利用一些 checkbox 类型的 input 元素，通过在js中实现特定功能，而设计的待办清单网页。在网页中，可以通过点击checkbox来标记任务状态，通过按住shift键可以对任务实现多项check。也可以通过点击添加来增加任务，完成的任务可以通过双击实现删除。 项目重点 类型为checkbox的input元素的点击事件，回调函数为clickCheck e.shiftKey this.checked 标记上一次点击的input，以及多选内部的Input 类型为text的input元素的change事件，回调函数为displayTask 使用createElement创建元素 使用append来在指定结点后添加html 输入文本回车后情况文本，this.value = ‘’ 监听双击事件，移除任务 checkbox后面的文本双击事件，回调函数为removeTask e.path[1].remove() 项目过程html部分 输入文本框input 定位在文本框上的div元素，点击后display: none 四个类名为task-item是checkbox和任务文本p 新添任务的占位标签，新添加的任务将会append在这里 Js部分 获取类型为checkbox的所有input，遍历点击事件 点击事件为clickCheck 多选操作的原理 123456789101112if(e.shiftKey &amp;&amp; this.checked) inputChecks.forEach(inputCheck =&gt; { console.log(inputCheck === this || inputCheck === lastChecked); if (inputCheck === this || inputCheck === lastChecked) { inBetween = !inBetween; // console.log('Starting to check them in between!'); } // console.log('行内是否',inBetween); if (inBetween) { inputCheck.checked = true; } }) 获取所有p元素，遍历双击事件 双击事件为removeTask 找到对应的任务路径，remove即可 123function removeTask(e){ console.log(e.path[1].remove());} 获取类名为add-icon的元素，监听点击事件，点击隐藏 使页面元素隐藏和显示可以有两种方式： 方式1：设置元素style属性中的display 123var t = document.getElementById('test');//选取id为test的元素t.style.display = 'none'; // 隐藏选择的元素t.style.display = 'block'; // 以块级样式显示 方式2：设置元素style属性中的visibility 123var t = document.getElementById('test');t.style.visibility = 'hidden'; // 隐藏元素t.style.visibility = 'visible'; // 显示元素 二者的区别在于设置display隐藏后不占用原来的位置，而visibility隐藏后元素位置任然被占用。 获取类型为text的input元素，监听change事件 change事件调用displayTask 动态插入html 使用createElement创建元素 使用append挂载元素 监听双击事件 123456789101112131415161718function displayTask(){ // 使用createElement创建元素 const newTaskItem = document.createElement('div'); newTaskItem.className = 'new-task-item'; const html = `&lt;div class=&quot;task-item&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;p&gt;${this.value}&lt;/p&gt;&lt;/div&gt;`; newTaskItem.innerHTML = html; newTask.append(newTaskItem); // console.log(newTask); // console.log(html); this.value = '' newTaskItem.addEventListener('dblclick',removeTask)} CSS部分 :checked 选择器 紧邻兄弟组合器：A+ B 组合器选择相邻元素，即后一个元素B紧跟在前一个A之后，并且共享同一个父节点 添加删除线 text-decoration: line-through; 项目知识点DOM 树DOM为文档对象模型，每个 HTML 标签都是一个对象。 DOM 将 HTML 表示为标签的树形结构。标签被称为 元素节点（或者仅仅是元素），并形成了树状结构：&lt;html&gt; 在根节点，&lt;head&gt; 和 &lt;body&gt; 是其子项，等。元素内的文本形成 文本节点，被标记为 ＃text。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。 利用JS修改文档 创建一个元素（DOM节点） document.createElement(tag)创建一个新 元素节点（element node） document.createTextNode(text)创建一个 文本节点 创建 div 分为 3 个步骤： 12345678// 1. 创建 &lt;div&gt; 元素let div = document.createElement('div');// 2. 将元素的类设置为 &quot;alert&quot;div.className = &quot;alert&quot;;// 3. 填充消息内容div.innerHTML = &quot;&lt;strong&gt;Hi there!&lt;/strong&gt; You've read an important message.&quot;; 这时已经创建了该元素。但到目前为止，它还只是在一个名为 div 的变量中，尚未在页面中。所以我们无法在页面上看到它。 append挂载元素 为了让 div 显示出来，我们需要将其插入到 document 中的某处。 append：document.body.append(div)。 node.append(...nodes or strings) —— 在 node 末尾 插入节点或字符串， node.prepend(...nodes or strings) —— 在 node 开头 插入节点或字符串， node.before(...nodes or strings) —— 在 node 前面 插入节点或字符串， node.after(...nodes or strings) —— 在 node 后面 插入节点或字符串， node.replaceWith(...nodes or strings) —— 将 node 替换为给定的节点或字符串。 JS30的第10个项目圆满完成啦，虽然对原项目做了一些改进，但是整体上也实现了一些我自己的独特功能。PS：中间跳了第7和9个项目，如果有时间我后面会补上滴！ 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/09/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Go-list-10/"},{"title":"【原生javascript项目】Video player 11","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第11天的“自定义视频播放器”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/videoPlayer/ 项目描述利用video标签，以及一些div标签，在js中设置视频的播放控件，包括暂停/播放，声音调节，视频进度调节，视频播放率，跳过/退后。 项目重点 video对象的各种属性、方法和事件 paused play() pause() currentTime volume playbackRate HTML DOM offsetWidth 属性 获取元素的宽度，包含内边距（padding）和边框（border）: HTML5 data-* 自定义属性 this.dataset. data- 项目过程html部分 video标签标记视频文件 div标签和button标签实现的一些视频控件，类名为.controlers .progress进度条，.progress_filled进度条填充颜色 .player_button播放按钮 声音滑块 播放速度滑块 前进/后退按钮 Js部分 获取标签 编写自定义函数 播放按键 12const method = video.paused ? 'play' : 'pause';video[method](); 更新播放键的按键 12const icon = this.paused ? '►' : '❚ ❚';toggle.textContent = icon; 前进/后退 1video.currentTime += parseFloat(this.dataset.skip); 更新滑块的值 1video[this.name] = this.value; 更新进度条（填充颜色） 12const percent = (video.currentTime / video.duration) * 100;progressBar.style.flexBasis = `${percent}%`; 鼠标移动进度条 12const scrubTime = (e.offsetX / progress.offsetWidth) * video.duration;video.currentTime = scrubTime; 添加监听事件 视频的click,play,pause,timeupdata事件 播放按钮、前进后退按钮的click事件 滑块的change,mousemove事件 进度条的click,mousemove,mousedown,mouseup事件 CSS部分 flex容器的项目属性 flex-basis：项目占据的主轴空间（main size） flex 属性选择器 input[type=range] 项目知识点data-*自定义数据属性，可通过所属元素的 HTMLElement 接口访问，确切地说是HTMLElement.dataset ， HTMLElement.dataset[&quot;testValue&quot;] 属性访问。 注*：data-后面的命名规则 该名称不能以xml开头，无论这些字母是大写还是小写； 该名称不能包含任何分号； 该名称不能包含A至Z的大写字母 data后面的命名中有-，如 data-test-value ，可通过 HTMLElement.dataset.testValue ( 或者是HTMLElement.dataset[&quot;testValue&quot;]) 来访问，任何短线符号都会被下个字母的大写替代(驼峰拼写)。 JS30的第11个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/18/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Video-player-11/"},{"title":"【原生javascript项目】Secret code sequence 12","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第12天的“字符序列检测”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/secretCode/ 键盘输入 happy 2022 即可触发彩蛋。 项目描述通过判断键盘输入的字符串中是否含有指定字符串序列，开启网页中的隐藏彩蛋。本项目的彩蛋是 从网页 Cornify.com 中加载一个 JS 文件，调用其中的 cornify_add() 方法时，随机在页面出加载独角兽的图标和p标签。 项目重点 window的keyup事件 window.addEventListener('keyup',) e.key 数组操作 .push() .splice() .length .join() .includes() 项目过程html部分 p标签标记一段提示的文字 Js部分 声明一个变量用来存储按下的字符串序列数组 声明一个变量用来存储已知的指定字符串序列 window的键盘监听事件 将字符串指定规则切分 1pressCode.splice(-secretCode.length - 1, pressCode.length - secretCode.length) 判断是否包含指定字符串 1if (pressCode.join('').includes(secretCode)){} 随机在页面中加载独角兽图标 1cornify_add(); 项目知识点js中的splice方法的使用说明splice方法可以用来对js的数组进行删除，添加，替换等操作。 删除。第一个参数为起始位置（如果为负数，表示倒数），第二个参数为要删除几个。 array.splice(index,num) 插入。第一个参数（插入位置），第二个参数（0），第三个参数（插入的项）。 array.splice(index,0,insertValue) 替换。第一个参数（起始位置），第二参数（删除项数），第三参数（插入任意数量的项）。 array.splice(index,num,insertValue) JS30的第12个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/20/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Secret-code-sequence-12/"},{"title":"【原生javascript项目】Slide in on scroll 13","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第13天的“图片随屏幕滚动而滑入滑出”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/sliderIn/ 项目描述本项目为一个图文浏览网页，其中，当浏览到图片时（屏幕滚动到图片上），图片具有滑入特效，浏览完毕后，图片滑出。滑入滑出特效由css的translateX()实现，触发特效有javascript控制。 项目重点 window的scroll事件 window.addEventListener('scroll') 一些位置（像素值） window.scrollY 文档当前垂直滚动的像素数 window.innerHeight viewport部分的高度 sliderImage.offsetTop 当前元素顶部相对于其 offsetParent 元素的顶部的距离 未枝丫博客有图解 debounce 的作用（函数防抖） 降低事件监听的频率，使用了 Lodash 中的 debounce 方法 项目过程html部分 p标签的文字 img标签的图片 JS部分 监听window的scroll事件 触发checkSlide函数 图片滑入条件：屏幕滚动位置以及屏幕高度之和 &gt; 图片顶部距离页面距离以及图片半高；屏幕滚动位置 &lt; 图片底部距离 1234const slideInAt = (window.scrollY + window.innerHeight);const imageBottom = sliderImage.offsetTop + sliderImage.height;const isHalfShown = slideInAt &gt; (sliderImage.offsetTop + sliderImage.height / 2);const isNotScrolledPast = window.scrollY &lt; imageBottom; 函数防抖 由于每次滚动都触发监听事件，会降低 JavaScript 运行性能，所以用 debounce 函数来降低触发的次数 1234567891011121314function debounce(func, wait = 20, immediate = true) { var timeout; return function() { var context = this, args = arguments; var later = function() { timeout = null; if (!immediate) func.apply(context, args); }; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); };}; CSS部分 屏幕滚动之前，图片的状态是：不透明度为0（隐藏），x方向偏移30%（相对于图片大小），缩放95%。 1234567.align-right.slide-in {transform: translateX(30%) scale(0.95);}.slide-in.active {opacity: 1;transform: translateX(0%) scale(1);} 触发特效，图片的状态是：不透明度为1，x方向偏移0%（相对于图片大小），缩放1。 1234.slide-in.active { opacity: 1; transform: translateX(0%) scale(1);} 项目补充元素浮动作用能够实现让多个元素排在问一行,并且给这些元素设置宽度与高度。 背景在标准文档流中的元素只有两种：块级元素和行内元素。让多个元素排在同一行：行内元素的特性；给这些元素设置宽高:块级元素的特性。如果想让一些元素既要有块级元素的特点也要有行内元素的特点，只能让这些元素脱离标准文档流（脱标），浮动可以让元素脱离标准文档流，可以实现让多个元素排在同一行并且可以设置宽高。 实现浮动通过浮动属性来实现，float这个属性有两个值left向左浮动，向左移动、right向右浮动，向右移动。 浮动元素的特性 浮动元素脱离标准文档流不再占用空间； 我们可以把浮动元素理解为“漂” 浮动元素的层级比标准文档流里面的元素层级要高,会将标准文档流中的元素给压盖住 行内素浮动后，变成块状元素 清除浮动：只要有浮动那么必须有清除浮动1 为什么要清除浮动? 因为经过浮动元素会影响到下面的元素的排版布局，浮动元素的父元素没有将浮动元素包裹，只要清除了浮动，就不会影响到浮动元素的下面进行排版布局，浮动元素的父元素会将浮动元素从视觉上包裹着。 2 清除浮动有以下三种方法: 给浮动元素的父元素设置一个固定的高度 使用清除浮动的样式属性 clear.（clear:left清除左浮动, clear: right:;清除右浮动 clear: both两者都清除）,这个属性一般用在最后一个浮动元素的下面,在最后一个浮动元素的下面（不是子级，而是并列下一行）新建一个空白的div,这个div什么内容都不要放,只做一件事件，就是清除浮动 使用 overflow: hidden这个属性来清除浮动 注意*：使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围 JS30的第13个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/30/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Slide-in-on-scroll-13/"},{"title":"【原生javascript项目】Reference VS copy 14","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第14天的“JS中引用和复制区别”项目。Have fun with the website! ♪(^∇^*) 项目描述本项目主要是在javascript中对比引用和复制变量的区别，效果在console（控制台）中显示。 项目重点 对于基础类型的值，存储的是值 number string boolean 对于复杂类型的值，存储的是引用（指针） arr object regx 对于复杂类型的值，如果实现复制 arr Array.prototype.slice() Array.prototype.concat() ES6 扩展语法 Array.from() 对象 Object.assign() JSON 转换 项目过程JS部分 首先从 String、Number、Boolean 类型的值开始。 12345let age = 100;let age2 = age;console.log(age, age2); // 100 100age = 200;console.log(age, age2); // 200 100 改动age不会影响age2。 对于数组 123456const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];const team = players;console.log(players, team);team[3] = 'Lux';console.log(players, team); // [&quot;Wes&quot;, &quot;Sarah&quot;, &quot;Ryan&quot;, &quot;Lux&quot;] [&quot;Wes&quot;, &quot;Sarah&quot;, &quot;Ryan&quot;, &quot;Lux&quot;] 对数组进行和Number类型相同的复制操作，发现改动team会改变players。 结论：基础类型（number,string,boolean）将内容直接存储在栈中（大小固定位置连续的存储空间），记录的是该数据类型的值，即直接访问，基础类型赋值是复制（copy）； 复杂类型（object即广义的对象类型（arr,object,regx））将内容存储在堆中，堆所对应的栈中记录的是指针（堆的地址），外部访问时先引出地址，再通过地址去找到值所存放的位置。复杂类型赋值是地址引用。 数组的复制 方法一 Array.prototype.slice() 123const team2 = players.slice();team2[3] = 'Lux2';console.log(players, team2); 方法二 Array.prototype.concat() 123const team3 = [].concat(players);team3[3] = 'Lux3';console.log(players, team3); 方法三 ES6 扩展语法 123const team4 = [...players];team4[3] = 'Lux4';console.log(players, team4); 方法四 Array.from() 123const team5 = Array.from(players);team5[3] = 'Lux5';console.log(players, team5); 对象的复制 方法一 Object.assign() 123456const person = { name: 'Wes Bos', age: 80 };const cap2 = Object.assign({}, person, { number: 99, age: 12 });console.log(cap2); // Object {name: &quot;Wes Bos&quot;, age: 12, number: 99} 方法二 JSON 转换 12345678910111213const wes = { name: 'Wes', age: 100, social: { twitter: '@wesbos', facebook: 'wesbos.developer' }};const dev = Object.assign({}, wes);const dev2 = JSON.parse(JSON.stringify(wes));console.log(wes);console.log(dev);console.log(dev2); 项目补充ES6扩展运算符符号：... 作用：将数组或对象进行展开 例如，对于数组arr=[1,2,3] console.log(…arr)相当于for循环把arr中每个元素打印一下。 参考博客1 js 值引用和值复制 2 对象引用和复制 3 总结 ES6 扩展运算符（…） 4 未枝丫的JS30博客 JS30的第14个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/31/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Reference-VS-copy-14/"},{"title":"【原生javascript项目】Local storage 15","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第15天的“JS window属性： localStorage ”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/localStorage/ 项目描述本项目是一个可添加项目的点菜清单，刷新网页时，菜单信息不会清空。实现该功能的主要技术是JavaScript Window 对象的localStorage属性。 项目重点 localStorage localStorage.setItem localStorage.getItem JS取消默认行为 event.preventDefault reset() 方法 把表单中的元素重置为默认值 JSON 的方法 JSON.stringify JSON.parse 项目过程HTML部分 网页logo &lt;svg&gt;标签 菜品清单内容 标题&lt;h2&gt; 菜单项目&lt;ul&gt; 添加菜品表单&lt;form&gt; 1234567891011&lt;div class=&quot;wrapper&quot;&gt; &lt;h2&gt;LOCAL TAPAS&lt;/h2&gt; &lt;p&gt;&lt;/p&gt; &lt;ul class=&quot;plates&quot;&gt; &lt;li&gt;Loading Tapas...&lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;add-items&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;item&quot; placeholder=&quot;Item Name&quot; required&gt; &lt;input type=&quot;submit&quot; value=&quot;+ Add Item&quot;&gt; &lt;/form&gt; &lt;/div&gt; CSS部分 菜品项目添加后默认复选框⬜️没有checked 1234.plates input + label:before {content: &quot;⬜️&quot;;margin-right: 10px;} 菜品项目checked后方框变成其他图标 123.plates input:checked + label:before {content: &quot;🌮&quot;;} JS部分 form表单中若有type 属性是 “submit”的元素，则具有submit 事件 1234function addItem(){ console.log('hello')}addItems.addEventListener('submit', addItem); 当点击form中的提交按钮时，会提交表单并且刷新页面（可在控制台中看出闪现hello），这种默认行为可以通过 e.preventDefault来阻止 123function addItem(e){ e.preventDefault();} 下面开始正式编写addItem函数，用来获取form中添加的元素，然后放到items变量中存储起来 this.querySelector('[name=item]')选择type为text元素的值（输入框输入的内容） 构造一个对象 item 来存储这个信息 把item push到提前创建的items（所有菜单）中 1234567const text = (this.querySelector('[name=item]')).value;// 构造一个对象 item 来存储这个信息item = { text, // ES6中对 text: text, 的简写 done:false // 标记有没有checked}items.push(item); 执行populateList(items, itemsList)函数，把新添加的菜品显示到页面中 更新localStorage中的items数据 重置输入框的值 123populateList(items, itemsList);localStorage.setItem('items', JSON.stringify(items));this.reset(); 编写populateList函数，实现将items中的信息挂载到DOM树上 &lt;input&gt;标签实现的复选框 data-index属性标记菜品序号 &lt;label&gt;标签记录菜单的文字 12345678910function populateList(plates = [], platesList) { platesList.innerHTML = plates.map((plate, i) =&gt; { return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=${i} id=&quot;item${i}&quot; ${plate.done ? 'checked' : ''} /&gt; &lt;label for=&quot;item${i}&quot;&gt;${plate.text}&lt;/label&gt; &lt;/li&gt; `; }).join('');} 程序写到这里基本完成，但是仔细观察会发现，如果checked每个菜品，刷新页面后，这个状态会被刷新（不被保留），这是因为我们并没有更新items中done的值 所以还需编写toggleDone函数，通过菜品click事件触发 e.target.dataset.index可以获取利用data-index属性标记菜品序号 !items[index].done否操作 更新localStorage和HTML页面 12345678910function toggleDone(e) { if (!e.target.matches('input')) return; // skip this unless it's an input // console.log(e.target) const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; localStorage.setItem('items', JSON.stringify(items)); populateList(items, itemsList); }itemsList.addEventListener('click', toggleDone); 项目补充HTML &lt;input&gt; 标签的 required 属性required 属性规定必需在提交之前填写输入字段 JS-preventDefault() 取消默认行为语法：event.preventDefault() 该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。 常用情景： 如果 type 属性是 “submit”，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。 标签在form表单中时，click事件默认会提交表单刷新页面，调用可方法，可避免刷新页面 a 标签点击时，会跳转url，采用如下方式，可防止链接打开 URL： 常用情景的知识点来源于博客 JSON.parse和JSON.stringifyJSON对象在所有现代浏览器中都适用，他有两个非常有用的方法是parse()和stringify(). JSON.parse() 把一个JSON字符串转变成JS对象 1234let userStr = '{&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;}';let userObj = JSON.parse(userStr);console.log(userObj);// {name: 'Sammy', email: 'sammy@example.com', plan: 'Pro'} JSON.parse() 第二个参数可以是一个自定义函数，具有返回值 123456789let userStr = '{&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;}';let userObj = JSON.parse(userStr, (key, value) =&gt; { if (typeof value === 'string') { return value.toUpperCase(); } return value;});console.log(userObj);// {name: 'SAMMY', email: 'SAMMY@EXAMPLE.COM', plan: 'PRO'} JSON.stringify() 把一个JS对象转变成JSON字符串 12345678let userObj = { name: &quot;Sammy&quot;, email: &quot;sammy@example.com&quot;, plan: &quot;Pro&quot;};let userStr = JSON.stringify(userObj);console.log(userStr);// {&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;} JSON.stringify()可以有两个额外参数 一个replacer参数（是一个自定义函数，函数名为replacer) 123456789101112131415let userObj = { name: &quot;Sammy&quot;, email: &quot;sammy@example.com&quot;, plan: &quot;Pro&quot;};function replacer(key, value) { console.log(typeof value); if (key === 'email') { return undefined; } return value;}let userStrReplacer = JSON.stringify(userObj, replacer);console.log(userStrReplacer);// {&quot;name&quot;:&quot;Sammy&quot;,&quot;plan&quot;:&quot;Pro&quot;} 一个是space参数（是 String 或者 Number 值），用来控制间距 如果是Number，缩进为空格数(1-10) 如果是String，缩进为该字符串 123456JSON.stringify({ uno: 1, dos: 2 }, null, '\\t');// returns the string:// '{// &quot;uno&quot;: 1,// &quot;dos&quot;: 2// }' map()和forEach()的区别和理解两个方法都可以实现元素遍历，但是map方法可以用返回值，而forEach方法没有返回值 参考博客 JS-preventDefault() 取消默认行为 How To Use JSON.parse() and JSON.stringify() Example of using JSON.stringify() with localStorage map()和forEach()的区别和理解 JS30的第15个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/04/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Local-storage-15/"},{"title":"【原生javascript项目】Mouse Move Shadow 16","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第16天的“文字阴影随鼠标移动”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/mouseMoveShadow/ 项目描述本项目实现的是一个文字阴影随鼠标位置移动的特效。其中文字阴影是通过添加CSS的text-shadow属性实现的，为了让文字阴影随鼠标位置移动，需要获取当前鼠标的位置，通过一些转化变成对应的文字阴影位置。 项目重点 CSS的text-shadow属性 text-shadow: 10px 10px 0 rgba(0,0,0,1), 10px 20px 0 rgba(200,0,0,1); HTMLElement的一些只读属性 offsetWidth offsetHeight offsetLeft offsetTop 鼠标事件的一些属性 offsetX offsetY 项目过程HTML部分 类名为hero的div元素 h1标签，加了contenteditable属性，表示浏览网页的用户可以编辑 CSS部分 让网页主题内容水平、垂直居中 123display: flex;justify-content: center;align-items: center; 让文字具有阴影（后面再JS中会修改） 12345h1 { text-shadow: 10px 10px 0 rgba(0,0,0,1); /* text-shadow: 10px 10px 0 rgba(0,0,0,1), 10px 20px 0 rgba(200,0,0,1); */ font-size: 100px;} JS部分 首先创建三个变量，一个指向类名为hero的元素，一个指向h1元素，最后一个变量walk用来存储文字阴影距离原文字最大距离的一半。 监听hero上的mouseover的事件，回调函数为shadow 回调函数要实现的是，获取鼠标移动事件的位置offsetX和offsetY，通过一些公式将这两个位置变成新的位置信息，然后修改CSS样式上的text-shadow属性。 首先设置变量width和height存储hero元素的宽高信息 设置变量x和y存储鼠标移动事件的位置信息 12const { offsetWidth: width, offsetHeight: height } = hero;let { offsetX: x, offsetY: y } = e; 这里的写法采用了ES6的**解构赋值写法**，语句let { offsetX: x, offsetY: y } = e;等同于let x = e.offsetX; let y = e.offsetY; offsetX/offsetY：鼠标位置（相对于最近父元素的坐标） offsetWidth/offsetHeight：元素的宽高（width+padding+border） 转换的公式如下所示，其中x/width是一个比例系数 12const xWalk = Math.round((x / width * walk) - (walk / 2));const yWalk = Math.round((y / height * walk) - (walk / 2)); 利用JS修改CSS中的text-shadow属性，具体来说有四个文字阴影，分布在text的四个角落 123456text.style.textShadow = `${xWalk}px ${yWalk}px 0 rgba(255,0,255,0.7),${xWalk * -1}px ${yWalk}px 0 rgba(0,255,255,0.7),${yWalk}px ${xWalk * -1}px 0 rgba(0,255,0,0.7),${yWalk * -1}px ${xWalk}px 0 rgba(0,0,255,0.7)`; 程序写到这里会出现一个bug，当鼠标移动到h1时，文字阴影没有在文字中聚焦，这是因为鼠标移动到h1时，offsetX表示的是相对于h1的位置；当鼠标移动在hero上时，offsetX表示的是相对于hero的位置。 所以还需要添加在shadow函数中，首先需要做个条件判断 1234if (this !== e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop;} 写到这里程序就大体完成啦！具体代码我放在了github上。 项目补充JavaScript中event.target与this区别this一直指向函数的调用者，在本程序中，鼠标无论移动到hero上还是h1上，console.log(this)显示的一直是 123&lt;div class=&quot;hero&quot;&gt; &lt;h1 contenteditable style=&quot;text-shadow: rgba(255, 0, 255, 0.7) 241px 101px 0px, rgba(0, 255, 255, 0.7) -241px 101px 0px, rgba(0, 255, 0, 0.7) 101px -241px 0px, rgba(0, 0, 255, 0.7) -101px 241px 0px;&quot;&gt;🔥WOAH!&lt;/h1&gt;&lt;/div&gt; 而event.target指向的是触发该事件的目标节点，在本程序中，鼠标移动到hero上，显示内容和上述一样，但是移动到h1上时，显示内容为 1&lt;h1 contenteditable style=&quot;text-shadow: rgba(255, 0, 255, 0.7) 241px 101px 0px, rgba(0, 255, 255, 0.7) -241px 101px 0px, rgba(0, 255, 0, 0.7) 101px -241px 0px, rgba(0, 0, 255, 0.7) -101px 241px 0px;&quot;&gt;🔥WOAH!&lt;/h1&gt; 因此，this与event.target的区别为当含有事件冒泡时，this一直指向该函数的调用者，而event.target则指向触发该事件的目标节点 ES6 解构赋值解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。 以前，为变量赋值，只能直接指定值。 123var a = 1;var b = 2;var c = 3; ES6允许写成下面这样。 1var [a, b, c] = [1, 2, 3]; 上述为数组赋值。 对于对象赋值，可以写成在这样 1var { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; 如果变量名与属性名不一致，必须写成下面这样 1234let obj = { first: 'hello', last: 'world' };let { first: f, last: l } = obj;f // 'hello'l // 'world' 参考博客 ES6 变量的解构赋值 JavaScript中event.target与this区别 JS30的第16个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/10/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Mouse-Move-Shadow-16/"},{"title":"【原生javascript项目】Sort without Articles 17","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第17天的“去除冠词排序”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/sortWithoutArticles/ 项目描述本项目首先给定了一个内容为band名字的列表bands，在JS中，对列表进行特殊的排序操作，得到新的列表最终以列表的形式显示到网页中。 其中特殊的排序操作，具体来说，是先去除列表元素中”a, an, the”的前缀，然后按照字母排序。排序的列表还是原列表，无需使列表元素去除特定前缀。 项目重点 字符串的一些方法 String.prototype.replace() String.prototype.trim() 数组的一些方法 Array.prototype.sort() 正则表达式 /^(a |the |an )/i 项目过程HTML部分 id 属性为bands的ul元素，列表内容在JS中添加 JS部分 首先提供一个已知列表bands 将列表bands内容显示到网页中 1document.querySelector('#bands').innerHTML = bands.map(band =&gt; `&lt;li&gt;${band}&lt;/li&gt;`).join(''); 显示已经实现，下一步我们需要对bands进行一些操作，得到的新列表再按照上述方法显示到网页中。注意：无需对原列表bands进行操作，也就是不用改变bands的值 去除前缀 123function strip(bandName){ return bandName.replace(/^(a |the |an )/i,'').trim();} 排序 12345const sortedBands = bands.sort( function(a,b){ return strip(a) &gt; strip(b) ? 1 : -1 }) 程序写到这里就已经ok啦！本项目需要注意的是最后显示的内容还是原bands中的元素，但是排序方式要求去掉前缀后排序。 如果项目要求最后显示的内容是去除前缀的元素，那么下面的程序提供了一个实现思路： 去除前缀 123456// 先将bands元素中开头为a|the|an的去掉前缀，返回新的bandsfunction newBands(bands){ return bands.map(band =&gt; { return band.replace(/^(a |the |an )/i,'').trim(); })} 排序 1const sortedBands = newBands(bands).sort() 项目补充String.prototype.replace()replace(pattern,replacement) 方法返回一个新字符串，该字符串由replacement替换部分或所有的pattern匹配项后的新字符串。 pattern可以是一个字符串或者一个正则表达式，replacement可以是一个字符串或者一个每次匹配都要调用的回调函数。 如果pattern是字符串，则仅替换第一个匹配项。 原字符串不会改变。 语法1str.replace(regexp|substr, newSubStr|function) String.prototype.trim()从一个字符串的两端删除所有空白字符。 Array.prototype.sort()1arr.sort([compareFunction]) 主要讲讲有compareFunction的情况，该函数具有两个参数a,b。 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 例如比较数字，compareFunction函数可以简单的以 a 减 b，如下的函数将会将数组升序排列 1234567function compareNumbers(a, b) { return a - b;}// 也可以这样些function compareNumbers(a, b) { return a &gt; b ? 1 : -1;} 正则表达式的特殊字符 ^匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。 例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 参考博客 正则表达式中的特殊字符 JS30的第17个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/14/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Sort-without-Articles-17/"},{"title":"【原生javascript项目】Time with Redece 18","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第18天的“利用reduce进行时间累加”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/18%20timeWithReduce/index.html 项目描述项目首先在html中提供了若干个属性名为data-time的列表元素，data-time的值以00:00（分：秒）的格式显示。要求在JS中计算出data-time的总值，并且用？时？分？秒的格式显示结果。 项目重点 Array.from() timeNode.dataset.time .split(':') .map(parseFloat) .reduce() Math.floor() 项目过程HTML部分 若干个li标签，添加了data-time属性 JS部分JS的整体思路是先获取所有的data-time的值，然后将所有值转化成秒，并且计算出的总秒数。根据总秒数得到对应的时、分、秒。 为了显示最后的结果，在本项目中国通过创建一个p元素来实现。 获取所有的data-time元素，转化成数组，并存储在timeNodes变量中 1const timeNodes = Array.from(document.querySelectorAll('[data-time]')); 从timeNodes中可以得到data-time的值 123const seconds = timeNodes.map( timeNode =&gt; timeNode.dataset.time) 将每个data-time的值转化成秒 1234567.map( timeCode =&gt; { const [min, sec] = timeCode.split(':').map(parseFloat) // console.log(typeof(min),sec) return (min*60)+sec }) 利用reduce方法累加得到总秒数 123.reduce( (total,vidSecond) =&gt; total + vidSecond) 根据总秒数，计算出时、分、秒 123456let leftSec = seconds;const hour = Math.floor(leftSec/3600);leftSec = leftSec % 3600;const min = Math.floor(leftSec/60);leftSec = leftSec % 60; 新建一个p元素，添加显示内容，最后挂载到网页上，显示结果 1234567891011function display(hour,min,leftSec){ // 使用createElement创建元素 const newTaskItem = document.createElement('p'); newTaskItem.className = 'total-time'; const html = ` 总播放时间为：${hour}小时${min}分${leftSec}秒。`; newTaskItem.innerHTML = html; document.querySelector('ul').before(newTaskItem);} 项目补充Array.from：将一个伪数组对象转化成数组。 .split()：将一个String对象分割成子字符串数组 parseFloat(string)将字符串解析为浮点数 如果 parseFloat 在解析过程中遇到了正号（+）、负号（- ）、数字（0-9）、小数点（.）、或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。 第二个小数点的出现也会使解析停止。 参数首位和末位的空白符会被忽略。 如果字符串的第一个字符不能被解析成为数字，则返回 NaN。 parseFloat 也可以解析并返回 Infinity。 reduce方法语法1arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) initialValue为作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 示例123[0, 1, 2, 3, 4].reduce(function(accumulator, currentValue){ return accumulator + currentValue;}); // 10 JS30的第18个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/15/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Time-with-Redece-18/"},{"title":"【原生javascript项目】WebCam Fun 19","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第19天的“网络摄像头”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/19%20webCamFun/index.html 项目描述通过访问网络摄像头，获取了当前摄像头拍摄的信息，作为video元素的内容。video元素中的视频信息被定时器一帧一帧绘制在canvas元素中。 提供了一个名为take photo的按钮用来抓取当前视频帧的内容，该内容最后通过通过创建a标签显示在网页中。 项目重点 mediaDevices.getUserMedia video属性和方法 video.videoWidth video.srcObject setInterval canvas.toDataURL HTML DOM setAttribute(属性名，值) canplay事件 项目过程HTML部分 最外层为类名为photobooth的div元素 作为控件的div元素：take photo按钮 canvas元素用来绘制video的视频帧 video元素用来播放从网络摄像头获取的数据流 音频audio标签 JS部分JS的大致思路是： 请求调用网络摄像头 摄像头中的数据流给video元素 在canvas上绘制video的内容 点击take photo按钮获取当前canvas上的画面，显示到网页上 编写getVideo函数：访问网络摄像头的权限,播放视频，放在video标签里 1234567891011function getVideo(){ navigator.mediaDevices.getUserMedia({ video: true, audio: false }) .then(localMediaStream =&gt; { console.log(localMediaStream); video.srcObject = localMediaStream; video.play(); }) .catch(err =&gt; { console.error(`OH NO!!!`, err); }); } 把视频信息放到canvas中 先获取视频的宽高信息，复制给canvas.width和height，保证canvas上显示视频画面完整（注意这里并不是设置canvas在网页上显示的宽高） canvas流畅显示的机制是利用定时器不断获取当前video的内容 利用ctx.drawImage实现绘制 123456789101112function paintToCanvas(){ const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; // canvas上显示的机制是利用定时器，将视频中当前帧的图像绘制在canvas上 return setInterval(() =&gt; { ctx.drawImage(video, 0, 0, width, height); }, 16);}video.addEventListener('canplay', paintToCanvas); 编写take photo的点击函数 播放音效 获取当前canvas的data，变成图片 创建元素，显示到网页中 12345678910111213function takePhoto(){ // 播放音频 snap.currentTime = 0; snap.play(); // 获取当前canvas的data，变成图片 const data = canvas.toDataURL('image/jpeg'); const link = document.createElement('a'); link.href = data; link.setAttribute('download', 'handsome'); link.innerHTML = `&lt;img src=&quot;${data}&quot; alt=&quot;Handsome Man&quot; /&gt;`; strip.insertBefore(link, strip.firstChild);} 项目补充HTML 音频/视频 DOM canplay 事件当浏览器能够开始播放指定的音频/视频时，触发canplay 事件 常用CSS的长度单位（相对/绝对） 单位 名称 em 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width rem 根元素的字体大小 vw 视窗宽度的1% vh 视窗高度的1% px 像素 navigator.mediaDevices.getUserMedia提示用户允许一个媒体输入（视频、音频等），媒体输入会产生一个mediaStream包换了媒体信息。该方法返回一个promise 示例 1234567navigator.mediaDevices.getUserMedia(constraints).then(function(stream) { /* use the stream */}).catch(function(err) { /* handle the error */}); 其中constrains参数可为{ audio: true, video: true } X:after 选择器在元素内部的后面插入内容。常用来清楚浮动clear-fix。 123456789101112.clearfix:after { content: &quot;&quot;; display: block; clear: both; visibility: hidden; font-size: 0; height: 0; } .clearfix { *display: inline-block; _height: 1%; } 原理是使用:after伪类元素来在元素后增加一个空间，然后清除它。 overflow-xoverflow-x 属性规定是否对内容的左/右边缘进行裁剪，如果溢出元素内容区域的话。 overflow-y 属性对上/下边缘的裁剪。 a:nth-child(5n+1)选择第1、6、11…个a标签 利用canvas操纵video获取到video的每一帧内容后，绘制在canavs上。这是显示的第一步，除此之外，还可以做一些进阶，比如将每一帧画面。 1let pixels = ctx.getImageData(0, 0, width, height); JavaScript 定时器 setTimeout()：指定多久时间运行回调函数 123setTimeout(() =&gt; { // 2 秒之后运行}, 2000) setTimeout 会返回定时器的 id。 通常不使用它，但是可以保存此 id，并在要删除此安排的函数执行时清除它： 12345const id = setTimeout(() =&gt; { // 应该在 2 秒之后运行}, 2000)// 改变主意了clearTimeout(id) setInterval()：指定多少时间间隔运行一次回调函数 123setInterval(() =&gt; {// 每 2 秒运行一次}, 2000) 问题：这里如何清除定时器呢？每次触发video的canplay事件，会执行paintToCanvas函数，而该函数可以返回定时器的id。如果要清除该定时器，怎么清除呢？ 参考博客 30个你必须记住的CSS选择符 探索 JavaScript 定时器 JS设置定时器和清除定时器 JS30的第19个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/16/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91WebCam-Fun-19/"},{"title":"【原生javascript项目】Speech Detetion 20","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第20天的“语音检测”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/20%20speechDetection/index.html 项目描述本项目是一个语音识别系统，网页首先会向用户请求麦克风权限，允许后可识别出用户的speech（语言为每个英语en-US')，并显示在网页中。 本项目用到的语音识别系统是Web Speech API，只能在 Chrome浏览器上使用，而且功能也一直在完善中，因此，本项目只是提供一种语音识别系统的解决思路，以便参考。 项目重点 Web Speech API SpeechRecognition 接口 SpeechRecognition.interimResults SpeechRecognition.lang SpeechRecognition.start() new SpeechRecognition() result事件 e.results result.transcript e.results[0].isFinal p.textContent end事件 项目过程HTML部分只有一个div元素，可编辑contenteditable 1&lt;div class=&quot;words&quot; contenteditable&gt;&lt;/div&gt; JS部分JS的大致思路是： 添加Chrome support 定义语音识别实例 开启语音识别功能 监听result事件，实时获取捕获到的speech，并通过创建元素的方法显示到网页中 监听end事件，当语音捕获结束后，重新开启语音识别功能 Chrome support SpeechRecognition 接口只能在 Chrome浏览器上使用，，因此需要适配Chrome浏览器的对象以及未来其他浏览器也能使用的一些修正 1window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; 定义语音识别实例 1const recognition = new SpeechRecognition(); 创建一个p元素，后面可以讲识别到的语音放进去 123const p = document.createElement('p');const words = document.querySelector('.words');words.appendChild(p); 打开语音识别功能，监听result事件，实时获取捕获到的speech，并显示到网页中 1234567891011121314recognition.addEventListener('result',e =&gt; { const transcript = Array.from(e.results) .map(result =&gt; result[0]) .map(result =&gt; result.transcript) .join(''); p.textContent = transcript; // console.log(e.results[0].transcript) if (e.results[0].isFinal) { p = document.createElement('p'); words.appendChild(p); }});recognition.start(); // 打开语音功能 监听end事件，当语音捕获结束后，重新开启语音识别功能 1recognition.addEventListener('end', recognition.start); 项目补充Web Speech API 语音识别和语音输出主要的语音识别接口是SpeechRecognition 接口，只能在 Chrome浏览器上使用 SpeechRecognition 接口的一些属性： SpeechRecognition.interimResults：设置语音识别系统是否返回中间结果，还是最终结果 SpeechRecognition.lang: 设置语音识别系统的语言 innerText、textContent和innerHTML三者的区别innerText、textContent和innerHTML可以设置标签中的文本内容。 不同点 innerHTML可以将内容中的标签为标签，而其他两个则不行，只是纯文本 innerText，textContent获取的是该标签和该标签下子标签中的文本内容 12345678910111213141516171819202122232425&lt;div id=&quot;mylinks&quot;&gt; This is my &lt;b&gt;link collection&lt;/b&gt;: &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;www.borland.com&quot;&gt;Bye bye &lt;b&gt;Borland&lt;/b&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;www.microfocus.com&quot;&gt;Welcome to &lt;b&gt;Micro Focus&lt;/b&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; const dv = document.getElementById(&quot;mylinks&quot;); console.log(dv.textContent); // This is my link collection: // Bye bye Borland // Welcome to Micro Focus console.log(dv.innerText); // This is my link collection: // Bye bye Borland // Welcome to Micro Focus console.log(dv.innerHTML); // This is my &lt;b&gt;link collection&lt;/b&gt;: // &lt;ul&gt; // &lt;li&gt;&lt;a href=&quot;www.borland.com&quot;&gt;Bye bye &lt;b&gt;Borland&lt;/b&gt; &lt;/a&gt;&lt;/li&gt; // &lt;li&gt;&lt;a href=&quot;www.microfocus.com&quot;&gt;Welcome to &lt;b&gt;Micro Focus&lt;/b&gt;&lt;/a&gt;&lt;/li&gt; // &lt;/ul&gt; &lt;/script&gt; let var const区别var 声明会变量提升 let 块级作用域，声明不会变量提升 const 块级作用域声明的变量为常量，值不可修改 更多内容见参考博客[2-4] CSS position 值 relative 相对自己原来（正常文档流）的位置 absolute 脱离文档流，相对于最近的已定位父元素 fixed 脱离文档流，相对于浏览器窗口是固定位置 sticky 基于用户的滚动位置来定位。行为就像 relative，而当页面滚动超出目标区域时，它的表现就像 fixed，固定在目标位置。 static HTML 元素的默认值，即没有定位，遵循正常的文档流对象。 参考博客 innerText、textContent和innerHTML三者的区别 一看就懂的var、let、const三者区别 var、let和const的区别详解 块作用域 JS30的第20个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/22/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Speech-Detetion-20/"},{"title":"【原生javascript项目】Geolocation 21","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第21天的“地理位置”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/21%20geoLocation/index.html 项目描述本项目是一个可视化的指南，利用网络地址位置Web Geolocation API获取的地理位置和速度。 本项目的JS代码相对比较简单，但是由于电脑一般没有速度及方向传感器，所以实际的功能并没显示出来，只是提供了一种实现途径。 项目重点 Geolocation.watchPosition() API .coords.speed .coords.heading CSS radial-gradient background-attachment设置背景图是否固定不到 项目过程HTML部分 svg图片元素 h1元素 类名为speed-value span标签 类名为speed-unit span标签 CSS部分 设置背景图片 radial-gradient由圆心向外的径向的颜色渐变 1radial-gradient(rgba(255,255,255,.1) 15%, transparent 20%) 0 1px JS部分JS的大致思路是： 请求调用Geolocation接口 获取当前的地理位置信息data 显示速度信息 data.coords.speed 改变页面中指南针的朝向 data.coords.heading 具体代码如下： 12345678navigator.geolocation.watchPosition((data) =&gt; { console.log(data); speed.textContent = data.coords.speed; arrow.style.transform = `rotate(${data.coords.heading}deg)`;}, (err) =&gt; { console.error(err);}); 项目补充Geolocation接口 ：获取设备的地理位置信息方法 1：Geolocation.getCurrentPosition() 获取当前的位置信息 方法 2：Geolocation.watchPosition() 返回位置变化后的最新信息 方法 3：Geolocation.clearWatch() 删除使用watchPosition()后的句柄 JS30的第21个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/24/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Geolocation-21/"},{"title":"【原生javascript项目】Link Highlighter 22","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第22天的“链接高亮显示”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/22%20linkHighlighter/index.html 项目描述本项目页面主要有一个导航栏菜单和正文内容组成。页面实现的效果是：当鼠标进入a标签时，背景颜色以白色高亮显示，当鼠标移到下一个a标签时，白色高亮块上一个a标签中移动下来。 项目重点 Element.getBoundingClientRect() window.scrollY mouseenter事件 项目过程HTML部分 nav标签包裹的导航栏菜单 ul标签 5个li标签，为菜单内容 类名为wrapper的div标签包含了正文内容 链接用a标签标记，在JS中要实现高亮显示 CSS部分使用如下技巧将外边距和内边距重置为零 123*, *:before, *:after { box-sizing: inherit;} 高亮块的CSS样式，基本思路是加上绝对定位（相对于最近定位的父元素定位，在这里父元素是body），通过在JS中改变top和left以及width和height属性，来呈现不同链接选中的状态。 123456789101112.highlight{ transition: all 0.2s; border-bottom: 2px solid white; position: absolute; top: 0; background: white; left: 0; z-index: -1; border-radius: 20px; display: block; box-shadow: 0 0 10px rgba(0,0,0,0.2);} JS部分JS的大致思路是： 获取链接标签，以及创建span标签，用来添加highlight样式 1234const triggers = document.querySelectorAll('a');const highlight = document.createElement('span');highlight.classList.add('highlight');document.body.appendChild(highlight); 获取当前鼠标进入的链接元素的位置信息 修改类名为highlight的样式 给a标签添加鼠标进入mouseenter事件 获取链接标签，以及创建span标签，用来添加highlight样式 1234567891011121314function highlightter(){ const link = this.getBoundingClientRect(); console.log(link); const linkCoordinates ={ width:link.width, height:link.height, top:link.top+window.scrollY, left:link.left+window.scrollX }; highlight.style.width = `${linkCoordinates.width}px`; highlight.style.height = `${linkCoordinates.height}px`; highlight.style.transform = `translate(${linkCoordinates.left}px,${linkCoordinates.top}px)`;}triggers.forEach(a =&gt; a.addEventListener('mouseenter', highlightter)); 项目补充Element.getBoundingClientRect()返回一个DOMRect对象，包含了元素的大小、相对于视口的位置信息。 DOMRect相关只读属性 Attribute Description height 矩形盒子的高度 width 矩形盒子的宽度 top Y 轴，相对于视口原点（viewport origin）顶部 left X 轴，相对于视口原点左侧 bottom Y 轴，相对于视口原点底部 right X 轴，相对于视口原点右侧 x 盒子左上角位置的X轴横坐标 y 盒子左上角位置的Y轴横坐标 window.scrollY鼠标滑动的垂直距离 window.scrollX 鼠标滑动的水平距离 mousemove, mouseenter 和mouseover区别mousemove：鼠标指针进入div以及其子元素时触发； mouseenter：鼠标指针进入div时触发； mouseover：鼠标每次滑过div时触发 点击此链接体验三者的效果 👉 体验 JS30的第22个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/25/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Link-Highlighter-22/"},{"title":"【原生javascript项目】Speech Synthesis 23","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第23天的“语音合成”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/23%20speechSynthesis/index.html 项目描述利用SpeechSynthesisUtterance接口等实现的语音合成项目，其中设有rate和pitch滑块可改变朗读速度和音高，stop和speech按钮用来控制朗读的开始和暂停。朗读的文本内容可以在文本框中自行输入。 项目重点 SpeechSynthesisUtterance接口 speechSynthesisUtterance.lang SpeechSynthesisUtterance.pitch SpeechSynthesisUtterance.rate SpeechSynthesisUtterance.text ``SpeechSynthesisUtterance.name` SpeechSynthesis接口 voiceschanged事件 SpeechSynthesis.getVoices() speechSynthesis.cancel() SpeechSynthesis.speak() 项目过程HTML部分 h1标签 select多选菜单 123&lt;select name=&quot;voice&quot; id=&quot;voices&quot;&gt; &lt;option value=&quot;&quot;&gt;Select A Voice&lt;/option&gt;&lt;/select&gt; 两个范围input控件，用来调控rate和speed 1234&lt;label for=&quot;rate&quot;&gt;Rate:&lt;/label&gt;&lt;input name=&quot;rate&quot; type=&quot;range&quot; min = 0 max = &quot;3&quot; value=&quot;1&quot; step=&quot;0.1&quot;&gt;&lt;label for=&quot;pitch&quot;&gt;Rate:&lt;/label&gt;&lt;input name=&quot;pitch&quot; type=&quot;range&quot; min=&quot;0&quot; max=&quot;2&quot; step=&quot;0.1&quot;&gt; 输入文本框，朗读内容 1&lt;textarea name=&quot;text&quot;&gt;Hey, my name is Iaine, nice to meet you&lt;/textarea&gt; 两个按钮，用来暂停朗读和开始朗读 12&lt;button id=&quot;stop&quot;&gt;Stop&lt;/button&gt;&lt;button id=&quot;speak&quot;&gt;Speak&lt;/button&gt; JS部分JS的大致思路是： 使用相应WebAPI接口获得浏览器支持的语言种类列表，填充至下拉菜单中； 在文本域中输入对应语言的文字，点击speak按钮后浏览器会阅读输入的文字； 在浏览器阅读时，点击stop按钮，浏览器会停止阅读； 拖动rate和pitch滑块可改变阅读速度和音高。 取得speechSynthesis对象，获取浏览器支持朗读语言，将所有选项动态添加至下拉列表 1234567891011const speechSynthesis = window.speechSynthesis;let voices=[];function populateVoices(){ voices = this.getVoices(); voicesDropdown.innerHTML = voices .map(voice =&gt; `&lt;option value=&quot;${voice.name}&quot;&gt;${voice.name} (${voice.lang})&lt;/option&gt;`) .join(''); console.log(voices)} speechSynthesis.addEventListener('voiceschanged', populateVoices); 设置下拉列表当前显示的语言，选择好语言后触发朗读 12345678910111213const voicesDropdown = document.querySelector('[name = &quot;voice&quot;]');function setVoice(){ msg.voice = voices.find(voice =&gt; voice.name === this.value); toggle();}// 发出语音function toggle(startOver = true) { speechSynthesis.cancel(); if (startOver) { speechSynthesis.speak(msg); }}voicesDropdown.addEventListener('change', setVoice); 点击speech按钮朗读，stop按钮停止 1234const speakButton = document.querySelector('#speak');const stopButton = document.querySelector('#stop');speakButton.addEventListener('click', toggle);stopButton.addEventListener('click', () =&gt; toggle(false)); 构建SpeechSynthesisUtterance实例，添加pitch,text, speed,name属性 123456789101112const msg = new SpeechSynthesisUtterance();msg.text = document.querySelector('[name=&quot;text&quot;]').value;const options = document.querySelectorAll('[type=&quot;range&quot;],[type = &quot;text&quot;]');function setOption(){ msg[this.name] = this.value; toggle();}options.forEach(option =&gt; option.addEventListener('change', setOption));function updateText(){ msg.text = document.querySelector('[name=&quot;text&quot;]').value;}document.querySelector('[name=&quot;text&quot;]').addEventListener('change', updateText); 项目补充SpeechSynthesisUtterance接口属于 Web Speech API 的一个接口，可以发出speech请求。 构造器1SpeechSynthesisUtterance.SpeechSynthesisUtterance() 返回一个新的 SpeechSynthesisUtterance 实例对象。 属性 SpeechSynthesisUtterance.lang (en-US) 获取或设置朗读的语言 SpeechSynthesisUtterance.pitch (en-US) 获取或设置朗读的音调 SpeechSynthesisUtterance.rate (en-US) 获取或设置朗读的速率 SpeechSynthesisUtterance.text (en-US) 获取或设置朗读的文本内容 SpeechSynthesisUtterance.voice 获取或设置朗读的voice SpeechSynthesisUtterance.volume (en-US) 获取或设置朗读的音量 SpeechSynthesis 接口属于 Web Speech API 的一个控制speech服务的接口，可以返回设备合成声音的信息，开始或者暂停speech等。 只读属性SpeechSynthesis.paused ：SpeechSynthesis对象是否暂停状态 SpeechSynthesis.pending ： utterance queue 是都还有没有余留没有读的 utterance。 SpeechSynthesis.speaking：一个utterance是否在被读的阶段 方法 SpeechSynthesis.cancel() 移除utterance queue队列中所有的utterances SpeechSynthesis.getVoices() 返回现有设备所有可用的voices的 SpeechSynthesisVoice 对象 SpeechSynthesis.pause() 把 SpeechSynthesis 对象放在暂停状态 SpeechSynthesis.resume() 把 SpeechSynthesis 对象放在重新打开状态 SpeechSynthesis.speak() 在utterance queue队列中增加一个utterance 事件voiceschanged 在SpeechSynthesis.getVoices()方法返回的SpeechSynthesisVoice 对象变化的时候触发 注意：SpeechSynthesisUtterance接口和SpeechSynthesis接口的关系 二者都属于Web Speech API 接口 前者是设置朗读的配置参数，包括语言，速度，语调，内容等 后者是控制朗读的行为，包括获取浏览器支持的朗读语言，文本朗读，暂停，停止等 CSS知识补充 :nth-of-type()伪类选择器，匹配相同类型（也就是相同标签）的元素 和:nth-child区别在于后者不是同类。 calc()方法 允许计算 JS30的第23个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/25/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Speech-Synthesis-23/"},{"title":"【原生javascript项目】Sticky Nav 24","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第246天的“粘贴导航栏”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/24%20stickyNav/index.html 项目描述本项目主要亮点在于实现导航栏的位置粘贴固定，此外，当鼠标滚动导航栏（本来）消失时，除了要固定导航栏，还要加一点其他样式。 技术要点是通过scroll事件中，判断窗口位置和当前导航栏的位置，如果前者大于或等于后者，则通过添加一个类名'fixed-nav'（其样式事先在CSS中完善），来实现上述两亮点。 当前者小于后者，则移除'fixed-nav'类名。 项目重点 scroll事件 window.scrollY &gt;= topOfNav nav.offsetTop document.body.classList.add() document.body.classList.remove() position: fixed 项目过程HTML部分 header标题 nav导航栏菜单 .site-wrap正文 JS部分JS的大致思路是： 监听页面滚动事件 判断页面当前滚动位置，如果大于等于导航栏距离窗口顶部位置时，则通过添加类名 否则移除类名 该类名的样式在CSS中设置好，原理在于position设置为fix 12345678910111213const nav = document.querySelector('#main');let topOfNav = nav.offsetTop;function fixNav() { if (window.scrollY &gt;= topOfNav) { // document.body.style.paddingTop = nav.offsetHeight + 'px'; document.body.classList.add('fixed-nav'); } else { document.body.classList.remove('fixed-nav'); document.body.style.paddingTop = 0; }}window.addEventListener('scroll', fixNav); 项目补充text-align: justify均匀分布，有点像word软件的“两端对齐”。 JS30的第24个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/26/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Sticky-Nav-24/"},{"title":"【原生javascript项目】Event Capture 25","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第25天的“语音合成”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/25%20eventCapture/index.html 项目描述本项目主要目的是理解事件的捕获、传播、冒泡、单次触发等机制。首先提供3个尺寸颜色不一的&lt;div&gt;元素，通过点击事件来理解上述内容。 项目重点 capture once 项目过程JS部分 冒泡 当点击某个div时，自该div起以及其外层的div也将监听到点击事件。 例如，点击第3个div（最内层的），控制台显示的结果是three,two,one。 12345const divs = document.querySelectorAll('div');function textLog(){ console.log(this.classList.value);}divs.forEach(div=&gt;div.addEventListener('click',textLog)); 捕获 点击某个div时，从不具体的div元素到最具体的元素（被点击的元素）从上到下监听到点击事件。 例如，点击第3个div（最内层的），控制台显示的结果是one,two,three。 123divs.forEach(div=&gt;div.addEventListener('click',textLog,{ capture: true })); 停止事件继续传递 在冒泡的基础上，加上e.stopPropagation();来设置不再继续传播 1234567function textLog(e){ console.log(this.classList.value); e.stopPropagation();}divs.forEach(div=&gt;div.addEventListener('click',textLog,{ capture: false})); Once：允许事件触发一次，之后相当于removeEventListener。 1234567function textLog(e){ console.log(this.classList.value);}divs.forEach(div=&gt;div.addEventListener('click',textLog,{ capture: false, once:true})); 项目补充事件冒泡事件开始由最精确的元素触发，逐级向上传播到其他节点 事件捕获事件由不太具体的节点传播到最具体的节点 参考博客 事件流 JS30的第25个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/27/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Event-Capture-25/"},{"title":"【原生javascript项目】Strip follow along nav 26","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第26天的“内容悬浮显示”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/26%20stripAlongNav/index.html 项目描述本项目的网页主题是一个菜单栏，通过鼠标mouseenter进入每个菜单项目时，会显示出相应的隐藏扩展内容，当从一个菜单进入另一个菜单时，扩展内容的显示会有一个从上一个菜单平移到当前菜单的动态效果。 本项目的难点在于适应大小的动态显示和平移效果。由于扩展内容包含的类型各不相同，而且显示要有一个从上一个菜单平移到当前菜单的动态效果，要做到用通用化的操作，根据扩展内容的具体大小动态显示出，是一件值得思考的事情。 项目重点 getBoundingClientRect() 项目过程HTML部分 第一个菜单及其扩展内容 包含a标签标记的标题；类名为dropdown,dropdown1的下拉菜单（一张图片和描述文本） 123456789&lt;li&gt; &lt;a href=&quot;#&quot;&gt;About Me&lt;/a&gt; &lt;div class=&quot;dropdown dropdown1&quot;&gt; &lt;div class=&quot;bio&quot;&gt; &lt;img src=&quot;https://logo.clearbit.com/wesbos.com&quot;&gt; &lt;p&gt;Wes Bos sure does love web development. He teaches things like JavaScript, CSS and BBQ. Wait. BBQ isn't part of web development. It should be though!&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/li&gt; 第二个菜单及其扩展内容 包含a标签标记的标题；类名为dropdown,dropdown2的下拉菜单（类型相同的列表） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;li&gt; &lt;a href=&quot;#&quot;&gt;Courses&lt;/a&gt; &lt;ul class=&quot;dropdown courses&quot;&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;RFB&lt;/span&gt; &lt;a href=&quot;https://ReactForBeginners.com&quot;&gt;React For Beginners&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;ES6&lt;/span&gt; &lt;a href=&quot;https://ES6.io&quot;&gt;ES6 For Everyone&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;NODE&lt;/span&gt; &lt;a href=&quot;https://LearnNode.com&quot;&gt;Learn Node&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;STPU&lt;/span&gt; &lt;a href=&quot;https://SublimeTextBook.com&quot;&gt;Sublime Text Power User&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;WTF&lt;/span&gt; &lt;a href=&quot;http://Flexbox.io&quot;&gt;What The Flexbox?!&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;GRID&lt;/span&gt; &lt;a href=&quot;https://CSSGrid.io&quot;&gt;CSS Grid&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;LRX&lt;/span&gt; &lt;a href=&quot;http://LearnRedux.com&quot;&gt;Learn Redux&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;CLPU&lt;/span&gt; &lt;a href=&quot;http://CommandLinePowerUser.com&quot;&gt;Command Line Power User&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;span class=&quot;code&quot;&gt;MMD&lt;/span&gt; &lt;a href=&quot;http://MasteringMarkdown.com&quot;&gt;Mastering Markdown&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; 第三个菜单及其扩展内容 包含a标签标记的标题；类名为dropdown,dropdown3的下拉菜单（类型相同的列表） 123456789&lt;li&gt; &lt;a href=&quot;#&quot;&gt;Other Links&lt;/a&gt; &lt;ul class=&quot;dropdown dropdown3&quot;&gt; &lt;li&gt;&lt;a class=&quot;button&quot; href=&quot;http://twitter.com/wesbos&quot;&gt;Twitter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;button&quot; href=&quot;http://facebook.com/wesbos.developer&quot;&gt;Facebook&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;button&quot; href=&quot;http://wesbos.com&quot;&gt;Blog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=&quot;button&quot; href=&quot;http://wesbos.com/courses&quot;&gt;Course Catalog&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; 白背景 123&lt;div class=&quot;dropdownBackground&quot;&gt; &lt;span class=&quot;arrow&quot;&gt;&lt;/span&gt;&lt;/div&gt; CSS部分 trigger-enter类名。效果是显示下拉菜单，但是此时下拉菜单的不透明度还是为0，所以还是看不到下拉菜单 123.trigger-enter .dropdown { display: block;} trigger-enter-active类名。效果是将下拉菜单的不透明度设置为1 123.trigger-enter-active .dropdown { opacity: 1;} dropBackgorund类名。设置背景图片的样式，也是本项目难点的实现机制，通过移动背景白版，来实现一个动态平移的过程。 12345678910111213.dropdownBackground { width: 100px; height: 100px; position: absolute; background: #fff; border-radius: 4px; box-shadow: 0 50px 100px rgba(50,50,93,.1), 0 15px 35px rgba(50,50,93,.15), 0 5px 15px rgba(0,0,0,.1); transition: all 0.3s, opacity 0.1s, transform 0.2s; transform-origin: 50% 0; display: flex; justify-content: center; opacity: 0;} open类名。将背景图片的不透明度设置为1 123.dropdownBackground.open { opacity: 1;} JS部分 鼠标进入导航栏项目时。 给对应的项目添加类名trigger-enter，随后150ms，添加类名trigger-enter-active。 白背景也要同时显示，所以添加类名open 利用getBoundingClientRect()属性获取元素的宽高和位置信息。这是本项目的难点的实现机制，根据下拉菜单大小动态显示。 白背景的显示位置是相对于已定位的nav元素，所以其top位置是下拉菜单的top位置减去nav的top位置。 12345678910111213141516171819202122232425const triggers = document.querySelectorAll('.cool &gt; li');const background = document.querySelector('.dropdownBackground');const nav = document.querySelector('.top');function handleEnter() { this.classList.add('trigger-enter'); setTimeout(() =&gt; this.classList.contains('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 150); background.classList.add('open'); const dropdown = this.querySelector('.dropdown'); const dropdownCoords = dropdown.getBoundingClientRect(); const navCoords = nav.getBoundingClientRect(); const coords = { height: dropdownCoords.height, width: dropdownCoords.width, top: dropdownCoords.top - navCoords.top, left: dropdownCoords.left - navCoords.left }; background.style.setProperty('width', `${coords.width}px`); background.style.setProperty('height', `${coords.height}px`); background.style.setProperty('transform', `translate(${coords.left}px, ${coords.top}px)`);}triggers.forEach(trigger =&gt; trigger.addEventListener('mouseenter', handleEnter)); 鼠标移除导航栏菜单时。删除类名trigger-enter，trigger-enter-active，open。 12345function handleLeave() { this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open');}triggers.forEach(trigger =&gt; trigger.addEventListener('mouseleave', handleLeave)); 项目补充getBoundingClientRect()返回DOMRect对象，包含元素的大小和相对视口的位置信息。 1domRect = element.getBoundingClientRect(); will-change: opacity提醒浏览器该元素的opacity特性将会改变 A &gt; B匹配A的所有直接后代B JS30的第26个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/27/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Strip-follow-along-nav-26/"},{"title":"【原生javascript项目】Click and drag 27","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第26天的“内容悬浮显示”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/27%20clickAndDrag/index.html 项目描述本项目为一个横向条幅，实现的特效是鼠标点击实现横向拖拽。 项目重点 e.pageX .scrollLeft .offsetLeft e.preventDefault() 项目过程JS部分编程思路为 监听最外层items元素的mousedown事件，触发后添加active类名，此类名具有一定的CSS特效。记录此时的起点startX 以及 左边滚动的位置scrollLeft。 监听鼠标移动mousemove事件，给scrollLeft赋值，即可调整元素在水平方向滚动的位置。 鼠标离开mouseleave和不点击mouseup事件触发时，去掉active类名。 mousedown事件 123456slider.addEventListener('mousedown', (e) =&gt; {isDown = true;slider.classList.add('active');startX = e.pageX - slider.offsetLeft;scrollLeft = slider.scrollLeft;}); mousemove事件 12345678slider.addEventListener('mousemove', (e) =&gt; {if (!isDown) return; // stop the fn from runninge.preventDefault();const x = e.pageX - slider.offsetLeft;const walk = (x - startX) * 3;slider.scrollLeft = scrollLeft - walk;}); mouseleave和不点击mouseup事件 123456789slider.addEventListener('mouseleave', () =&gt; {isDown = false;slider.classList.remove('active');});slider.addEventListener('mouseup', () =&gt; {isDown = false;slider.classList.remove('active');}); 项目补充一些CSS样式 overflow属性：控制元素溢出时的特性，主要有一下几个值 visible 默认值，溢出也是可见的，没有被裁剪 hidden 溢出的内容被裁剪，并且看不到 scroll 溢出的内容被裁剪，但是可以添加滑块scrollbar看到溢出内容 auto 有点像scroll white-space空格处理 normal表示合并空格，多个相邻空格合并成一个空格 nowrap不换行，经常和overflow,text-overflow一起使用 pre保留空格不换行，有几个空格算几个空格显示 pre-wrap的作用是保留空格 user-select：禁止用户用鼠标在页面上选中文字、图片等，也就是，让页面内容不可选 JS30的第27个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/03/05/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Click-and-drag-27/"},{"title":"【原生javascript项目】Video Speed Controller 28","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第27天的“视频播放速度控制器”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/28%20VideoSpeedController/index.htm **本项目的笔记内容选自 大史不说话**，他本人是JS30社区里的知名参与者，他的全部笔记在这里。 本项目的笔记在这里。 挑战任务初始文档index-start.html中提供了一个视频播放区域（使用的是H5原生的控制器）以及一个表示播放速度的滑块区域，本次的编程任务需要实现的效果是当鼠标拖动滑块时，实时改变视频播放的速度。 实现效果[](https://github.com/soyaine/JavaScript30/blob/master/28 - Video Speed Controller/effect.png) 编程思路本次的编程任务难度系数较低，在右侧速度条上监听鼠标点击事件，调整滑块的高度来表示不同的填充百分比，即不同的播放速度，将速度赋值给video对象的playbackRate属性即可实时改变播放速度。难点在于高度的百分比转换。 过程指南本篇实现较为简单，不再分步骤讲解，示例代码如下： 1234567891011121314151617const speed = document.querySelector(&quot;.speed&quot;);const speedBar = speed.querySelector(&quot;.speed-bar&quot;);const video = document.querySelector(&quot;.flex&quot;);function changeSpeed(e) { const height = e.offsetY;//获取滑块的高度 const percentage = e.offsetY / speed.offsetHeight; const min = 0.5; const max = 5; //依据自定义播放速度范围和滑块高度百分比确定播放速率 const playbackRate = percentage * (max - min) + min; speedBar.style.height = Math.round(percentage*100) + '%'; speedBar.textContent = playbackRate.toFixed(2) + '×'; video.playbackRate = playbackRate;}speed.addEventListener('click',changeSpeed); JS30的第28个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Video-Speed-Controller-28/"},{"title":"【原生javascript项目】Countdown Timer 29","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第28天的“倒计时计时器”项目。Have fun with the website! ♪(^∇^*) 源代码：https://github.com/janice143/JavaScript30Program/tree/master/29%20CountdownTimer/index.htm **本项目的笔记内容选自 大史不说话**，他本人是JS30社区里的知名参与者，他的全部笔记在这里。 本项目的笔记在这里。 挑战任务初始文档index-start.html中提供了一个倒计时控制器，从html文档的结构可以看出，顶部的按钮可以用来增加倒计时时间，常用的时间间隔已将参数绑定在data-time属性上;display类用来显示计时的结果。本次编程挑战的任务是通过javascript代码基于当前时间生成一个倒计时，将结束时间和剩余时间分别显示在diaplay__time-left类标签和display__end-time类标签上。 实现效果[](https://github.com/soyaine/JavaScript30/blob/master/29 - Countdown Timer/effect.png) 编程思路监听按点击事件click来为倒计时增加时间，使用setInterval函数每秒执行判断函数，若倒计时事件到，则清除当前计时器，若时间未到，则计算并刷新页面上应该显示的时间。 过程指南1.定义变量及获取需要操作的DOM元素的引用。 12345678const endTime = document.querySelector(&quot;.display__end-time&quot;);const leftTime = document.querySelector(&quot;.display__time-left&quot;);const buttons = document.querySelectorAll(&quot;button&quot;);const date = new Date();var left = 0;//剩余时间var end = 0;//结束时间var timer;//interval计时器leftTime.innerHTML = left;//未操作时，剩余时间显示0 2.为button绑定点击事件，当按钮点击时执行对应的回调函数。 1234const arr = Array.from(buttons);arr.map(function(item){ item.addEventListener('click',clickAction);}); 3.监听表单的提交事件,注意表单的调用方式。 12345document.customForm.addEventListener('submit',function(e){ e.preventDefault(); updateTime(this.minutes.value*60); updateTimer();}); 4.点击后的回调函数中取得点击按钮传递的秒数，调用updateTime()函数更新页面显示结果，并调用updateTimer()来更新计时器相关动作. 12345678function clickAction(e){ let deltaTime; deltaTime = this.dataset.time;//取得data-time属性的值 updateTime(deltaTime); //点击后更新计时器 updateTimer();} 5.updateTime()函数用来更新和页面相关的显示信息。 123456 function updateTime(delta){ left = left + parseInt(delta,0); end = date.getTime() + left*1000; leftTime.innerHTML = left; endTime.innerHTML =new Date(end).toLocaleTimeString();} 6.updateTimer()函数用来执行和设定每秒检查计时器是否需要继续工作的逻辑判断。 1234567891011121314151617function updateTimer(){ //清除以前的timer,如果不清除，新生成的定时器会和以前的定时器叠加在一起，均会生效。 if(timer){ clearInterval(timer); } // 设置新的Timer timer = setInterval(function(){ if(left == 0){ endTime.innerHTML = 'End'; clearInterval(timer); }else{ left -= 1; leftTime.innerHTML = left; }},1000);} 延伸思考本次代码中前后会定义定时器和清除定时器，另一种做法是定时器一直工作不清除，对应的按钮和表单只修改时间，不用调整定时器，当值发生变化后，下一秒定时器检测时就会开始倒计时，这样代码逻辑上会有所简化，感兴趣的朋友可以自行练习。 JS30的第29个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Countdown-Timer-29/"},{"title":"【原生javascript项目】Whack A Mole 30","text":"","link":"/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Whack-A-Mole-30/"},{"title":"【原生javascript项目】JS30-总结","text":"作者：©iaineisalsoyan简介：Atypical frond-end developer. 非典型前端开发者。 完整指南在 GitHub，喜欢请 Star 哦♪(^∇^*) Have fun with the website! ♪(^∇^*) 项目简介30 Day Challenge是 Wes Bos 设计的一个 30 天原生JS编程挑战。 项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。目的是在不借助框架、库、编译器和引用的情况下，帮助初学者理解纯JavaScript语言。 项目内容 Drum kit（架子鼓模拟器） JS and CSS Clock （网页时钟） CSS Variables （CSS变量） Array Cardio Day1 （数组操作1） Flex Panel Gallery （Flex画廊面板） Type Ahead （异步输出） Array Cardio Day2 （数组操作2） Fun with HTML5 Canvas（有趣的HTML5画布） Dev Tools Domination （） Hold Shift and Check Checkboxes （计划清单） Custom Video Player （自定义视频播放器） Key Sequence Detection （字符串序列彩蛋检测） Slide in on Scroll （滚动鼠标滚轮滑动显示） JavaScript References VS Copying （引用与拷贝） Local Storage （本地存储） Mouse Move Shadow （随鼠标移动的文字阴影） Sort with Articles （去掉冠词排列） Adding up Times with Reduce （用Reduce实现时间累加器） Webcam Fun （有趣的网络摄像头） Speech Detection （语音识别） Geolocation （地理位置信息获取） Follow along Link Highlighter （链接高亮显示） Speech Synthesis （语音合成） Sticky Nav （固定的导航栏） Event Capture, Propagation, Bubbling and Once（事件捕捉，传播，冒泡与Once方法） Stripe Follow along Nav （导航栏跟随移动显示特效） Click and Drag （点击并拖拽） Video Speed Controller （视频速度控制器） Countdown Timer （倒计时计时器） Whack A Mole（打地鼠小游戏） 用VUE实现的JS30查看index-VUE.html文件 Drum kit（架子鼓模拟器） JS and CSS Clock （网页时钟） CSS Variables （CSS变量） Flex Panel Gallery （Flex画廊面板） Type Ahead （异步输出） Fun with HTML5 Canvas（有趣的HTML5画布） Hold Shift and Check Checkboxes （计划清单） Custom Video Player （自定义视频播放器） Whack A Mole（打地鼠小游戏） 社区内容#JavaScript30Feel free to submit a PR adding a link to your own recaps, guides or reviews! Arjun Khode’s blog about summaries for each day, including fixed glitches, bugs and extra features Nitish Dayal’s Text Guides are great for those who like reading over watching Meredith Underell’s Quick Lessons Learned Rowan Weismiller’s Recaps + Lessons Learned Thorsten Frommen shares how he solved the exercises before viewing the answers Soyaine 写的中文指南包含了过程记录和难点解释 Ayo Isaiah’s Recaps and Lessons Learned Adriana Rios shares her alternative solutions Michael Einsohn publishes each challenge after watching the video once Mike Ekkel Yusef Habib lessons and tricks learned, and a gh-page to see working all the mini-projects. Amelie Yeh 30 lessons notes with things I’ve learned, and those important recaps. and directly view my demos here 🇹🇼😄 Winar的JavaScript30天挑战，记录练习过程，重难点和其他的解决方案。🎨 Rayhatron - walkthroughs, recaps and lessons learned. Andrei Dobra Full repo with lessons learned and a gh-page with all the exercises. 从零到壹全栈部落,春哥发起的从零到壹全栈部落，旨在带领大家一起学习，一起输出，文档化，代码化，中文视频化，全栈部落口号：输出是最好的学习方式。 Usmaan Ali’s summary of the technical skills learned from each project. He’s also posting them as separate blog posts here Axel‘s lessons learned and a showcase with the projects. Chris 中文實戰，目標描述、過程紀錄。 Muhammad D. Ramadhan’s blog. He shamlesly mixed his personal life with 30 day JavaScript challenge so as to increase his learning retention. He also summarised the challenge on one single page. Do not read his blog! Lee Keitel’s Blog includes summaries of each lesson, what I learned from each one, and my thoughts about the topic taught and using them in the future. Dustin Hsiao 包含了各篇介紹、 效果Demo、各篇詳解及記錄過程，附上部分延伸閱讀及gh-page。 GuaHsu - 紀錄各篇練習過程與心得，並嘗試擴充部分練習，也做了一個包含全部練習的介紹站🇹🇼 Daniela‘s completed challenges on GitHub Pages and Codepen :raised_hands: :muscle: :+1: Dmitrii Pashutskii’s code of all challenges on GitHub with Pages and review blog posts Abid Hasan’s completion of all challenges. This was awesome!! Learned so much! :+1: Yusong Notes Records Yusong JS 30 days note and demo :star2: Ding’s Implementation code and online demo Herminio Torres lessons and tricks learned, and a gh-page to see working all the mini-projects. Dmytro Borysovskyi says many thanks to for the course to Wes 🤝 It was incredible challenge 👌 The full repository with code available here and demos can be reached by the link to gh-pages 👍👍👍 Kizito‘s follow along repo with completed challenges and notes. VannTile‘s repository and GitHub Pages showcase. Thank you for a great ⌨️ experience. Alex Kim completed all the challenges. You can check them out at github pages. Mikhail Thomas created JS30++ to add another level of challenge ontop of this already great course. Ramon Morcillo finished this awesome challenge!. You can see the showcase of his implementations on this link. Santiago Escobar‘s repository and GitHub Pages showcase. Harry Xie 紀錄 30 天的練習筆記在 此連結. Van Ribeiro’s about demos and recaps. On GitHub Repo there’s a summary about what was learned and researched. Mugilan is currently doing this challenge. Check out his Repo and the Live Demo. Eshan Vohra is currently doing this challenge. Check out my repo here. RegusAl is currently doing this challenge. Check out my repo here. Ayush Gupta’s implementation of JavaScript30 challenge with some add-ons &amp; updated design. filipkowal Fix to flex panels (5th day) so the panels deactivate when clicked on another one. Mo. Saif’snote on lessons learned and a gh-pages showcase for the projects. Stiaannel’s implementation of the Javascript30 challenge, with small design changes and a couple of extra features. 其他方法实现的JS30Here are some links of people who have done the tutorials, but in a different language or framework: Thomas Mattacchione JavaScript 30 written in ClojureScript Dave Follett’s blog series, A New Vue on #JavaScript30, where he explores re-implementing #JavaScript30 projects using Vue. Akinjide Bankole used Node.js with Jade to solve the exercises Adrien Poly a modest attempt to convert Drum Kit, Video Player, Local Tapas, TypeHead to Stimulus JS framework in a Rails App. Bogdan Lazar all the JavaScript 30 written in TypeScript Will Wager another TypeScript implementation! marcoSven solution suggestion for 10 - Hold Shift and Check Checkboxes ALMaclaine Javascript 30 written in Dart 2.0.","link":"/myblog.github.io/2022/03/12/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91JS30-%E6%80%BB%E7%BB%93/"},{"title":"【Github】配置连接github","text":"复制代码配置身份，不正确会影响贡献度统计 12git config --global user.email &quot;A175A174@gmail.com&quot;git config --global user.name &quot;A175A174&quot; 配置 ssh 链接，一路回车，打开提示目录下 id_rsa.pub复制到 https://github.com/settings/keys 点击 New sshKey，Title 可以不写 1ssh-keygen -t rsa -C &quot;A175A174@email.com&quot; 验证 ssh 是否成功Hi A175A174! You’ve successfully authenticated, but GitHub does not provide shell access 1ssh -T git@github.com","link":"/myblog.github.io/2021/08/20/%E3%80%90Github%E3%80%91%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5github/"},{"title":"【LeetCode】N 皇后问题","text":"问题描述N 皇后问题是指在 n * n 的棋盘上要摆 n 个皇后。 要求：任何两个皇后不同行，不同列也不在同一条斜线上，求给一个整数 n ，返回 n 皇后的摆法数。 例如12345输入：8返回值：92输入：4返回值：2 题解思路看懂此题解之前，需要会做 【BM55 没有重复项数字的全排列】。 如果BM55已经会做了，下面开始看本题解。 👇👇👇大概思路 n个皇后分别在1，2,3…n行的不同列处，列的下标用数组arr表示 要确定皇后的位置，其实就是确定列的位置，因为行已经固定了 进一步讲，也就是如何摆放 数组arr[0,1,2,3,…,n-1] 如果没有【不在同一条斜线上】要求，这题其实只是单纯的全排列问题，代码很容易些出来 但是对于【不在同一条斜线上】要求，全排列得到的res结果有些并不能用，比如说皇后的列位置不能这样排列：[0,1,2,3…,n-1] 所以现在问题变成了，在全排列的基础上，根据N皇后的问题，去除一些结果 下面开始声明一些变量 arr n个皇后的列位置 res n皇后排列结果 ruler 记录对应的列位置是否已经占用（也是是否有皇后），如果有，那么设为1，没有设为0 setPos 哈希集合，标记正斜线（从左上到右下）位置，如果在相同正斜线上，坐标(x,y)满足 y-x 都相同 setCon 哈希集合，标记反正斜线（从y右上到左下）位置，如果在相同反斜线上，坐标(x,y)满足 x+y 都相同 大致的代码思路如下所示 123456789101112131415arr = [0,1,2,3,...,n-1]res = []ruler = [n]setPos = new Set()setPos = new Set()backtrack(路径, arr): if 满足结束条件: result.add(路径) return for 选择 in 选择列表(arr): 做选择 backtrack(路径, arr) 撤销选择 return res.length 一些解释首先，N 个皇后肯定得在不同行，不同列处（由题意 “任何两个皇后不同行，不同列” 可知）。 要实现这个方案，其实思路和 BM55 全排列一样。把N个皇后的列坐标定义成数组arr = [0,1,2,...,n-1]。然后全排列该数组即可，得到的排列方式res的长度，就是排列方案的总数。 但是N皇后问题，还需要满足N 皇后不在同一条斜线上。这就更复杂了一点，需要对斜线位置进行判断。 怎么判断呢？ 如果setPos里不包含正斜线位置，setCon里不包含反斜线位置，那么就是我们要的【满足结束条件】。 在回溯函数里，我们先确定第0排皇后的列位置，然后回溯递归，确定第1排的皇后的列位置。 所以每次回溯，坐标(x,y)其实是(row,i) 最终的代码12345678910111213141516171819202122232425262728const arr= Array.from({length:n},(item, index)=&gt; index) // 列的位置let res = [];let ruler = new Array(n).fill(0);//用来记录num的皇后下落后，对角线位置，如果在对角线位置，那么为1，否则0let setPos = new Set();//标记正对角线let setCon = new Set();// 标记反对角线const backTrace = (row,path)=&gt;{ if(path.length === n){ res.push(path.slice()); return;} for(let i=0;i&lt;n;i++){ // i表示列 if(ruler[i] == 0 &amp;&amp; !setPos.has(i-row) &amp;&amp; !setCon.has(i + row)){ path.push(arr[i]); ruler[i] = 1 setPos.add(i - row) setCon.add(i + row) backTrace(row+1,path); path.pop(); ruler[i] = 0; setPos.delete(i - row) setCon.delete(i + row) } }}backTrace(0,[])return res.length;","link":"/myblog.github.io/2022/03/18/%E3%80%90LeetCode%E3%80%91N-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"},{"title":"【前端面试基础——HTML】图片懒加载 01","text":"作者：©Iaineisalsoyan 嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！ Have fun with the website! ♪(^∇^*) 什么是图片懒加载浏览网页的时候，滑动页面到能看到图片的时候再加载图片。 该功能实际可以拆分成两点： 判断图片出现在了当前视口（因为这个时候需要显示图片） 控制图片的加载 一些思考🤔 类似功能在JS30的项目里做过。参考【原生javascript项目】Slide in on scroll 13 我们现在回忆一下该项目的技术点。当时做该项目的时候，主要通过Scroll事件+位置计算实现了，另外加了函数防抖功能。其中位置计算主要包括屏幕高度（视口高度）、屏幕滚定位置、图片顶部距页面距离、图片半高、图片底部位置。 当屏幕滚动位置+屏幕高度之和 &gt; 图片顶部距页面距离+半高之和，移入图片；当屏幕滚动位置&lt;图片底部距离，移出图片。 window的scroll事件 window.addEventListener('scroll') 一些位置（像素值） window.scrollY 文档当前垂直滚动的像素数 window.innerHeight viewport部分的高度 sliderImage.offsetTop 当前元素顶部相对于其 offsetParent 元素的顶部的距离 debounce 的作用（函数防抖） 降低事件监听的频率，使用了 Lodash 中的 debounce 方法 解决方案🔖🔖🔖 速看在这里！！！ 判断图片出现在当前视口 scrollY, offsetTop,innerHeight+ Scroll事件 getBoundingClientRect API + Scroll事件 控制图片的加载 DataSet API 一步到位的方法 IntersectionObserver API 1 判断图片出现在当前视口 位置计算 + Scroll事件 这里出现的意思可以特指能看到图片一半的高度。 1234const slideInAt = (window.scrollY + window.innerHeight);const imageBottom = sliderImage.offsetTop + sliderImage.height;const isHalfShown = slideInAt &gt; (sliderImage.offsetTop + sliderImage.height / 2);const isNotScrolledPast = window.scrollY &lt; imageBottom; 知识点：scrollY, offsetTop,innerHeight getBoundingClientRect API + Scroll事件 该方法返回元素的大小及其相对于视口的位置。有top,left,bottom,right等属性。 1img.getBoundingClientRect().top &lt; document.documentElement.clientHeight; // 视口高度 the document.documentElement property gives you the html element, while the document.body property gives you the body element. 2 控制图片的加载 DataSet API 1&lt;img data-src=&quot;shanyue.jpg&quot; /&gt; 首先设置一个临时 Data 属性 data-src，控制加载时使用 src 代替 data-src，可利用 DataSet API 实现 1img.src = img.datset.src 3 一步到位的方法 IntersectionObserver API 异步监听元素是否到了当前视口或者其他元素 一个能够监听元素是否到了当前视口的事件，一步到位 12345678910111213const observer = new IntersectionObserver((changes) =&gt; { // changes: 目标元素集合 changes.forEach((change) =&gt; { // intersectionRatio if (change.isIntersecting) { const img = change.target; img.src = img.dataset.src; observer.unobserve(img); } });});observer.observe(img); LazyLoading 属性 1&lt;img src=&quot;shanyue.jpg&quot; loading=&quot;lazy&quot; /&gt; 不过目前浏览器兼容性不太好。 4 其他优化 window.scroll 事件可以加防抖节流。一般使用 lodash.throttle 。 1_.throttle(func, [(wait = 0)], [(options = {})]);","link":"/myblog.github.io/2022/03/24/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94HTML%E3%80%91%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD-01/"},{"title":"【前端面试基础--HTML】行内元素 05","text":"作者：©Iaineisalsoyan 嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！哦，对了，本系列的学习来源是 山月大佬的博客，他非常用心得整理了一份大厂面试题的项目，推荐大家去看看！ Have fun with the website! ♪(^∇^*) HTML 常见的行内元素标签 a img picture：包含零或多个 source 元素和一个 img 元素来为不同的显示/设备场景提供图像版本 span input textarea select label HTML 中有哪些语义化标签 header footer main aside article section address summary/details menu h1/h2/h3/h4/h5/h6 img p strong/italic","link":"/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-05/"},{"title":"【前端面试基础--HTML】一键复制功能 02","text":"作者：©Iaineisalsoyan 嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！哦，对了，本系列的学习来源是 山月大佬的博客，他非常用心得整理了一份大厂面试题的项目，推荐大家去看看！ Have fun with the website! ♪(^∇^*) 一键复制功能描述在一些博客网站中，可以看到代码区域的右上角会有一个复制的按钮，点击之后，可以迅速将代码框中的代码复制到剪切板上。 解决方案1Clipboard API1navigator.clipboard.writeText(text); 2 选中+复制对于不支持 Clipboard API 的浏览器，使用选中+复制的API进行复制。 选中 Selection API+Range API 12345678910const selection = window.getSelection();const range = document.createRange();// RangeAPI: 制造区域range.selectNodeContents(element);// Selection: 选中区域selection.addRange(range);selectedText = selection.toString(); 复制: execCommand 1document.execCommand(&quot;copy&quot;);","link":"/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91%E4%B8%80%E9%94%AE%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD-02/"},{"title":"【前端面试基础--HTML】Data Url 03","text":"作者：©Iaineisalsoyan 嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！哦，对了，本系列的学习来源是 山月大佬的博客，他非常用心得整理了一份大厂面试题的项目，推荐大家去看看！ Have fun with the website! ♪(^∇^*) 什么是Data URL?Data URL 是将图片转换为 base64 直接嵌入到了网页中，使用&lt;img src=&quot;data:[MIME type];base64&quot;/&gt;这种方式引用图片，不需要再发请求获取图片 缺点 base64 编码后的图片会比原来的体积大三分之一左右。 Data URL 形式的图片不会缓存下来，每次访问页面都要被下载一次。可以将 Data URL 写入到 CSS 文件中随着 CSS 被缓存下来。","link":"/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91Data-Url-03/"},{"title":"【前端面试基础--HTML】 实体编码 04","text":"作者：©Iaineisalsoyan 嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！哦，对了，本系列的学习来源是 山月大佬的博客，他非常用心得整理了一份大厂面试题的项目，推荐大家去看看！ Have fun with the website! ♪(^∇^*) 什么是 HTML 的实体编码 (HTML Entity Encode)一段以连字号（&amp;）开头、以分号（;）结尾的字符串。用以显示不可见字符及保留字符 (如 HTML 标签)。 例如： 不可分的空格:＆nbsp; &lt;(小于符号):＆lt; &gt;(大于符号):＆gt; ＆(与符号):＆amp; ″(双引号):＆quot; ‘(单引号):’＆apos;","link":"/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91-%E5%AE%9E%E4%BD%93%E7%BC%96%E7%A0%81-04/"},{"title":"【前端面试基础-CSS】CSS变量 03","text":"CSS variable，它解决了哪些问题1 减少样式重复定义比如同一个颜色值要在多个地方重复使用 1234567891011:root{ --bgcolor: blue; --color: red;}p { color: var(--color);}div { backgroung-color: var(--bgcolor); color: var(--color)} 2 媒体查询在媒体查询中使用，精简代码，减少冗余 1234567891011.box { --base-size: 10; width: calc(var(--base-size)* 10px); height: clac(var(--base-size)* 5px); padding:calc(var(--base-size) * 1px);}@media screen and (min-width: 1480px) { .box{ --base-size: 8; }} 3 方便在 JS 中使用123456// 设置变量document.getElementById(&quot;box&quot;).style.setPropertyValue('--color', 'pink')// 读取变量doucment.getElementById('box').style.getPropertyValue('--color').trim() //pink// 删除变量document.getElementById('box').style.removeProperty('--color') 4 其他 可以减少 JavaScript 对 DOM 的介入，制作性能更高的动画 配合 content 等通过 CSS 给 JS 传参，得到一些通过 JavaScript 难以获取的参数","link":"/myblog.github.io/2022/03/26/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-CSS%E3%80%91CSS%E5%8F%98%E9%87%8F-03/"},{"title":"【前端面试基础-CSS】左侧固定右侧自适应 02","text":"css 如何实现左侧固定宽度 300px，右侧自适应的布局初始元素如下： 1234&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt; 解决方案1 flex布局123456789.container{ display:flex; } .left{ width:300px;} .main{ flex:1; } 123456789.container { display: flex;}.left { flex: 0 0 300px;}.main { flex: 1 1;} 123456789101112.container { display: flex;}.left { flex-basis: 300px; flex-shrink: 0;}.main { flex-grow: 1;} 2 Grid 布局1234.container { display: grid; grid-template-columns: 300px 1fr;} 3 calc 方法123456.left { width:300px;}.main { width: calc(100% - 300px)}","link":"/myblog.github.io/2022/03/26/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-CSS%E3%80%91%E5%B7%A6%E4%BE%A7%E5%9B%BA%E5%AE%9A%E5%8F%B3%E4%BE%A7%E8%87%AA%E9%80%82%E5%BA%94-02/"},{"title":"【前端面试基础-CSS】Styled component 04","text":"styled-components📖📖📖 官方文档 📖📖📖 其他文档 模板字符串和CSS语法，生成的样式化组件，用来给React的组件定义样式的。 最为流行的 CSS-in-JS 方案","link":"/myblog.github.io/2022/04/04/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-CSS%E3%80%91Styled-component-04/"},{"title":"【Javascript】闭包浅理解","text":"什么是闭包closure先看下面这段代码： 12345var name = 'Joey'function printName(){ console.log(name)}printName(); // Joey 这段代码最终会打印出Joey这个名字，这是JS语言的独特之处，就是函数内部可以读取到外部的变量。 在这段代码中，具有两个作用域scope，一个是整段代码处于一个作用域，另一个是function函数里面有一个作用域。函数内部可以访问到外部的变量name。 其实这个printName函数就是一个闭包。闭包就是能够访问其他函数内部变量的函数。但是这个闭包并不是我们经常说的闭包。在理解现在的闭包的概念之前，我们再看一段代码： 123456var name = 'Joey'function printName(){ var age = 12; console.log(name)}console.log(age) // 报错 这段代码会报错，原因是因为在函数外部自然无法读取函数内的变量。 那如何在函数外部访问到函数内部的变量呢？在函数内部在定义一个函数，然后返回该函数 1234567891011var name = 'Joey'function printName(){ var age = 12; function printAge(){ console.log(age) } return printAge;}let age = printName();age(); // 12 在这段代码中，因为函数内部可以访问到外部的变量，所以printAge函数可以访问到外部的age变量。因此，只要 return printAge就可以在外部最外部的作用域中访问到age这个变量。 这段代码中printAge函数就是一个闭包，这也是我们现在认为的闭包。 闭包的概念闭包就是能够读取其他函数内部变量的函数，简答来讲就是，闭包就是函数内部的函数。 闭包的作用 读取函数内部的变量 让函数内部的变量保存在内存中。函数内部的变量为局部变量，闭包的作用，就是把函数的内部的局部变量变成了全局变量。","link":"/myblog.github.io/2022/04/12/%E3%80%90Javascript%E3%80%91%E9%97%AD%E5%8C%85%E6%B5%85%E7%90%86%E8%A7%A3/"},{"title":"【JavaScript】apply,call,bind区别","text":"三者的用法12345678910obj = { name:'Joey', age:12,}function printObj(name1,name2,name3){ console.log(this.name,name1,name2,name3)}printObj.call(obj,'Tom','Ben','Jack')printObj.apply(obj,['Tom','Ben','Jack'])printObj.bind(obj)('Tom','Ben','Jack') call, apply, bind都是函数的原型函数，任何函数都有这三个方法。 在上述代码中，call、apply和bind方法都将this指向了obj对象。 call和apply的区别12fun.call(thisArg,arg1,age2,...)fun.apply(thisArg,[argsArray]) 参数thisArg ：在fun函数运行时指定的this值。 **arg1,age2,…**： 指定的参数列表。 argsArray：可选。一个数组或者类数组对象，其中的数组元素将作为单独的的参数传给fun函数。 所以call和apply的唯一区别在于第二个参数，前者是参数列表，后者是一个数组或者类数组 bindbind方法返回的是一个函数。和call相似，传入的第二个参数是一个参数列表。 apply、call、bind总结：apply、call、bind 三者都是用来改变函数this对象的指向。 apply、call、bind 三者第一个参数都是this要指向的对象，也就是指定的上下文。 apply、call、bind 三者都可以利用后续参数传参。 bind是返回对应的函数，便于稍后调用。 apply、call 则是立即调用。 面试题： js 中如何实现 bind问题描述：编写一个fakeBind函数，实现功能和bind一样。 123456function f(b) { console.log(this.a, b);}//=&gt; 3, 4f.fakeBind({ a: 3 })(4); 解决： 12345Function.prototype.fakeBind(obj,...args){ return (...rest)=&gt;{ this.call(obj,...args,...rest) }} 📖📖📖 参考博客在网上查找资料的时候，觉得这篇博客不错，特地小抄了一下。","link":"/myblog.github.io/2022/04/13/%E3%80%90JavaScript%E3%80%91apply-call-bind%E5%8C%BA%E5%88%AB/"},{"title":"【NodeJS】第一个node.js web服务器","text":"1 📖📖📖 Node.js文档：官方文档：https://nodejs.org/dist/latest-v14.x/docs/api/synopsis.html 官方文档对于初学者不太友好，有点难度，所以我又在网上其他文档看，比如下面这个 👇👇👇 Node.js 入门指南 菜鸟教程 2 第一个node.js代码：app.js12345678910111213const http = require('http');const port = 3000;const server = http.createServer(function(req,res){ res.write('Hello Node') res.end()})server.listen(port,function(error){ if(error){ console.log('Something went wrong') }else{ console.log('Server is listening on port') }}) 这个代码是基本结构。写好之后，在终端输入 node app.js，然后在浏览器里输入localhost:3000即可打开。 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 3 在node.js里引入html文件如果提前编写好了一个html文件，想要在web服务器打开，可以写一个app.js，然后用node.js编译。 在app.js中需要引入fs内置模块。 123456789101112131415161718192021222324252627const http = require('http');const fs = require('fs');const port = 3000;const server = http.createServer(function(req,res){ // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain res.writeHead(200,{'Content-Type':'text/html'}) fs.readFile('index.html',function(error,data){ if(error){ res.writeHead(404) res.write('Error: File not found') }else{ res.write(data) } res.end() })})server.listen(port,function(error){ if(error){ console.log('Something went wrong') }else{ console.log('Server is listening on port') }}) 3 新式的写法——使用express框架先用npm下载express的包 1npm install express --save 然后编写下面的代码就可以了 12345678910const express = require('express');const app = express();app.get('/', (req, res) =&gt; { res.send('Hello World!');});app.listen(3000, () =&gt; { console.log('示例应用正在监听 3000 端口!');}); 好了，到这你就学会了使用Node.js实现一个web服务器！","link":"/myblog.github.io/2022/04/14/%E3%80%90NodeJS%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AAnode-js-web%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"【ejs模板引擎】第一次用ejs","text":"1 ejs是什么一套简单的模板语言，可利用普通的 JavaScript 代码生成 HTML 页面 📖📖📖 ejs.js文档官方文档：https://ejs.bootcss.com/#install 2 入门1 在浏览器 JS 环境中如何使用1.1 下载到ejs的js文件 2.2 新建html文件，html内容如下 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id =&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;ejs.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; let people = ['geddy', 'neil', 'alex'], html = ejs.render('&lt;%= people.join(&quot;, &quot;); %&gt;', {people: people});/* 将写好的ejs进行渲染 */ document.getElementById('app').innerHTML = html;&lt;/script&gt;&lt;/html&gt; 说明：需要引入ejs的js文件， ejs.render会返回一个字符串，将字符串挂载到页面中即可显示出来。 ejs.render的语法是ejs.render(str, data, options);str是一个模板字符串，data是模板字符串里面需要用到的数据。 首先需要用npm安装ejs 1npm install ejs","link":"/myblog.github.io/2022/04/15/%E3%80%90ejs%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E3%80%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%A8ejs/"},{"title":"【NodeJS】node小项目——购物车","text":"项目描述项目提供了初始的前端代码（放在public文件夹中），现在需要利用node.js来实现项目的后端部分。 项目初始化1 npm初始化会生成一个package.json文件。 1npm init npm是包管理工具，下载node的时候回顺带下载到npm。更多想了解的可以参考文档：菜鸟教程 2 项目所需库2.1 介绍这个项目需要用到express,ejs,stripe以及dotenv 四个库。先大致说一下这几个库的用途。 express是用来创建服务器，以及接收请求和响应请求等； 📖📖📖 官方文档：https://www.expressjs.com.cn/guide/routing.html ejs是用一套模板引擎（或者叫模板语言），因为本项目需要陈列一些商品信息，这些信息我们用一个json文件管理，然后需要动态渲染出来，这时候就用到了ejs语言。 📖📖📖 官方文档：https://ejs.bootcss.com/ stripe是stripe(一个支付服务平台，有点像国内的阿里)的一个线上支付工具包，另外stripe还提供了一些线上支付的接口，需要注册使用，才能获取到私密钥和公共密钥。 📖📖📖 官方文档：https://stripe.com/docs/payments?payments=popular dotenv用来管理环境变量的，stripe提供的接口中申请的私人密钥和公共密钥，其中私人密钥不能出现在生产环境中，只用来测试的时候用，所以需要管理我们的环境变量，让有些模块不会出现的生产环境中。 2.2 安装1npm install express ejs stripe dotenv --save 注意：加上save会将该依赖存入到package.json 里的dependcies里，不加则不会。 下载 dotenv (只在开发的时候下载来用，生产环境下是不需要的) 1npm install dotenv -save-dev 有些模块只是在本地开发的时候用到，这些模块会在devDependencies，在生产环境这些模块不会被打入包内。 在下载包的时候加上 --also=dev可配置。 项目过程本项目的大致思路是： 新建server.js文件，利用express搭建 web 服务器 利用git clone下载初始文件，将初始文件里的public/fonts文件夹移动那当前项目文件夹中，然后删除多余初始文件，将fonts文件夹重命名为public 提供的初始文件是一个静态网页+少量的js交互。利用app.use(express.static('public'))可查看 当你点击导航栏的STORE，可以浏览商品页面，点击商品加入购物车，然后点击购买，会alert出“成功购买”的信息。这些是初始文件在js中设计好的，我们项目的就是搭建服务器，将商品信息动态地渲染到页面中。选择商品加入购物车后，在点击购买的时候，调用stripe的接口完成线上支付。 新建items.json文件，根据页面的商品信息，做一个简单的商品数据库，以便后期加入其他商品 新建views文件夹，把初始文件store.html移动到该文件夹中，然后把该文件后缀名改为.ejs 利用ejs的语法在.ejs文件中修改对应的商品内容 在server.js文件中编写代码，将ejs文件渲染出来 注册stripe 官网的账号，在开发者测试中拿到密钥 新建.env文件，文件名为.env，开始配置环境变量，一个是公钥，一个是密钥（密钥是敏感信息，决不能外露，不然会被随意消费） 新建.gitignore文件，把环境配置文件.env写入里面，这样代码打包的时候就不会把环境配置这个文件打包 在server.js引入.env中的公钥和密钥 把公钥通过ejs文件传给store.js文件，下面我们开始修改store.js文件上的点击支付按钮的交互 在ejs文件中引入stripe的js文件（浏览器版本） 在store.js设置stripe的处理器 在server.js中设计app.post，发出支付请求 expressJS 网络服务器框架1 基本使用1234567const express = require('express')const app = express()// respond with &quot;hello world&quot; when a GET request is made to the homepageapp.get('/', function (req, res) { res.send('hello world')})app.listen(3000) 编写完这段代码，然后在浏览器上输入localhost:3000，就可以看到页面上显示hello world字样。这说明我们成功搭建了一个node.js服务器。 .env https://juejin.cn/post/6844904153890684935 .gitignore https://blog.csdn.net/beiniao520/article/details/79500647 过程页面的跳转恰好用的是res.render的方式，搭配上ejs模板引擎实现了页面的渲染。Node Express框架中EJS模板引擎的使用https://blog.csdn.net/weixin_41162427/article/details/107864130","link":"/myblog.github.io/2022/04/14/%E3%80%90NodeJS%E3%80%91node%E5%B0%8F%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E8%B4%AD%E7%89%A9%E8%BD%A6/"},{"title":"【nodejs】基于EJS+Node.js+MongoDB的全栈电商平台（全英文）","text":"基于EJS+Node.js+MongoDB的全栈电商平台（全英文）Full stack ecommerce online store application 后台管理账号 用户名：admin 密码：123456 项目介绍本项目为基于EJS+Node.js+MongoDB技术实现的全栈电商平台，用户可以在平台上浏览，搜索所需商品，商家可以在后台上传商品信息并实时发布到平台，供用户进行购买，数据库会实时向用户展示平台上的各种商品。 本项目是前后端分离开发，前后端功能需求完全独立，数据上相互依靠。前端包括以下几点的核心功能模块：1）商品列表展示模块；2）商品详情模块；3）商品分类展示模块；4）登录模块；5）注册模块；6）购物车模块；7）网站主页菜单栏编辑、添加、删除模块；8）商品类别编辑、添加、删除模块；9）商品信息编辑、添加、删除模块。 后端主要实现的功能为：1）按类名查询商品列表功能；2）用户登录和注册功能；3）对购物车相应数据的增加、删除、更新和清空功能；4）订单支付功能；5）对商品类别的数据增加、编辑、删除功能；6）对商品的数据增加、编辑、删除功能；7）对网站主页菜单栏的数据增加、编辑、删除功能 本项目采用的技术是： 前端：bootstrap, ejs 后端：node.js, express, express-router, stripe, mongodb, mongoose, express-validator, dropzone, passport 项目功能界面 系统设计1 功能模块分析前端采用bootstrap框架来实现页面的快速响应式布局记忆快速搭建。同时使用了EJS这类高效的嵌入式 JavaScript 模板引擎，用来实现动态的数据渲染。后端基于Nodejs 的Express 服务架构，使用非关系型数据库MongoDB 数据支持。整个系统使用流行的MVC 框架结构，实现了表现层、逻辑层和数据层的分离。系统完成之后，可以为买家用户提供商品浏览购买等服务，为卖家提供商品以及商品类别的增添、删除和编辑等功能。 （1）商品列表展示模块：实现商品列表的整体布局和组件拆分，根据服务器响应的数据，以及EJS模板引擎实现动态地渲染页面。 （2）商品分类展示模块：使用mongoose的数据库查找功能，按照商品类别（category），查找对应的商品，并把数据给页面进行展示。 （3）登录模块：主要实现网站的登录，和用户校验功能，当用户未进行登录时不可以对购买商品进行加入购物车操作，只能进行商品的查看，在后台中添加请求拦截可以实现此功能。用户登录后可以实现加入购物车以及购买商品等一系列操作。 （4）注册模块：主要实现网站账号的注册，注册过程中有些文本框需要满足一定的要求，比如用户名，名字等不能为空，利用express-validator来实现校验。 （5）购物车模块：把商品加入购物车后回显示商品的数目，购物车结算页面中可以进行商品的增加、减少，清除功能。最后还包括对整个购物车的一键清除，以及支付功能。其中支付功能采用了stripe的接口，可以利用stripe的卡号来进行实际的支付功能。 88888888—除了上述列出的一系列重要模块之外，本系统还利用—88888888888 2 数据库设计采用MongoDB数据库，这种非关系型数据库拥有以json格式进行数据传输与存储，没有烦琐的业务关系的处理，并且与node.js兼容性非常的良好。采用MongoDB 数据库中自带的Mongoose 类库作为中间件解决数据集合中数据操作问题，并且使用MongoDBCompass图形化管理数据。 本系统准备了四张表，名字分别为category（存储商品类名信息），page（存储主页导航栏信息），product（存储商品信息），user（存储用户信息）。 3 前端路由 项目开发详解项目初始化 1 npm init 2 新建server.js文件 3 安装express包 npm i –save express。在server.js文件中编写下述代码 12345678const express = require('express')const app = express()app.get('/', function (req, res) { res.send('Hello World')})app.listen(3000) 4 在控制台中输入命令 node server.js .一个nodejs服务器就启动了 访问: http://localhost:3000 项目源码目录设计1234567config 文件夹 配置mongodb服务器、用户登录的passport等models 文件夹 mongoose的数据模型public 文件夹 放一些静态的css,js以及图片等，产品图片也会通过建立文件夹的形式存储在本文件夹中routes 文件夹 存放路由views 文件夹 视图层，用来渲染数据.env 文件 环境变量配置，用来存放一些重要、敏感的信息，比如密钥等 项目用到的库和插件123456789101112131415161718192021222324252627282930313233343536373839express node.js Web应用框架, 提供各种特性和丰富的 HTTP 工具实现各种 Web 应用的创建。可以快速地搭建一个完整功能的网站。ejs JS模板引擎，模板文件后缀.ejs，&lt;% 内容 %&gt;。语法简单，上手容易body-parser 一般用到express框架都需要用这个中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。通俗地讲，用了body-parser中间件之后，我们的请求对象中就多了一个body属性，可以通过req.body显示出传入参数。(可以参考这篇博客 https://segmentfault.com/a/1190000041169686)express-session 服务器储存。在本项目中用来存储用户购物车一类的数据express-validator 表单验证器express-messages 提供Flash 通知渲染express-fileupload 接受从客户端传来的图片，并将图片作为文件存储在服务端fs-extra 文件操作，fs的一个扩展，提供了非常多的便利API，并且继承了fs所有方法和为fs方法添加了promise的支持mkdirp 不仅可以创建文件夹，还可以创建多层的文件夹connect-flash flash通知Mongoose 在 nodeJs 异步环境下对 mongodb 进行便捷操作的对象模型工具。bcryptjs 密码加密以及解密匹配passport 登录验证（身份认证的一种），功能单一，只能做登录验证，但非常强大，支持本地账号验证和第三方账号登录验证（OAuth和OpenID等），支持大多数Web网站和服务passport-local passport的依赖包，本地认证，本地身份验证resize-img 调整图片大小，比如说奥村图片的时候，重新调大小sortablejs JavaScript 拖拽库。可用于列表拖拽排序、以及低代码拖拽配置等场景stripe 支付接口bootstrap 基于HTML、CSS、JavaScript的前端框架,响应式前端布局dropzone 文件拖拽上传功能fileupload 实现图片上传viewerjs 大图预览（https://github.com/fengyuanchen/viewerjs） Express Messages的基本使用作用：提供flash通知的渲染 12345678app.use(require('connect-flash')());app.use(function (req, res, next) { res.locals.messages = require('express-messages')(req, res); next();});req.flash(&quot;info&quot;, &quot;Email queued&quot;);req.flash(&quot;info&quot;, &quot;Email sent&quot;);req.flash(&quot;error&quot;, &quot;Email delivery failed&quot;); 渲染messages, 根据所使用的的模板引擎执行messages函数。 12EJS:&lt;%- messages() %&gt; Connect Flash的基本使用flash是配合session使用的，所以在使用flash之前，要引入express-session模块，它往往用在登录和注册，消息只会通知一次就消失了，其中redirect和flash是不能分开使用的。 With the flash middleware in place, all requests will have a req.flash() function that can be used for flash messages. 12345678910app.get('/flash', function(req, res){ // Set a flash message by passing the key, followed by the value, to req.flash(). req.flash('info', 'Flash is back!') res.redirect('/');});app.get('/', function(req, res){ // Get an array of flash messages by passing the key to req.flash() res.render('index', { messages: req.flash('info') });}); Mongoose基本使用本部分内容主要参考了这篇博客，因为这篇文章写得很详细，想看更多细节，可以点击链接 1 引入 mongoose 并连接数据库12345const mongoose = require('mongoose');mongoose.connect('mongodb://localhost/test'); 如果有账户密码需要采用下面的连接方式： mongoose.connect('mongodb://eggadmin:123456@localhost:27017/eggcms'); 复制代码 2 定义 Schema数据库中的 Schema，为数据库对象的集合。schema 是 mongoose 里会用到的一种数据模式， 可以理解为表结构的定义；每个 schema 会映射到 mongodb 中的一个 collection，它不具备 操作数据库的能力 12345678910111213141516const PageSchema = new mongoose.Schema({ title:{ type:String, required:true }, slug:{ type:String, }, content:{ type:String, required:true }, sorting:{ type:Number, }, }); 3 创建数据模型定义好了 Schema，接下就是生成 Model。model 是由 schema 生成的模型，可以对数据库的 操作。 1const Page = mongoose.model('page', PageSchema); 注意： mongoose.model 里面可以传入两个参数也可以传入三个参数 mongoose.model（参数 1:模型名称，参数 2:Schema） mongoose.model（参数 1:模型名称，参数 2:Schema，参数 3:数据库集合名称） 如果传入 2 个参数的话，这个模型会和模型名称相同的复数的数据库建立连接：如通过下面 方法创建模型，那么这个模型将会操作 users 这个集合。 4 查找数据12345678UserModel.find({}, function(err, docs) { if (err) { console.log(err); return; } console.log(docs);}); 5 增加数据12345678//实例化模型 传入增加的数据var u = new UserModel({ name: &quot;lisi2222&quot;, age: 20, status: true});u.save();复制代码 6 修改数据12345678UserModel.updateOne({ name: &quot;lisi2222&quot; }, { name: &quot;哈哈哈&quot; }, function(err, res) { if (err) { console.log(err); return; } console.log(&quot;成功&quot;);});复制代码 7 删除数据12345678UserModel.deleteOne({ _id: &quot;5b72ada84e284f0acc8d318a&quot; }, function(err) { if (err) { console.log(err); return; } //只会删除一条 console.log(&quot;成功&quot;);}); bcryptjs基本使用bcryptjs 是nodejs中比较好的一款加盐(salt)加密的包, 我们处理密码加密、校验要使用到的两个方法： 12345678910111213141516/** * 加密处理 - 同步方法 * bcryptjs.hashSync(data, salt) * - data 要加密的数据 * - slat 用于哈希密码的盐。如果指定为数字，则将使用指定的轮数生成盐并将其使用。推荐 10 */const hashPassword = bcryptjs.hashSync(password, 10)/** * 校验 - 使用同步方法 * bcryptjs.compareSync(data, encrypted) * - data 要比较的数据, 使用登录时传递过来的密码 * - encrypted 要比较的数据, 使用从数据库中查询出来的加密过的密码 */const isOk = bcryptjs.compareSync(password, encryptPassword) 路由介绍路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。 每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行 express-sessionhttp://blog.inode.club/cookie-session-token305/ express-validatorhttps://juejin.cn/post/6844903854195081223 项目中遇到的问题1 a标签的点击事件以及href跳转的问题在项目中，我需要设计一个删除按钮（是一个a标签），点击后会弹出确认窗口，如果取消删除，则不发生任何操作。如果点击确定（删除），那么就会进行href的一个路由跳转。 a标签的click 事件是在页面开始跳转之前执行的。正常情况下，如果给a标签添加一个click点击事件，比如说执行一些打印操作，控制台会很快刷新一下的。因为a标签有默认的一个href跳转动作（默认事件），在执行完打印操作后，页面会很快跳转，这是控制台就已经被刷新了。 如果要阻止这个默认事件，可以使用e.preventDefalt()。 参考链接 HTML tag want to add both href and onclick working a 标签的 href 属性和 onclick 事件 2 mkdirp slower than fileupload项目中使用mkdirp插件实现多层文件夹的操作，建完文件夹后，需要把图片保存在对应的文件夹中，但这时候我遇到了问题：No such file or directory，经观察，我发现创造文件更慢，以至于后面上传文件的时候，没有文件夹。这就是程序报错的原因：。 更重要的原因是mkdirp这个函数是异步的。因此，可以在异步执行完后返回的promise中使用then方法，继续下面的程序 12345678910111213mkdirp('public/product_images/'+ product._id).then(made =&gt; { console.log(`made directories, starting with ${made}`) if(imageFile !== &quot;&quot;){ let productImage = req.files.image; // console.log(productImage) const filepath = 'public/product_images/'+ product._id+'/' + imageFile; // 文件上传 productImage.mv(filepath,err=&gt; { return console.log(err) }) }} 3 request.files获取不到文件的解决方案在form表单中发送post请求的时候，需要给服务器一些图片，但是我在req.files上找不到。后来发现是我在form标签了，没有加上 enctype=”multipart/form-data” 的属性。 要确保能在req.files上获取文件，要确保一些几点： 保证页面中的上传文件标记里都包含name属性。 必须在form上添加 enctype=”multipart/form-data” 的属性。 这样后台就可以正常获取input type=”file”提交过来的文件里。 4 管理台新添page,或者顺序改变，如果不重启服务器，用户主页不会更新解决办法是在管理台的adminPages.js文件上，及时更改全局的pages变量，也就是req.app.locals.pages 12345Page.find({}).sort({sorting:1}).exec(function(err,pages){ if(err) console.log(err) // set global pages variable req.app.locals.pages = pages;}) 5 相对路径和绝对路径的问题/product_images和product_images路径的区别，前者绝对路径（localhost:3000/product_images)，后者是相对路径(localhost:3000/当前路径/product_images) app.use(‘/当前路径’) 12os.mkdir('dir_name') // 相对路径os.mkdir('/dir_name') //绝对路径 6 using findOne inside a foreach()由于mongoose数据查询是异步操作，所以如果我在for循环下查找数据库的话会出现问题。 这个问题出现的场景是，我想在用stripe结账的时候，从服务器上计算total总价格，因此我采用前端传过来的购买商品名字和数量这两个信息，去服务器里匹配对应的商品价格，然后计算total。但是我每次stripe接口结账的时候total为0，而stripe接口必须支付打印1cent以上的金额。所以就出现了程序报错。 查找了很多资料，有说下面的程序可以解决，但是我试了不可行。但这里我这个方法我还是想做个标记，因为我对异步不是理解得很透彻。 12345(async () =&gt; { for (const question of questionList) { await questionAction(question); }})() 最后我找到了解决问题的思路，就是数据库接口的设计问题，一个数据库不止可以实现findOne查找，还有findAll查找。为什么要每次在for循环下findOne呢？这很明显不符合数据库接口的设计思路，多次访问数据库也会给服务器带来很多负担。 所以应该优化这个查询思路，就是一次性找出所有的数据，找出来后再进行计算。 12345678910111213141516171819202122232425262728Product.find({slug:titles},(err,products)=&gt;{ if(err) console.log(err); // console.log(item,product) if(products){ // prices.push(product.price) products.forEach((product,i)=&gt;{ // console.log(product.title,req.body.items[i]) total += product.price * req.body.items[i].quantity }) console.log(total) // stripe的total是用美分计算的，，所以要*100 stripe.charges.create({ // total金额要在1美元以上 amount: parseFloat(total).toFixed(2)*100, source: req.body.stripeTokenId, currency: 'usd' }).then(function() { // 清空购物车 delete req.session.cart // You're using a res in the then callback, and that one shadows the res from the router.post. console.log('Charge Successful') res.json({ message: 'Successfully purchased items' }) }).catch(function(e) { console.log(e.message,'Charge Fail') res.status(500).end() }) } 解决问题过程中查找的资料： 解决mongoose数据查询的异步操作 How to call a mongoose findOne inside the forEach before the answer? 如何优雅的解决循环里的异步查询？（主要是这个博客点醒了我！！！！） 7 res.redirect is not a function in promise thenres.redirect cant work in then promise 项目未来的一些优化想法1 采用懒加载的加载模式，大大提高了页面的加载速度，提高用户体验，降低了后台API请求数据的压力。 2 权限跳转 https://juejin.cn/post/6844904033660977159 3 jwt 方式，标识用户身份 服务器验证成功后应该签发一个身份标识的东西给客户端，这样以后客户端就拿着这个标识来证明自己的身份。而标识用户身份的方式有多种，这里我们采用jwt方式 https://juejin.cn/post/7044708915438682148 4 后台管理中，pages 编辑的内容。可以用一些插件修改文字的样式，比如 CKeditor 总结这个项目大概做了8天。写博客也花了好几个小时。甚至中途都有点想为啥我要花这么久时间写博客，太费时间了。后来我想通了，我目前的学习不是很沉淀，我需要做笔记来加深我对前端知识的理解。所以我应该坚持。 最近比较忙碌的一段时间，本来想找实习的，但是来不及了，感觉没有准备好。还有这个月中旬由有教资面试（虽然我不打算当老师），但是我就是想拿到这个证，所以我就下定决心要花时间拿到。这个月还想开始联系博导，虽然我的最终目标是硕士毕业工作，做前端开发，但是我本科就有一些文章和成果，所以还是想看看这些东西能不能找个985博士读读。 最近几个月我还想复习我的光学专业知识，感觉专业上用的中文教材都不是很好，没讲清楚很多东西，所以我找一下国外教材重新复习一下。一下子这么多事情我感觉很烦躁，随便一项工作都要花时间，有些东西最对我来水可能以后还用不到，但是我一想到这点，我就觉得我不能这样想，我不能因为他有用而去学。相反，任何东西都很有用，我应该抱着热爱、兴趣的态度去学习。如果我要是不喜欢，那我才应该真正的放弃。","link":"/myblog.github.io/2022/05/04/%E3%80%90nodejs%E3%80%91%E5%9F%BA%E4%BA%8EEJS+Node.js+MongoDB%E7%9A%84%E5%85%A8%E6%A0%88%E7%94%B5%E5%95%86%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%85%A8%E8%8B%B1%E6%96%87%EF%BC%89/"},{"title":"【前端面试-VUE】VUE合集","text":"vuex123456789101112131415161718192021222324252627282930313233343536### 谈谈vuex原理？1 执行Vue.use。会执行vuex的install方法，会往全局混入一个mixin，只有一个属性beforeCreate，它的作用是让每个组件可以访问到this.$store属性。2 执行new Vuex.Store。将传入的配置进行格式化处理，会递归注册每个module的state、mutations、actions、getters属性，将每个module的mutations、actions、getters放入一个对象里，对应的key前面会加上模块名，而state会放入一个有上下级关系的对象里。3 内部会重写commit和dispatch，当前模块触发状态变更时，自动在要触发的commit和dispatch前面加上模块名。4 最后会提供一些map开头的语法糖使用。### vuex是什么？怎么使用？哪种功能场景使用它？1 状态管理模式。可以看成一个数据仓库，集中管理项目公共数据的，所有组件都可以访问并更改。（统一管理，数据共享，程序可维护性高）2 具有state、mutations、actions、getters、module属性。state 有数据； mutations 唯一能更改数据的地方，有点像vue实例的方法；(只能写同步的方法，异步操作写字actions上)actions 提交mutations，不能直接修改state;getters 计算属性;moudle 小仓库，store分割成模块，每个模块拥有自己的 state、mutations、actions、getters、甚至是嵌套子模块3 单向数据流4 大型项目中比较常用，非关系组件传递数据比较方便5 使用5.1 Vue.use 使用vuex插件5.2 new Vuex.Store 创建一个store 实例：里面有state，mutations,actions，getters属性。state初始化数据，mutations、actions和getters可以写方法，actions需要提交mutations才能改变state，getters是计算属性，用来简化数据5.3 在Vue 组件中， 可以通过 this.$store 访问store实例，mutations的方法可以通过`store.commit`调用，触发状态变更。actions 的方法可以通过 `store.dispatch` 方法触发，如果要改变数据的话，需要再提交mutationsgetters 的方法直接通过`store.getters`调用5.4 使用mapState、mapMutations、mapActions、mapGetters等辅助函数可以一次性获取仓库的数据或者属性等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061### 双向绑定和 vuex 是否冲突1 问题出现的场景：&lt;input v-model=&quot;obj.message&quot;&gt;这里的 obj 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，v-model 会试图直接修改 obj.message。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。所以确实会有冲突2 解决方案2.1 在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值&lt;input :value=&quot;message&quot; @input=&quot;updateMessage&quot;&gt;// ...computed: { ...mapState({ message: state =&gt; state.obj.message })},methods: { updateMessage (e) { this.$store.commit('updateMessage', e.target.value) }}2.2 使用带有setter的双向绑定计算属性。&lt;input v-model=&quot;message&quot;&gt;// ...computed: { message: { get () { return this.$store.state.obj.message }, set (value) { this.$store.commit('updateMessage', value) } }}### 聊聊Vuex 的设计思想把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。### 为什么 Vuex 的 mutation 不能做异步操作1 设计理念。人为规定不能在mutation中使用异步，强行建议做同步操作，将它作为一个无副作用的函数，使得状态可预测的，方便维护。将有副作用的函数放在action中，同步修改放在mutation中2 异步操作的副作用。vuex中在mutation中使用异步，程序也不会报错，所以对结果是没有影响的。但是异步操作是成功还是失败不可预测，什么时候进行异步操作也不可预测；当异步操作成功或失败时，如果不 commit(mutation) 或者 dispatch(action)，Vuex 就不能捕获到异步的结果，从而进行相应的操作### vuex持久化存储1 不能持久化存储，页面一刷新或者关闭就没了2 解决方案：2.1 localStorage2.2 使用插件，比如vue-persist（本质上也是localStorage) MVVM12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152### 对于MVVM的理解一个框架，一个理念1 为什么有这个框架前端的历史，不从web1.0，web2.0讲起，而是将MVC框架，因为MVVM本质上是MVC的改进版1.1 MVCModel View Controller，即模型-视图-控制器。用户访问操作网页会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数据。将结果返回给前端,页面重新渲染。1.2 MVC特点特点：单向通信；View和Model直接进行通信1.3 痛点随着前端应用的复杂程度越来越复杂，View和Model之间随着业务量的不断庞大，那么MVC就暴露出了三个痛点问题：◆ 开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。◆ 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。◆ 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。所以MVVM就出现了，并且可以解决上述问题。2 MVVM这个框架是什么MVVM 是 Model-View-ViewModel 的缩写。Model: 代表数据模型，数据层View: 视图层，用户操作界面。ViewModel：业务逻辑层。View通过View-Model的DOM Listeners将事件绑定到Model上，而Model则通过Data Bindings来管理View中的数据，View-Model从中起到一个连接桥的作用。MVVM框架与MVC框架的主要区别有两点：◆ 实现数据与视图的分离◆ 数据双向绑定。通过数据来驱动视图，开发者只需要关心数据变化，DOM操作被封装了。总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。### 为什么使用前端框架?1 组件化: 高度的组件化可以是我们的工程易于维护、易于组合拓展。2 天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。3 生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案 1234567### MVVM-脏数据检测### 当新入职一家公司时，如何快速搭建开发环境并让应用跑起来 MVVM-数据劫持12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849### Object.defineProperty`语法` Object.defineProperty(obj,prop,descriptor)`参数` obj:目标对象 prop:需要定义的属性或方法的名称 descriptor:目标属性所拥有的特性`可供定义的特性列表` value:属性的值 writable:如果为false，属性的值就不能被重写。 get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。 set:一旦目标属性被赋值，就会调回此方法。 configurable:如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被无效化。 enumerable:是否能在for...in循环中遍历出来或在Object.keys中列举出来。-----------------------------------------------------------------------------------------------------------下面这段代码演示了object.defineProperty的使用，可以发现当我们访问或者修改对象的属性的时候，可以触发getter和setter函数--------------------------------------------------------------------------------------------------------var data = { name:'lhl'}Object.keys(data).forEach(function(key){ Object.defineProperty(data,key,{ enumerable:true, configurable:true, get:function(){ console.log('get'); }, set:function(){ console.log('监听到数据发生了变化'); } })})data.name //控制台会打印出 “get”data.name = 'hxx' //控制台会打印出 &quot;监听到数据发生了变化&quot;从上可以发现，当我们访问(get)或设置(set)对象的属性的时候，都会触发相对应的函数，然后在这个函数里返回或设置属性的值。既然如此，我们当然可以在触发函数的时候动一些手脚做点我们自己想做的事情，这也就是“劫持”操作。### 总结Vue通过Object.defineProperty来劫持对象属性的setter和getter操作，每次访问(get)或设置(set)对象的属性的时候，可以做一些具体的实现自己目的的操作。vue进行数据劫持主要是实现数据双向绑定，所以在劫持到setter和getter的时候，可以“种下”一个监听器，当数据发生变化的时候发出通知。这样就可以实现。 数据双向绑定原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114### 总结数据双向绑定的原理离不开数据劫持，Vue通过Object.defineProperty来劫持对象属性的setter和getter操作，每次访问(get)或设置(set)对象的属性的时候，可以做一些具体的实现自己目的的操作。要实现数据双向绑定，就要在劫持到setter和getter的时候，“种下”一个监听器，当数据发生变化的时候发出通知。这样就可以实现。-----------------------------------------------------------------------------------------------------------object.defineProperty实现数据劫持的可行性--------------------------------------------------------------------------------------------------------var data = { name: 'yck' }observe(data)let name = data.name // -&gt; get valuedata.name = 'yyy' // -&gt; change valuefunction observe(obj) { // 判断类型 if (!obj || typeof obj !== 'object') { return } Object.keys(obj).forEach(key =&gt; { defineReactive(obj, key, obj[key]) })}function defineReactive(obj, key, val) { // 递归子属性 observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { console.log('get value') return val }, set: function reactiveSetter(newVal) { console.log('change value') val = newVal } })}注*：observe方法观测对象和数组，给其添加一个observel实例### 添加发布订阅上面代码只是展示了数据劫持的可行性，并没有真正实行，要实现数据双向绑定，还得做一些初始化工作，给model的属性添加发布订阅// 通过 Dep 解耦class Dep { constructor() { this.subs = [] } // 订阅，标记要更新的数据 addSub(sub) { // sub 是 Watcher 实例 this.subs.push(sub) } // 通知（发布），更新数据 notify() { this.subs.forEach(sub =&gt; { sub.update() }) }}// 全局属性，通过该属性配置 WatcherDep.target = nullfunction update(value) { document.querySelector('div').innerText = value}class Watcher { constructor(obj, key, cb) { // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null } update() { // 获得新值 this.value = this.obj[this.key] // 调用 update 方法更新 Dom this.cb(this.value) }}### 真正实现数据劫持function defineReactive(obj, key, val) { // 递归子属性 observe(val) let dp = new Dep() Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { console.log('get value') // 将 Watcher 添加到订阅 if (Dep.target) { dp.addSub(Dep.target) } return val }, set: function reactiveSetter(newVal) { console.log('change value') val = newVal // 执行 watcher 的 update 方法 dp.notify() } })} 数据双向绑定问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980### Proxy 相比于 defineProperty 的优势1 Object.defineProperty 缺陷◆ 只能对属性进行数据劫持，所以需要深度遍历整个对象◆ 对于数组不能监听到数据的变化const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)// hack 以下几个函数const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']methodsToPatch.forEach(function (method) { // 获得原生函数 const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) { // 调用原生函数 const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) ob.observeArray(inserted) // 触发更新 ob.dep.notify() return result })})2 Proxy◆ 原生支持监听数组变化，◆ 并且可以直接对整个对象进行拦截（不只是属性）let onWatch = (obj, setBind, getLogger) =&gt; { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver); }, set(target, property, value, receiver) { setBind(value); return Reflect.set(target, property, value); } }; return new Proxy(obj, handler);};let obj = { a: 1 }let valuelet p = onWatch(obj, (v) =&gt; { value = v}, (target, property) =&gt; { console.log(`Get '${property}' = ${target[property]}`);})p.a = 2 // bind `value` to `2`p.a // -&gt; Get 'a' = 2### v-model原理v:model 在模板编译的时候转换代码v-model 本质是 :value 和 v-on，但是略微有点区别。在输入控件下，有两个事件监听，输入中文时只有当输出中文才触发数据赋值v-model 和:bind 同时使用，前者优先级更高，如果 :value 会出现冲突v-model 因为语法糖的原因，还可以用于父子通信 vue源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465### diff算法请说下VUE diff算法1 虚拟节点vnodevnode是描述了节点的对象，vnode提供一种简单对象去代替复杂的 dom 对象，从而优化 dom ,不用不断操作DOM，因为这样很耗性能。2 diff算法diff算法去比较新旧vnode的差异，将变化的地方更新到真实的dom上。3 总结框架会将所有的结点先转化为虚拟节点Vnode，在发生更改后将VNode和原本页面的OldNode进行对比，然后以VNode为基准，在oldNode上进行准确的修改。（修改准则：原本没有新版有，则增加；原本有新版没有，则删除；都有则进行比较，都为文本结点则替换值；都为静态资源不处理；都为正常结点则替换）### 介绍下虚拟 DOM，对虚拟 DOM 的理解1 Virtual DOMVirtual DOM(虚拟DOM)，是由普通的JS对象来描述DOM对象。真实DOM成员，先打印出所有的DOM成员--------------------------------------------------------------------------------------------------------let element = document.querySelector('#app')let s = ''for(let key in element){ s += key + ','}console.log(s)一个DOM的成员是非常多的，创建一个真实DOM成本非常高--------------------------------------------------------------------------------------------------------虚拟DOM{ sel:'div', data:{}, children:undefined, text:'hello world', elm:undefined, key:undefined}创建成本比真实DOM低很多### 组件在 Vue 中，子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的### 响应式Vue 响应式原理### 原理vue 中 computed 的原理是什么vue-loader 的实现原理是什么### keyreact 与 vue 数组中 key 的作用是什么在 react/vue 中数组是否可以以在数组中的次序为 key在虚拟 DOM 中进行 diff 算法时，介绍当根据 key 对数组进行重用时的算法 组件通信123456789101112131415161718192021222324252627282930313233343536组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯### 父子组件间 1 props 和$emit这种方式通常用于父子组件之间的传值，父组件通过属性的方式将值传递给子组件，子组件通过props进行接收。子组件通过自定义事件的方式向父组件传递数据。2 $parent获取父组件值这种方式可以让子组件非常方便的获取父组件的值，不仅仅包括数据，还可以是方法。3 $children和$refs获取子组件值这两种方式和$parent非常的类似，它们可以直接获取子组件的相关属性或方法，不仅限于数据。### 兄弟组件1 全局事件总线 this.$bus.$emitthis.$bus.$on事件中心的思想也比较简单：中间中心主要就两个作用：触发事件和监听事件。假如两个组件之间需要传递数据，组件A可以触发事件中心的事件，组件B监听事件中心的事件，从而让两个组件之间产生关联，实现数据传递。2 VuexVuex是状态管理器，它存储的数据不是持久化存储，一旦刷新页面或者关闭项目数据便不见了。Vuex存储的数据是响应式的。3 localstorageloacalStorage是HTML5中的一种数据存储方式，持久化存储，存储的数据不是响应式的。### 总结Vue中组件通讯的方式有很多种，每一种应用的场景可能都有一些不一样，我们需要在合适的场景下选择合适的通讯方式。父子组件间通讯：props和emit、emit、emit、parent、refs和refs和refs和children、v-model兄弟组件间通讯：事件总线、Vuex、localStorage隔代组件间通讯：provide和inject无相关组件间通讯：事件总线、Vuex、localStorage 路由12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758### Vue的路由实现：hash模式 和 history模式1 hash模式: 在浏览器的url中有符号“#”2 history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。### vue-router 有哪几种导航守卫?1 全局守卫router.beforeEach 全局前置守卫 进入路由之前router.beforeResolve 全局解析守卫router.afterEach 全局后置钩子 进入路由之后 // main.js 入口文件 import router from './router'; // 引入路由 router.beforeEach((to, from, next) =&gt; { next(); }); router.beforeResolve((to, from, next) =&gt; { next(); }); router.afterEach((to, from) =&gt; { console.log('afterEach 全局后置钩子'); });2 路由独享守卫const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; { // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 // ... } } ] })3 路由组件内的守卫（用得较少）beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 thisbeforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this### 路由鉴权登录页和其他页面分开，登录以后实例化 Vue 并且初始化需要的路由动态路由，通过 addRoute 实现简述路由原理### React/Vue 中的 router 实现原理如何### vue-router 实现懒加载的方法？1 vue-router 实现懒加载的作用：性能优化，不用到该路由，不加载该组件2 ES6的impot方式: component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ '../views/About.vue') VUE中的异步组件进行懒加载方式: component: resolve=&gt;(require(['../views/About'],resolve)) 生命周期123456789101112131415161718192021222324252627282930313233343536373839404142434445### 请详细说下你对vue生命周期的理解1 beforeCreate data和methods中的数据或方法还未初始化，无法调用，只能使用一些默认事件。2 createddata和methods已经初始化完成了，但是模板还没有编译，也就是我们还不能获取到DOM3 beforeMount模板进行编译，会调用render函数生成vDom，也就是虚拟DOM，此时我们同样无法获取DOM节点。无法获取DOM节点的，因为此时只存在VDOM，还在JS级别4 mounted模板编译好了，而且挂载到真实DOM树上面去了，也就是我们的页面可以显示了。5 beforeUpdate页面或者组件发生变化时，便会执行对应的更新阶段的钩子函数。6 updated页面也渲染更新完成了，显示的就是最新的数据7 beforeDestory此时组件实际上还没有被销毁，还可以正常使用。我们通常会在这个钩子函数里面解除一些全局或者自定义事件8 destoryed此时所有的组件包括子组件都被销毁了。9 补充通常情况下我们切换路由等一些操作时，组件都会被销毁，切换回来的时候组件又重新渲染。但是有时候我们为了提高性能，我们可以在切换路由的时候不必销毁组件，这个时候我们就需要用到Vue的一个内置组件keep-alive。activated页面渲染的时候执行deactivated页面被隐藏或者页面即将被替换成新的页面时被执行### Vue 的父组件和子组件生命周期钩子执行顺序是什么父组件和子组件钩子执行顺序加载渲染过程：父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted父组件挂载完毕肯定是等里面的子组件都挂载完毕后才算父组件挂载完毕了，所以父组件的mounted在最后。子组件更新过程(子组件更新影响到父组件的情况)：父beforeUpdate -&gt; 子beforeUpdate-&gt;子updated -&gt; 父updted子组件更新过程(子组件更新不影响父组件的情况)：子beforeUpdate -&gt; 子updated父组件更新过程(父组件影响子组件的情况)：父beforeUpdate -&gt; 子beforeUpdate-&gt;子updated -&gt; 父updted父组件更新过程(父组件不影响子组件的情况)：父beforeUpdate -&gt; 父updated销毁过程：父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed 性能优化1234567891011121314151617181920212223242526272829303132### vue 渲染大量数据时应该怎么优化数据量大的时候，可以做分页处理。翻页一次请求10-20条数据按需加载局部数据, 虚拟列表，无限下拉刷新js运行异步处理:分割任务，实现时间切片处理, 类似react fiber, 每次执行记录时间, 超过一定执行时间则settimeout或requestAnimation推迟到下一个时间片,一般一个时间片为16ms大量纯展示的数据,不需要追踪变化的 用object.freeze冻结### vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？1 回答1首页白屏的原因：单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的js文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏**解决办法**优化 webpack 减少模块打包体积，code-split 按需加载服务端渲染，在服务端事先拼装好首页所需的 html首页加 loading 或 骨架屏 （仅仅是优化体验）2 回答2VUE首页加载过慢，其原因是因为它是一个单页应用，需要将所有需要的资源都下载到浏览器端并解析。**考虑解决办法**1.使用首屏SSR + 跳转SPA方式来优化2.改单页应用为多页应用，需要修改webpack的entry3.改成多页以后使用应该使用prefetch的就使用4.处理加载的时间片，合理安排加载顺序，尽量不要有大面积空隙5.CDN资源还是很重要的，最好分开，也能减少一些不必要的资源损耗6.使用Quicklink，在网速好的时候 可以帮助你预加载页面资源7.骨架屏这种的用户体验的东西一定要上，最好借助stream先将这部分输出给浏览器解析8.合理使用web worker优化一些计算9.缓存一定要使用，但是请注意合理使用10.大概就这么多，最后可以借助一些工具进行性能评测，重点调优，例如使用performance自己实现下等 手写源码1234### 如何使用 vue 实现一个 message API### 写一个发布订阅 EventEmitter方法简单 其他1234567891011121314151617181920212223242526272829303132333435363738### vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？1 事件代理需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数2 作用将事件处理程序代理到父节点，减少内存占用率动态生成子节点时能自动绑定事件处理程序到父节点### watch 和 computed 的区别和运用的场景1 computed计算属性，值有缓存，只有当计算值变化才变化触发渲染;computer 就是简单计算一下，适用于渲染页面2 watch后者监听到值得变化就会执行回调;watch 适合做一些复杂业务逻辑### Vue 中 $nextTick 作用与原理？下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。也支持 Promise 的使用，会判断是否实现了 PromisePromiseMutationObserversetImmediatesetTimeout### vue 中 v-if 和 v-show 的区别是什么v-show 总是会进行编译和渲染的工作 - 它只是简单的在元素上添加了 display: none; 的样式。v-show 具有较高的初始化性能成本上的消耗，但是使得转换状态变得很容易。 v-if 才是真正「有条件」的：它的加载是惰性的，因此，若它的初始条件是 false，它就不会做任何事情。这对于初始加载时间来说是有益的，当条件为 true 时，v-if 才会编译并渲染其内容。切换 v-if 下的块儿内容实际上时销毁了其内部的所有元素，比如说处于 v-if 下的组件实际上在切换状态时会被销毁并重新生成，因此，切换一个较大 v-if 块儿时会比 v-show 消耗的性能多。","link":"/myblog.github.io/2022/05/20/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-VUE%E3%80%91VUE%E5%90%88%E9%9B%86/"},{"title":"【前端面试-JS】基础面试题","text":"JS 基础面试延迟加载js方式 async 后台下载 执行会中断页面渲染 下载好后立刻执行，没有顺序（谁先下载完谁先执行） defer 后台下载 不会中断页面渲染（等页面渲染完后执行） 顺次执行（多个js文件会按先后顺序执行） 数据类型基本类型string, number, boolean, undefined, null, symbol（, bigint) 引用类型object(包括数组等) 数据类型的隐式转换 true+1 // 2 ‘name’ + true // ‘nametrue’ （字符串和其他类型相加，都是转化成字符串） undefined + 1 // NaN（是一个number) typeof null // object null 和undefined 区别undefined 一个变量最原始的状态；此处应该有一个值，但是还没有定义；转为数值时为NaN 变量被声明了，但没有赋值 调用函数时，但没有传递实参 访问对象上不存在的属性或者未定义的变量 函数没有返回值时，默认返回undefined null 表示一个被人为的重置为空对象；该处的值为空；转为数值时为0 典型用法： 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。 == 和 === 区别== 比较的是值 === 不仅比较值，还比较类型 微任务和宏任务背景知识js是单线程，但是有异步处理。js是同步任务执行完毕后再去执行异步任务。 什么是宏任务和微任务微任务： promise.then 宏任务：定时器，用户交互事件，ajax，读取文件 js异步执行原则1 同步 2 process.nextTick 3 异步 3.1 微任务： promise.then 3.2 宏任务：定时器，用户交互事件，ajax，读取文件 4 setImmediate方法 注意： 同步的任务都执行完后，才会执行事件循环的内容。 要执行宏任务，前提是清空所有微任务。 js代码执行流程： 同步执行完后 =&gt; 事件循环（宏任务和微任务） =&gt; 微任务 =&gt; 宏任务 =&gt; 微任务 … 进入事件循环：请求，定时器，事件… JS作用域1 除函数外，js没有块级作用域 2 作用域链：内部可以访问到外部的变量，但是外部不能访问内部的变量。 注意：如果有内部，优先查找内部，如果没有，就查找外部 3 声明变量没有用var let const，那这个变量就是全局的(window的) 4 js变量提升机制 5 优先级： 声明变量 &gt; 声明普通函数 &gt; 参数 &gt; 变量提升 var 变量提升 变量覆盖 没有块级作用域 const 声明之后必须赋值 定义的值不可修改 其他和let一样 let 没有变量提升 不允许重复声明 所声明的变量，只在let命令所在的代码块内有效 暂时性死区使用 let 或 const 声明的变量，在声明赋值没有到达之前，访问该变量都会导致报错，就连一直以为安全的 typeof 也不再安全 12345678910111213{ //函数作用域开始，TDZ开始 console.log(temp) //ReferenceError: temp is not defined //声明 let temp console.log(temp) //ReferenceError: Cannot access 'temp' before initialization //赋值 temp = 345 //TDZ结束 console.log(temp) //345 //块级作用域结束}//在块级作用域外访问console.log(temp) //ReferenceError: temp is not defined 注意：任何在暂时性死区内访问变量的企图都会导致 运行时错误（Runtime Error）。只有执行到变量的声明语句时，该变量才会从暂时性死区内被移除并可以安全使用。 JS对象1 对象通过new操作符构建的，所以对象不相等(=== 是false) 2 对象是引用类型（地址） 3 对象的key是字符串类型 12345678910111213a = { aa: 1 }b = { bb: 2 }c = { cc: 3 }a[b] = '123'a[c] = '456'console.log(a[b]) // 456b和c是对象，当成为a的属性的时候，会变成字符串，值是[object object]。c会覆盖b的值。相当于a = { '[object object]':456, aa:1} 4 对象如何找属性或者方法（原型链） 对象本身找 =&gt; 构造函数找 =&gt; 对象原型找 __proto__=&gt; 构造函数原型找 prototype =&gt; 对象上一层原型查找 instanceof判断对象的类型，原理是通过判断对象的原型链中是不是能找到构造函数的 prototype。 语法 object instanceof constructor 123456789101112function Car(make, model, year) { this.make = make; this.model = model; this.year = year;}const auto = new Car('Honda', 'Accord', 1998);console.log(auto instanceof Car);// expected output: trueconsole.log(auto instanceof Object);// expected output: true 判断变量是否是数组1 isArray 12const arr = [1,2,3]console.log(Array.isArray(arr)) 2 instanceof 12const arr = [1,2,3]console.log(arr instanceof Array) 3 原型prototype 12const arr = [1,2,3]Object.prototype.toString.call(arr).indexOf('Array') &gt; -1 4 isPrototypeOf 12const arr = [1,2,3]Array.prototype.isPrototypeOf(arr) 5 constructor 12const arr = [1,2,3]arr.constructor.toString().indexOf('Array') &gt; -1 new 操作符具体做了什么1 创建了一个空对象 2 将空对象的原型，指向构造函数的原型 fn.prototype === new fn().__proto__ 3 将空对象作为构造函数的上下文（改变this的方向） 12345function Foo(){ this.name = 'aa' // this指向window}console.log(new Foo()) // Foo {name: 'aa'} this指向new出来的对象 4 对构造函数有返回值的处理判断 如果返回的是基本类型，则没有影响，如果是对象，则就是返回值 12345678function Foo(){ this.name = 'aa' // this指向window return 11 // return {} // return [1,2,3]}console.log(new Foo()) // Foo {name: 'aa'} 返回的11没有影响 手写new1234567891011function create(fn,...args){ // 创建一个空对象 const obj = {} // 将空对象的原型，指向构造函数的原型 Obeject.setPrototypeOf(obj,fn.prototype) // 将空对象作为构造函数的上下文(改变this指向) const result = fn.apply(obj,args) // 对构造函数的有返回值的处理判断 return result instanceof Object ? result : obj } 闭包1 闭包是什么闭包是一个函数加上创建函数的作用域链接，闭包“关闭”了函数的自由变量。 通俗的描述：函数嵌套函数，内部函数就是闭包 正常情况下，函数执行完后，内部的变量会销毁，但是有了闭包后，函数内部的变量就可以保存。等内部的函数（闭包）执行外后，该变量才会被销毁。 12345678910111213141516const lis = document.getElmentsByTagName('li') // 加上lis长度为5for(var i=0;i&lt;lis.length;i++){ lis[i].onclick = function(){ alert(i) }}// 每次点击列表的某个元素，都显示5// 下面看加了闭包for(var i=0;i&lt;lis.length;i++){ (function(i){ lis[i].onclick = function(){ alert(i) } })(i)}// 每次点击列表的某个元素，对应显示下标0,1,2,3,4 2 闭包解决什么问题 延长变量的生命周期（原理是内部函数可以访问到外部函数的局部变量） 实现模块化功能（创建私有环境） vue 的组件中的data是一个函数就是利用闭包的思想，可以保护组件的数据不被其他组件影响 12345678910111213141516const cal = (function(){ let a = 10, b = 20 function add(){ reurn a+b } function sub(){ return a-b } return { add, sub }})()console.log(cal.add()) // 30console.log(cal.sub()) // -10 3 闭包缺点变量驻留在内存中，造成内存损耗 原型对象原型每个对象都有原型对象，原型对象上的所有属性和方法，该对象都能访问。 1234567let cat = { name:&quot;喵喵&quot;}cat.__proto__.eat = function(){ console.log(&quot;吃鱼&quot;)}cat.eat() // 吃鱼 获取原型的方法 通过对象的__proto__ 通过构造函数（或者类）的prototype new 创建的是一个对象。 123456789function Cat(name,age){ this.name = name this.age = age}let cat = new Cat(&quot;喵喵&quot;,2)Cat.prototype.eat = function(){ console.log(&quot;吃鱼&quot;)}cat.eat() // 吃鱼 类与继承1 类 ES5创建对象用构造函数，ES6创建对象用class 1234567891011class Cat{ constructor(name,age){ this.name = name this.age = age }}Cat.prototype.eat = function(){ console.log(&quot;吃鱼&quot;)}let cat = new Cat(&quot;喵喵&quot;,2)cat.eat() // 吃鱼 2 继承 ES6 1234567891011121314151617class User{ constructor(username,password){ this.username = username this.password = password } login(){ console.log(&quot;log in&quot;) }}class Admin extend User{ deletePerson(){ console.log(&quot;删除了一个用户&quot;) }}let admin = new Admin()admin.login() // log in ES5： prototype 12345678910111213141516function User(username,password){ this.username = username this.password = password this.login(){ console.log(&quot;log in&quot;) }}function Admin(){ this.deletePerson(){ console.log(&quot;删除了一个用户&quot;) } }Admin.prototype = new User()let admin = new Admin()admin.login() // log in 原型链 原型链是什么 一个对象有原型，其原型又是一个对象，该对象也有原型，可以看，一直往上，有一条原型链存在。（最顶端是Obejct.prototype) 解决什么问题 对象共享属性和共享方法 谁有原型 函数：prototype 对象：__proto__ 对象查找属性或者方法的顺序 对象本身找 =&gt; 构造函数找 =&gt; 对象原型找 __proto__=&gt; 构造函数原型找 prototype =&gt; 对象上一层原型查找 JS继承1 ES6 2 原型链 3 构造函数继承 4 组合式继承 call, apply, bind区别共同点：功能一致 改变this指向， 语法：函数.call() 、函数.apply()、函数.bind() 区别 call, apply可以立即执行，bind不会立即执行（返回的是一个函数） 参数：apply第二个参数是数组，call和bind有多个参数是需要挨着写(arg1,arg2,arg3,…) 场景 继承：子类可以继承父类的方法 1234567891011function Animal(){ this.eat = function(){ console.log(&quot;吃东西&quot;) }}function Cat(){ Animal.call(this)}let cat = new Cat()cat.eat() // 吃东西 求最大值 123const arr = [1,2,3,4,5,6,7]console.log(Math.max.apply(null,arr)) // 求最大值// Math.max(...arr) 2 bind 12345const bnt = document.getElmentById('btn')const hls = document.getElmentById('hls')bnt.onclick = function(){ console.log(this.id)}.bind(hls) 手写bind, call, aplly 手写bind 12345Function.prototype.myBind = function(obj,...args){ return (...rest)=&gt;{ this.call(obj,...args,...rest) }} 手写call 12345678Function.prototype.myCall = function (obj, ...args) { // this表示f.myCall的f函数 obj.fn = this const result = obj.fn(...args) // 删除 fn delete obj.fn return result} 手写apply 12345678Function.prototype.myApply = function (obj, args) { // this表示f.myCall的f函数 obj.fn = this const result = obj.fn(...args) // 删除 fn delete obj.fn6ew return result} this指向1 普通函数或作为对象属性函数作为对象的属性被调用的时候，其this指向调用该函数的对象，否则其this指向window 123456789101112const fn = function () { console.log(this); // 指向window};const obj = { name: 'OBJ', fn };fn(); // window（相当于window.fn()） obj.fn();// {name: 'OBJ', fn: function() {console.log(this)}} // objconst fn1 = obj.fn; fn1(); // window 2 事件绑定在进行事件绑定的时候，事件绑定函数中的this是绑定事件的元素 3 构造函数(new Fn)构造函数(new Fn)执行，函数中的this是当前类的实例 12345678var x = 100;const Fn = function () { this.x = 200; console.log(this.x);};const fn = new Fn(); // 200 4 箭头函数箭头函数中没有自身的this，所用到的this都是其最近父级上下文中的this 1234567891011121314const fn = function () { console.log(this); // {x:100, fn: function() {...}} // obj setTimeout(() =&gt; { console.log(this); // window 定时器是全局的 }, 1000); setTimeout(function () { console.log(this); // {x:100, fn: function() {...}} // obj });};const obj = { x: 100, fn };obj.fn(); 5 call/apply/bind改变this指向call/apply/bind传入的第一个参数即为函数的this 12345678910111213var x = 100;const obj = { x: 200, y: 200 };const fn = function () { console.log(this.x);};fn(); // 100fn.call(obj); // 200fn.apply(obj); // 200const fixedThisFn = fn.bind(obj);fixedThisFn(); //200 call在执行时，第一个参数为this指向，之后的参数为fn执行时的参数 apply在执行时，第一个参数为this指向，之后的参数为fn执行时的参数组成的数组，数组的每一项会和fn的每一个参数进行对应 bind在执行时，第一个参数为预先传入this指向，之后的参数为实际调用fn前预先传入的参数，返回值为一个函数fixedThisFn，fixedThisFn内部会调用fn并指定其this指向 promiss和async函数1 promiss用法12345678let p = new Promiss((resolve)=&gt;{ console.log(11) resolve(22)})// .then的data是resolve里的，只有调用resolve才会执行.thenp.then((data)=&gt;{ console.log(data)}) 2 async函数12345678910111213async functin fun(){ return 1}console.log(fun()) // 返回一个promiss// ------------- 上面这代码和下面的代码等效 ----------------function fun(){ return new Promiss((resolve)=&gt;{ resolve(1) })} 3 async awaitawait 后面是一个promiss对象，可以拿到resolve的值 1234567891011let p1 = new Promiss((resolve)=&gt;{ resolve(1)})let p1 = new Promiss((resolve)=&gt;{ resolve(2)})async function fun(){ let a = await p1 let b = await p2 console.log(a,b) // 1,2} 4 手写promiss一个简单的 Promise 的粗糙实现，关键点在于 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败） Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。 设置两个队列，onResolvedCallbacks，onRejectedCallbacks，用于存放成功和失败的回调函数，当状态发生改变时依次从数组中取出执行。 利用setTimeout实现resolve和rejected异步 then返回promiss 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Prom { constructor(fn) { this.state = &quot;PENDING&quot; this.value = undefined this.reason = undefined // 保存尚未fulfilled的then中的回调函数(异步) this.onResolvedCallbacks = []; // 保存尚未rejected的then中的回调函数(异步) this.onRejectedCallbacks = []; const resolve = value =&gt; { setTimeout(() =&gt; { this.state = &quot;RESOLVED&quot; this.value = value // 判断成功回调是否存在，如果存在就调用 // 循环回调数组. 把数组前面的方法弹出来并且直接调用 while (this.onResolvedCallbacks.length) { this.onResolvedCallbacks.shift()(value) } }) } const reject = reason =&gt; { setTimeout(() =&gt; { this.state = &quot;REJECTED&quot; this.reason = reason while (this.onRejectedCallbacks.length) { this.onRejectedCallbacks.shift()(reason) } }) } fn(resolve, reject) } then(onFulfilled) { // 当传入的then回调函数为空的时候。。创建对应的空函数 onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : () =&gt; { } if (this.state === &quot;RESOLVED&quot;) { const result = onFulfilled(this.value); // 需要返回一个 Promise // 如果状态为 resolved，直接执行 return Prom.resolve(result); } // then方法执行时如果状态是等待态，就将其回调函数存入对应数组 if (this.state === &quot;PENDING&quot;) { return new Prom((resolve, reject) =&gt; { // 新增等待态判断，此时异步代码还未走完，回调入数组队列 this.onResolvedCallbacks.push(onFulfilled) }); } } catch(onRejcted) { onRejcted = typeof onRejcted === &quot;function&quot; ? onRejcted : () =&gt; { } if (this.status === &quot;REJECTED&quot;) { const reason = onRejcted(this.reason); return Prom.reject(reason); } if (this.status === &quot;PENDING&quot;) { return new Prom((resolve, reject) =&gt; { // 新增等待态判断，此时异步代码还未走完，回调入数组队列 this.onRejectedCallbacks.push(onRejcted) }); } }} 可枚举、不可枚举对象的属性所有的特性有以下几种： 1234567value:属性的值writable:如果为false，属性的值就不能被重写。get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。set:一旦目标属性被赋值，就会调回此方法。configurable:如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被无效化。### enumerable:是否能在for...in循环中遍历出来或在Object.keys中列举出来。 其中enumerable表示可枚举特性(true为可，false为不可)。 对象拷贝基本类型存储在栈内存中，对象存储在堆内存中 1 浅拷贝1234567function copy(obj){ let newObj = {} for(let i in obj){ newObj[i] = obj[i] } return newObj} 缺点：对象的属性只能是基本类型，不能是对象，所以该方法只能进行浅拷贝 2 深拷贝（对象里面包含对象的拷贝）1234567891011function copy(obj){ let newObj = {} for(let i in obj){ if(obj[i] instanceof Object){ newObj[i] = copy(obj[i]) }else{ newObj[i] = obj[i] } } return newObj} 3 对象的拷贝 方法一 Object.assign() 123456const person = { name: 'Wes Bos', age: 80 };const cap2 = Object.assign({}, person, { number: 99, age: 12 });console.log(cap2); // Object {name: &quot;Wes Bos&quot;, age: 12, number: 99} 方法二 JSON 转换 12345678910const wes = { name: 'Wes', age: 100, social: { twitter: '@wesbos', facebook: 'wesbos.developer' }};const dev2 = JSON.parse(JSON.stringify(wes));console.log(dev2); 防抖节流防抖防止触发事件过于频繁，只执行最后一次 1 手写防抖1234567891011121314151617let inp = ducoment.querySelector('input')inp.onchange = debounce(function(){ console.log(this.value)},500)function debounce(fn,delay){ let t = null return function(){ if(t !== null){ clearTimeout(t) }else{ t = setTimeout(()={ fn.call(this) },delay) } }} 2 防抖应用场景 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖 文本编辑器实时保存，当无任何更改操作一秒后进行保存 节流控制执行次数 1 手写节流1234567891011121314151617let inp = ducoment.querySelector('input')window.onscroll = throttle(function(){ console.log(&quot;滚动&quot;)},delay)function throttle(fn,delay){ let flag = true return function(){ if(flag){ setTimeout(()={ fn.call(this) flag = true },delay) } flag = false }} 2 节流应用场景 scroll 事件，每隔一秒计算一次位置信息等 浏览器播放事件，每个一秒计算一次进度信息等 input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖) 总结 (简要答案) 防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。**代码实现重在清零 clearTimeout**。防抖可以比作等电梯，只要有一个人进来，就需要再等一会儿。业务场景有避免登录按钮多次点击的重复提交。 节流：控制流量，单位时间内事件只能触发一次，与服务器端的限流 (Rate Limit) 类似。**代码实现重在开锁关锁 timer=timeout; timer=null**。节流可以比作过红绿灯，每等一个红灯时间就可以过一批。 debounce: Grouping a sudden burst of events (like keystrokes) into a single one. throttle: Guaranteeing a constant flow of executions every X milliseconds. Like checking every 200ms your scroll position to trigger a CSS animation. ES6 filter函数1234567const a = [1,2,3,4,5]// cur 当前值； idx 当前值的下标； arr 数组对象const b = arr.filter((cur,idx,arr)=&gt;{ return cur&gt;3})console.log(a) //12345console.log(b) // 45 forEach 和map区别 forEach 没有返回值 不会被break打断 遍历的是value map 有返回值，返回是数组，默认返回值是undefined 不会被break打断 遍历的是value和key ES6 解构数组结构12345678910let list = [3, 5]let first = list[0]let second = list[1]let [first, second] = list;// 解构中交换数据let car1 = 'bmw';let car2 = 'audi'[car2, car1] = [car1, car2] 对象解构12345678910111213141516171819const family = { father: '' mother: ''}const { father, mother } = family;// 解构对象并重命名变量const { father: f, mother:m } = {father: '1',mother: '2'}console.log(f); // '1'// 函数解构const family = { father: 'baba', mother: 'mama'}function log({ father }) { console.log(father)}log(family) // baba 正则表达式常用的正则表达式有哪些？1234567891011121314// （1）匹配 16 进制颜色值var regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;// （2）匹配日期，如 yyyy-mm-dd 格式var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;// （3）匹配 qq 号var regex = /^[1-9][0-9]{4,10}$/g;// （4）手机号码正则var regex = /^1[34578]\\d{9}$/g;// （5）用户名正则var regex = /^[a-zA-Z\\$][a-zA-Z0-9_\\$]{4,16}$/; 虚拟列表类数组转化为数组的方法题目描述:类数组拥有 length 属性 可以使用下标来访问元素 但是不能使用数组的方法 如何把类数组转化为数组? 实现代码如下: 123456789101112const arrayLike=document.querySelectorAll('div')// 1.扩展运算符[...arrayLike]// 2.Array.fromArray.from(arrayLike)// 3.Array.prototype.sliceArray.prototype.slice.call(arrayLike)// 4.Array.applyArray.apply(null, arrayLike)// 5.Array.prototype.concatArray.prototype.concat.apply([], arrayLike) 为什么0.1+0.2 ! == 0.3，如何让其相等在开发过程中遇到类似这样的问题： 123let n1 = 0.1, n2 = 0.2console.log(n1 + n2) // 0.30000000000000004复制代码 这里得到的不是想要的结果，要想等于0.3，就要把它进行转化： 12(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入复制代码 toFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？ 计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？ 一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。 根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。","link":"/myblog.github.io/2022/05/26/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-JS%E3%80%91%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"记录第一次vue-nodejs-mongodb项目服务器部署","text":"记录自己第一次部署项目，中间遇到很多errors，但好在花了两天时间成功部署了。先放出部署成功的项目链接 👉👉👉 师大Buy 校园闲置交易平台 👈👈👈 （先注册一个账号使用即可体验） 流程本项目包含三个子项目 前台展示 后台管理 后端nodejs服务器+mongodb数据库 大概流程 开发好前端与后端程序 购买服务器（和域名） 安全组、开放端口与设置规则 xshell操作 服务器上安装 和配置node，mongodb 所需环境 nginx设置代理 上传项目代码到服务器上 启动 express 服务器 购买服务器我的服务器信息： 腾讯云轻量服务器 运算组件：2核CPU、2GB内存 (通用型-2核2G-40G-300G) 系统盘：40GB SSD云硬盘 (通用型-2核2G-40G-300G) 流量包：300GB/月流量包 (通用型-2核2G-40G-300G) 地域：上海 镜像：CentOS 8 买好服务器后可以进入控制台，对服务器进行操作。可以尝试一下开机关机，之后最重要的是重置密码，这个密码后面通过xshell登录的时候经常用到，所以要记住。 安全组、开放端口与设置规则在腾讯云控制台的搜索框中搜索安全组，打开云服务器 -网络安全-安全组。里面可以设置一些安全组规则，意思就是这里可以打开一些端口，以便项目使用。 一开始可以新建安全组，使用一些默认的安全组规则。下面这张图展示就是默认的安全组规则，可以看到他已经放通了22,80等端口可以使用。 本项目中的三个项目分别使用了8080（前台），9528(后台)，3000（后端），27017（数据库）端口，所以要用到这些端口，我们就得自己去开放，因为默认的安全组这些端口是没有开放的。 开放这些端口的时候，需要在安全组里添加（可以在原来默认的安全组里新添，也可以新建安全组），也需要在服务器的防火墙里添加，只有这两个地方都放通了，端口才能访问。 登录和操作服务器xshell操作我电脑是windows系统，所以安装了xshell来登录服务器。如果是 mac系统，好像可以直接在终端，通过ssh root@公网IP命令行连接到服务器。因为我没用过，所以这里只讲xshell如何登录和操纵。 安装xshell的时候记得顺带安装xftp，可以用来上传文件，不仅如此，我还发现可以用来浏览文件夹，甚至修改编辑文件，很好用！ 打开xshell的时候，会弹出一个会话框，选择新建一个会话，然后命名一下，点击连接，这时候会弹出一个输入密码的对话框，输入一开始你在浏览器上的服务器控制台上重置的密码，就登录了。 centos是基于linux建立的操作系统，所以用的指令和linux一样。而linux指令其实和DOS是一样的，只是命令的表达上可能有点儿不一样，所以遇到这个黑框不要害怕。 下面说一下xshell里面常用的linux指令 12345cd 进入目录ls 查看当前目录下的文件mkdir 创建文件夹mv 移动或重命名rm -rf 删除整个文件夹 大概知道这些你就有了部署项目的基础了，中途如果遇到其他的需要，可以上网查看。 你可以先试试ls，看看当前文件夹里有什么文件，这感觉就好像是在windows系统上浏览文件夹，只不过在windows上是可视化的操作界面。 xftp使用xftp是个很好用的可视化界面，一开始我是看别人说用来上传文件的，但是后来我用的时候，我发现它很好用来浏览文件，找回了使用windows一样的感觉。 当你进入xftp软件的时候，首先也会弹出一个会话框，新建会话，重命名，然后连接，输入密码。和使用xshell一样。 要传什么文件给服务器，先在右框中选择文件夹（新建文件夹），找好存放的位置后，在左框中浏览你电脑的文件，找到对应的文件后右键 传输。 值得注意的是，在连接服务器后，初始文件夹的位置是/root，你可以从xftp软件的右框中看到，也可以在xshell里面ls看到。 在xftp软件上右框的文件夹中有 … (三个点)，点击一下，可以返回上一级，你会发现，这里有很多初始文件夹。知道这些文件夹的存在，对于我们下一步的操作很重要，这里暂时放开，我们继续后面。 服务器上安装node，mongodb浏览到这里，我们已经知道一些基本的xshell指令，知道如何通过xshell登录服务器，通过xftp上传文件。下面我们开始在服务器上安装项目所需环境。 一般在新服务器创建后，建议先升级一下 CentOS： 1yum -y update 在升级之后，我的yum指令就下载不了东西了，报错Fix Failed to download metadata for repo，解决办法是 Step 1: Go to the /etc/yum.repos.d/ directory. 1[root@autocontroller ~]# cd /etc/yum.repos.d/ Step 2: Run the below commands 12[root@autocontroller ~]# sed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-*[root@autocontroller ~]# sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-* **Step 3:**现在yum就可以使用了 nodejs网上的博客描写安装Nodejs很多，甚至还不一样，很容易踩坑，但是我推荐看这篇博客，另外我也在这讲一下步骤。 123456789101112131415161718192021222324252627# 1 安装wgetyum -y install wget# 2 切换到/usr/local/src目录，选择这个文件夹存放nodejscd /usr/local/src# 3 去nodejs下载官网复制下载链接，我的服务器是centos 8, 64位，所以我选择了https://nodejs.org/dist/v16.15.1/node-v16.15.1-linux-x64.tar.xz# 4 使用 wget 安装方式wget https://nodejs.org/dist/v16.15.1/node-v16.15.1-linux-x64.tar.xz# 这时候这个压缩包就在当前文件夹下，现在需要解压它# 5 解压xz -d node-v16.15.1-linux-x64.tar.xztar -xvf node-v16.15.1-linux-x64.tar# 6 建立软连接ln -s /node-v16.15.1-linux-x64/bin/node /usr/local/binln -s /node-v16.15.1-linux-x64/bin/npm /usr/local/bin# 这时候你可以切换到/usr/local/bin目录，看看有没有npm，node文件夹，有的话说明成功了# 7 试试node,npms是否能使用node -vnpm -v# 打印出了版本好就说明没问题 mongodb推荐看官网的步骤 （有官方看官方，否则看别人的博客很容易踩坑） 官网给出了如何在centos上下载mongodb 5，我也在这里写出步骤 1 配置yumxftp的作用来了，打开该软件，在/etc/yum.repos.d文件夹下创建mongodb-org-5.0.repo文件，选择记事本打开，粘贴下面代码 123456[mongodb-org-5.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/5.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-5.0.asc 这个操作就好像告诉yum去指定的baseurl去下载资源，不配置的话yum不指导哪里找资源下载。 2 安装mongodb安装包1yum install -y mongodb-org 3 验证安装结果1rpm -qa |grep mongodb 如果输出很多Mongodb相关的包时，说明你的服务器已经有这些包了 4 data目录和log目录默认情况下，MongoDB 会创建一下mongod用户，该用户会使用data和log目录 /var/lib/mongo (the data directory) /var/log/mongodb (the log directory) 我们这里就使用它默认的一个位置来存放mongodb的data和log。 5 启动MongoDB服务1systemctl start mongod.service 我这里启动报错，后来我看到了这篇文章，（看高赞回答），我发现权限错误，我的/tmp/mongodb-27017.lock所有者是root，需要改为mongod。 permission settings on /var/lib/mongodb and /tmp/mongodb-27017.lock are wrong. You will have to change the owner to monogdb user 在xshell输入一下指令即可 12chown -R mongod:mongod /var/lib/mongodbchown mongod:mongod /tmp/mongodb-27017.sock 6 验证服务开启1234执行: mongo输出： MongoDB shell version v5.0.9connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb 到现在我们已经完成了部署难点的很大一部分。下面我们看看怎么在服务器运行我们三个项目 nginx设置代理不需要懂nginx原理，我们可以先使用它看看。 参考这篇文章，我这里也引用一下 先查看服务器是否有nginx1whereis nginx 安装nginx1yum install -y nginx 查看nginx安装目录命令如下： 1whereis nginx 启动nginx启动 1nginx 直接输入nginx即可启动服务，打开浏览器，访问服务器公网地址，出现如下界面则代表启动成功。 这里访问默认的是80端口，因为nginx服务就是默认的80端口，如果不能访问，大致有几种原因： nginx未启动 服务器安全组未加入80端口 nginx配置错误 停止 停止nginx服务，命令如下： 1nginx -s stop 此时访问浏览器则无法访问。 重启 重启nginx服务，一般用于修改配置文件之后，命令如下： 1nginx -s reload 配置nginxnginx启动后，在浏览器上输入公网地址，就可以打开默认的一个html页面。 但是这个页面和端口都是默认的，如果需要显示我们自己的页面，就需要配置nginx，配置文件为/etc/nginx/nginx.conf，使用xftp找到该文件夹，并打开编辑。 也可以在xshell上cd找到并vim打开，但是这个很不方便，不能快速复制粘贴和定位。所以推荐使用我用xftp发现的隐藏功能。 在配置文件中，重点看server 对象，要改的也是这个对象，我的配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114 # 默认端口 server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } }# 前台展示的打开的服务代理server { listen 8080; server_name localhost; root /root/lan/schoolstore/frontshop/dist; # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; location / { root /root/lan/schoolstore/frontshop/dist; index index.html; try_files $uri $uri/ @router; autoindex on; } location @router{ rewrite ^.*$ /index.html last; } location /api/ { proxy_set_header X-Real-IP $remote_addr; proxy_pass http://0.0.0.0:3000; } gzip on; gzip_buffers 32 4k; gzip_comp_level 6; gzip_min_length 200; gzip_types text/css text/xml application/javascript; gzip_vary on; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } }# 后台管理的服务代理server { listen 9528; server_name localhost; root /root/lan/schoolstore/cms/dist; # Load configuration files for the default server block. # include /etc/nginx/default.d/*.conf; # 找到要渲染的页面 location / { # try_files $uri $uri/ /index.html; root /root/lan/schoolstore/cms/dist; index index.html; try_files $uri $uri/ @router; autoindex on; } # 找到路由 location @router{ rewrite ^.*$ /index.html last; } # 后端数据 location /api/ { proxy_set_header X-Real-IP $remote_addr; proxy_pass http://0.0.0.0:3000; } gzip on; gzip_buffers 32 4k; gzip_comp_level 6; gzip_min_length 200; gzip_types text/css text/xml application/javascript; gzip_vary on; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 主要就是修改root 和 location。 我开了两个代理的：前台展示打开的服务代理8080，和管理后台打开的服务代9528，这个项目是分开端口访问的。修改配置文件后 执行 nginx -s reload，如果项目已经上传，理论上访问ip:8080可以打开前台展示项目，访问ip:9528，可以打开后台展示项目。但是我们现在没讲到上传文件。所以会访问不成功，而80端口我还保留了默认的页面，还是可以访问到的，不妨试一试。 上传项目代码到服务器主要有三个项目的文件需要上传：前台，后台，后端 我们先把后端部署好，前台上传比较容易，并且后端部署好后，前台部署可以拿到数据。 在服务器上使用nodejs不着急直接上传nodejs文件，我们先看看服务器上nodejs怎么使用，因为一开始对于一个服务器小白来说，我们要上传什么东西都不知道，要不要打包也不知道，上传后端和前台一样也不知道。所以带着这些疑问，我们先上网搜搜，怎么在服务器上使用nodejs。 参考文章 ，主要看【步骤二：部署测试项目】，本文这里也给出步骤，主要是参考了这篇文章。 1 打开vscode，在自己电脑里新建一个example.js文件，复制一下代码，然后node example.js就可以在http://localhost:3000/看到·`hello word` 123456789101112const http = require('http');const hostname = '0.0.0.0';const port = 3000;const server = http.createServer((req, res) =&gt; { res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\n');}); server.listen(port, hostname, () =&gt; { console.log(`Server running at http://${hostname}:${port}/`);}); 这是在自己电脑运行的效果，现在我们要想这个example.js文件放到服务器上，然后再服务器上运行，最后在自己电脑的浏览器上输入对应网址，可以看到同样的hello world。 2 把example.js文件通过xftp上传到服务器上的/root文件夹下。然后再xshell中切换到该文件夹。通过ls指令可以看到该js文件，输入一以下指令运行该js文件。（和在自己电脑的控制台上一样） 1node example.js 打开浏览器并访问http://&lt;ECS实例公网IP地址&gt;:&lt;项目端口号&gt;。本示例中，&lt;项目端口号&gt;为3000。你会发现该文件运行了同样效果。 这就是node在服务器上的使用，总的来说，其实和在自己电脑运行一样，也就是说我们要把js文件上传到服务器，如果项目大的话，会有很多文件夹，还会有node modules，所以这些也要上传。这些文件都有，node js文件就可以运行了！ 在服务器上部署Node.js + MongoDB 项目我的后端项目还用到了数据库，刚才我们只学到node项目怎么部署，但是node+mongodb呢？现在我们来看看 参考教学视频 下面的讲解是假设你已经知道了怎么在自己电脑上开发node+mongodb项目，如果不知道建议先掌握这部分知识，再来看服务器上的部署。 重点是在node 项目文件里设置Mongodb数据库连接，这个链接怎么看呢？在xshell里输入mongo就可以看到， 图中红色框就是你的数据库的连接地址。但是在node项目里，？后面的字符串不需要写进入，同时还要也一个明确的数据库名称，我的数据库连接如下图所示。 处理好mongodb的连接地址，下面的步骤其实和Node项目一样，接下来我们真正开始讲解本项目的部署。 上传本项目后端代码有的博客说可以用git上传，大概的意思就是服务器其实也是一台电脑，在这台里面通过git拉取项目，前提是你已经在自己的电脑里把项目文件git到了github上。但是这样很复杂，服务器这台电脑还需要配置git使用，不然就会没有权限，拉取不到项目文件。我弄了一会没弄出来我就另辟蹊径了。 我的方式： 1 在自己电脑里把项目上传到github上，忽略node modules等开发文件，(我的电脑使用git很久了，已经配置好了，如果第一次使用，也是要配置的，但是在可视化的windows上配置应该比centos上配置容易点)。 2 上传之后在git clone拉取下来 3 把新文件同xftp上传到服务器上 4 xshell切换到项目文件下，输入node install下载项目所需包 5 node server.js文件运行即可 pm2使用 PM2 是一个守护进程管理器，它将帮助您管理和保持您的应用程序在线 其实说到这里后端项目就已经部署好了，但是很多博客都介绍了pm2这个工具，这个工具可以替代node server.js，同样让后端启动，但是不同的是，pm2的使用可以保证项目永久运行在服务器上，且不会一报错后端服务器就挂了，而且运行中还可以进行其他操作。 1 安装 1npm install -g pm2 2 切换当前工作目录到项目server.js文件夹中，执行指令 1pm2 start server.js pm2的其他操作 12pm2 stop server.js // 关闭pm2 list //查看所用已启动项目 到现在为止后端已经部署完毕了 上传本项目前端代码前端代码上传比较容易，参考文章 我的项目是vue项目，所以npm run build打包出一个dist文件夹即可。然后把这个文件夹上传到服务器。此时无需重启nginx，刷新浏览器，可以看到我们的网站已经部署成功了 前台 后台 本项目有关地址部署项目重点参考了三篇文章 1 服务器小白的我,是如何成功将 node+mongodb 项目部署在服务器上并进行性能优化的 2 记录react+node+mongodb项目部署到服务器的过程 3 前端Vue项目打包部署实战教程 非常推荐看这三篇，少走很多弯路。 我的个人博客地址，里面偶尔会做一些笔记 https://janice143.github.io/myblog.github.io/ 本项目部署地址 http://101.34.27.188:8080/#/home 我的github项目 https://github.com/janice143?tab=repositories 一些bug清单，附带解决问题的网站 1 nginx配置500内部错误 2 ECS服务器部署Nodejs出现错误Error: Listen EADDRNOTAVAIL 3 mongodb的导入json文件 mongoimport --jsonArray --db schoolstore --collection categories --file cat.json 4 linux服务器升级后，yum安装出错 前端小菜鸟，研二在校生（马上要研三了），非科班，物电学院，专业你猜 大二接触前端，但是有了专业课老师上课要抽同学讲课，然后我就学了一下简单的三件套，做了个转盘抽签网页，没做出来，但是我再网上找了代码改了改弄出来了。这是我第一次的前端开发 😁😁😁 大二大三是人生巅峰，拿国奖，发SCI了，觉得自己有搞研究的天分，准备本专业考研了。 到了研究生发现自己不适合读博，想找工作，不想当物理老师，不想从事本专业，然后又开始拿起前端三件套，进阶前端之路了。I have no idea what I’m doing… 最近提前批、秋招要来了，好紧张，我要冲去找工作了！ 祝我好运！ have fun here! 对了，后面还有很多文章想写的，等我有时间都会给它写了！","link":"/myblog.github.io/2022/06/21/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1vue-nodejs-mongodb%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"},{"title":"git 多人协作流程","text":"基本指令123456789101112131415161718192021222324252627git clone *** # 下载远程仓库的代码git branch develop master # 从master分支上新建develop分支git checkout develop # 切换到develop分支# 此处可进行功能开发，并add和commit到develop分支在多人协作中，可以新建自己的分支，git checkout -b dev1在这条分支上开发完后，可以把这条分支合并到develop分支上，git checkout develop // 切换到develop分支git merge dev1 // 合并dev1很多时候合并会报错，因为很有可能团队其他人也在develop分支上进行修改了，这时候需要拉取远端的代码，查看更新，解决冲突git pull origin develop # 更新远端代码，看develop分支是否有更新（无更新）检查没问题后，提交到远程仓库git add . git commit -m &quot;message&quot;git push origin develop # 推送develop分支到远端的origin/develop一般来讲，在push之前最后pull一下当你完成一个develop分支的代码更新之后，你再次回到dev1分支，或者新建其他分支，继续完善项目，首先你需要git pull origin develop拉取最新的代码 参考博客 图文详解如何利用Git+Github进行团队协作开发 使用Git进行多人协作开发 详细步骤版1、首先，你需要在远程仓库创建一个新的项目（github、gitee或是你自己的远程服务器），这个新的项目默认会有一个主分支 master,现在你需要新建一个 dev 分支，这个dev分支就是所谓的主战场，在以后的开发中，就在这个dev以及dev下的分支进行开发。 2、然后使用git命令***git clone***到一个空的文件夹 3、克隆下来的这个项目相当于你在远程创建的那个项目的镜像，所以现在你本地的项目里也有个dev分支，当然也有master分支，现在切换到dev分支 *git checkout dev* 4、现在就可以在这个dev分支上新建自己的分支愉快的开发了，命令 *git checkout -b dev1* 5、由于是多人开发，另一个人也可以以同样的方式（经历2、3、4步骤后）新建一个自己的分支dev2 命令*git checkout -b dev2* 6、在dev1 或 dev2 开发完成后，需要提交到本地仓库，在dev1分支下使用命令 git add . 和 git commit -a -m ‘commit msg’ 7、提交完之后，需要汇总到dev分支上，先切回dev分支，命令***git checkout dev***，这个时候是没有你在dev1上修改或添加的东西的，需要合并之后才会有； 8、合并 在dev分支下使用命令 *git merge dev1* 现在就可以在dev分支下看到你在dev1分支下修改的东西了 9、提交 合并到dev分支之后就是提交到远程仓库的dev分支，可以先看一下现在都有什么分支，命令 *git branch -a* 10、提交到远程dev 命令 *git push origin dev* 11、现在远程仓库的dev分支上已经是最新的代码了；最后再把远程的dev分支合并到远程的master主分支上就可以了。一般主分支主要是存放比较稳定版本的版本，dev分支才是最活跃的。","link":"/myblog.github.io/2022/08/17/git-%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B/"}],"tags":[{"name":"原生javascript项目","slug":"原生javascript项目","link":"/myblog.github.io/tags/%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE/"},{"name":"JS30;30个原生javascript项目","slug":"JS30-30个原生javascript项目","link":"/myblog.github.io/tags/JS30-30%E4%B8%AA%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE/"},{"name":"JavaScript","slug":"JavaScript","link":"/myblog.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","link":"/myblog.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/myblog.github.io/tags/CSS/"},{"name":"JavaScript知识点","slug":"JavaScript知识点","link":"/myblog.github.io/tags/JavaScript%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"Node.js","slug":"Node-js","link":"/myblog.github.io/tags/Node-js/"},{"name":"ejs.js","slug":"ejs-js","link":"/myblog.github.io/tags/ejs-js/"},{"name":"vuejs","slug":"vuejs","link":"/myblog.github.io/tags/vuejs/"},{"name":"js","slug":"js","link":"/myblog.github.io/tags/js/"}],"categories":[{"name":"30个原生javascript项目","slug":"30个原生javascript项目","link":"/myblog.github.io/categories/30%E4%B8%AA%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE/"},{"name":"LeetCode","slug":"LeetCode","link":"/myblog.github.io/categories/LeetCode/"},{"name":"前端面试基础","slug":"前端面试基础","link":"/myblog.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"node.js","slug":"node-js","link":"/myblog.github.io/categories/node-js/"},{"name":"ejs.js","slug":"ejs-js","link":"/myblog.github.io/categories/ejs-js/"},{"name":"vue","slug":"vue","link":"/myblog.github.io/categories/vue/"},{"name":"js","slug":"js","link":"/myblog.github.io/categories/js/"}]}
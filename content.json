{"pages":[],"posts":[{"title":"【python】清理重复图片","text":"引言本文解释如何编写python脚本，实现重复图片清理的功能。 正文MD5,Message-Digest Algorithm，信息摘要算法，是一种信息加密算法，可以把任意长度的数据转换为一个长度固定的数据串（通常是16进制的字符串表示）。一个图片文本的本质是一个数据串，所以要想清理重复图片，就是要匹配到相同的数据串的两张图片，使用DM5的目的是将图片的数据串统一，如果两张图片经过MD5算法变换后的数据串相同，则可判断这两种图片重复。 以计算一个字符串的MD5值为例，代码如下： 12345import hashlibmd5 = hashlib.md5()md5.update('how to use md5 in python hashlib?'.encode('utf-8'))print(md5.hexdigest()) 计算结果为 1d26a53750bc40b38b65a520292f69306 参考网站：廖雪峰老师博客中摘要算法简介 本文的脚本的思路如下：1 遍历文件夹下的图片文件2 把图片文件记录到一个字典变量中3 生成所有图片文件的MD5值4 把MD5值存放到一个新的字典变量中5 判断如果已经存放，则该图片为重复图片，删除即可 选取文件夹，遍历文件夹下所有的文件123456inpath = &quot;G:/最新/照片/2018-2019年照片备份/2021年&quot;for path,dir,filelist in os.walk(inpath): for filename in filelist: # print(filename) allfile.append(os.path.join(path,filename)) 获取MD5值123456fd = open(file,'rb')md5 = hashlib.md5()md5.update(fd.read())fd.close()return md5.hexdigest() 根据MD5值比较123456for photo in allfile: md5sum = getmd5(photo) if md5sum not in md5list: md5list.append(md5sum) else: identicallist.append(photo) 删除重复照片12for idenPhoto in identicallist: os.remove(idenPhoto) 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/09/02/%E3%80%90python%E3%80%91%E6%B8%85%E7%90%86%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87/"},{"title":"配置连接github","text":"复制代码配置身份，不正确会影响贡献度统计 12git config --global user.email &quot;A175A174@gmail.com&quot;git config --global user.name &quot;A175A174&quot; 配置 ssh 链接，一路回车，打开提示目录下 id_rsa.pub复制到 https://github.com/settings/keys 点击 New sshKey，Title 可以不写 1ssh-keygen -t rsa -C &quot;A175A174@email.com&quot; 验证 ssh 是否成功Hi A175A174! You’ve successfully authenticated, but GitHub does not provide shell access 1ssh -T git@github.com","link":"/myblog.github.io/2021/08/20/%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5github/"},{"title":"【程序】我是如何建立我的第一个博客网站的？","text":"写在前面我从大二开始喜欢上写程序，也从那开始自学了很多编程语言。当我第一次接触到前端开发的时候，那些由多个不同后缀名组成的项目，让我觉得又新奇（第一次见这种编程语言，太有特色了），同时又恐惧（这么多个编程语言组成，我能学会吗）。 大二是我人生阶段最迷茫的一段时间，不想上课，不想和人交往。但是我生来好像就有股向上的劲头，即使每天很颓废，也告诫自己做点有用的事情，做点有用的事情。所以我那段时间学了很多编程语言，虽然是迷迷糊糊学了很多语言，走了很多弯路。 好在我也勉勉强强地学了前端开发，我记得那段时间我先是在网上看了一个教学视频，然后就开始自己动手捣鼓做起了第一个个人网站，花了一天一夜的时间。 大三开始我稳定地在实验室跟着一个老师做科研，便没有时间再去学写程序。 大四基本上是在做创新创业比赛，更没有时间写程序了。 但是大二以后的整个过程，我总是偶尔地问自己：当初我为何要学写这么多程序？我大二整整一年的时间都花在自学程序上，感觉就这么放弃有点太不值得？自学程序有用吗以后？ 现在我也不知道学的程序有没有用，但是就是因为当初花了一年时间起步，不甘心没有一点收获地戛然而止。所以我，到了大四暑假的末尾，研一马上要开学，要重新拾起我以前学的东西，好好做下去，希望能做出点东西。 自学编程的时候听到最多、最有用的建议就是要多做实战，而对于前端开发来讲，第一个要做的实战就是建立自己的个人网站，第二个就是建立个人博客。所以在建立好自己的第一个网站，一年后，也就是现在，我开始建个人博客，并且立下不倒的flag，这个网站将会见证我一点一滴的成长（未来我的生活琐事，学习曲线等奖全部记录记录在这里），是我人生中一笔宝贵的财富，我一定会好好经营。 正文一、找资料一般开始一个新东西，第一步肯定是找资料，毕竟光想是想不出来的。我找的第一个资料就是B站Up主CodeSheep的一个视频手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo：https://www.bilibili.com/video/BV1Yb411a7ty 在看这个视频的过程中，我有很多疑惑（为什么要下载node.js,在cmd下建文件夹是怎么回事等等），所以也会找其他资料使用hexo+github搭建免费个人博客详细教程：https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.htmlhexo5分钟免费搭建个人博客教程：https://www.jianshu.com/p/722fe57ef163 结合视频，以及文本资料，我的很多疑惑都消除了，接下来我便可以自己动手尝试了。 二、下载软件，准备环境1.安装好node.js（最好下载Windows 安装包 (.msi)，在安装过程中会配置好路径，用zip文件还要自己手动配置，特别容易报错） 和 Git 2.在das窗口下输入命令 node -v和 npm -v，检验hexo运行环境 3.git安装完成后的检验操作是：鼠标右键。会出现git GUI here 和git bash here 三、使用hexo框架搭建静态博客1.安装 hexo 框架 1npm install -g hexo 2.在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\\程序\\html_codes\\janiceBlog，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 3.cmd窗口下切换到janiceBlog文件夹路径，然后输入一下代码： 1hexo init # 初始化 hexo会自动下载一些文件到这个目录，包括node_modules 12hexo g # 生成hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。hexo s是开启本地预览服务，打开浏览器访问http://localhost:4000即可看到内容 4.修改主题可以再官网选一个好看的主题以yilia主题为例，在博客路径下，输入一下命令: 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布 四、上传到github1.配置_config.yml中有关deploy的部分： 1234deploy: type: git repository: git@github.com:janice143/iainsBlog.git branch: master 2.打开博客文件夹，右键选择git bash here，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会(部署这个命令一定要用git bash,不要在cmd下，不然会报错) 五、上传到GitHub出现一些错误错误1： hexo + github pages搭建博客，本地server成功，部署到github上之后样式加载不出来解决：需要修改根目录_config.yml文件中的url地址和根目录 123456##If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://janice143.github.io/myblog.github.io/root: /myblog.github.iopermalink: :year/:month/:day/:title.htmlpermalink_defaults: url 是GitHub pages给我们分配的网址root是搭建该博客的仓库名 最后重新部署上传就可以了 123hexo cleanhexo ghexo d 错误2：修改默认头像解决：在主题的yilia文件夹的img文件夹里放上头像图片，然后修改yilia文件夹下的_config.yml文件 12#你的头像urlavatar: /myblog.github.io/img/me.JPG 六、写博客1.定位到我们的博客目录，执行命令： 1hexo new “博客名自己取” 2.markdown格式编写规则参考：http://www.mdeditor.com/","link":"/myblog.github.io/2020/09/11/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%EF%BC%9F/"},{"title":"【原生javascript项目】Real time clock 02","text":"引言本文利用javascript写一个实时显示时间的时钟特效网页。 网址为(https://janice143.github.io/realTImeClock/) 正文1网页布局与功能 网页主体为一个时钟，具有表盘（12个数字）和三个指针（时针、分针、秒针）。 2实现原理一、 html代码 使用一个类名为clock为的div容器，里面包含时针.hour-hand,分针.minute-hand,秒针second-hand，以及12个数字。 12345678910111213141516171819202122&lt;div class=&quot;clock&quot;&gt; &lt;div class=&quot;hour-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;minute-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;second-hand hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;number&quot;&gt; &lt;span class=&quot;num12&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;num1&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;num2&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;num3&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;num4&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;num5&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;num6&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;num7&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;num8&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;num9&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;num10&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;num11&quot;&gt;11&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 二、css代码 1 先让时钟显示在页面的中部（垂直居中，水平居中），这可以用个在clock的上一级词main中设置flex容器。 12345678#main{ display: flex; min-height: 100vh; align-items: center; justify-content: center;} 2 时钟的表盘的样式 1234567.clock{ width: 300px; height: 300px; border-radius: 300px; border: 20px solid white; position: relative;} 3 指针的样式 指针旋转的特效是由transfrom：rotate(deg)实现的（本文这里是通过js代码后面再设置的）。transform-origin默认是50%，元素会绕着中间旋转，设置成100%后，元素绕着一端旋转。transition-timing-function是设置过渡的时间函数特效，不设置是默认均匀地过渡。 1234567891011121314151617.hand{ width: 120px; height: 6px; background-color: blueviolet; position:absolute; top:148px; right: 148px; transform-origin: 100%; transition:all 0.05s; transition-timing-function: cubic-bezier(0.1, 2.7, 0.58, 1);}.hour-hand{ width: 100px;}.second-hand{ height: 4px;} 4 12个数字的样式 先给数字设置相对定位，相对于上一级.number。然后再给每个数字设置相应的top和left. 数字位置算法为： num=2; top=135sin((num-3)30/180pi)+135； left=135cos((num-3)30/180pi)+135 （num为1-12的数字） 1234567891011.number{ width: 300px; height:300px; font-size: 15px; position:absolute; top:0px; right: 0px;} 三、 javascript代码 分别获取时针、分钟、秒针的类名，然后通过当前时间给三个指针分配正确的旋转角度。 1 秒针： parseInt(second/60*360)+90; 2 分针： parseInt(minute/(60)*360+second/10)+90; 3 时针：parseInt(hour/(12)*360+minute/(60)*30)+90; +90度是因为设置指针css样式的时候，指针都在指在9点钟的位置，+90度可让指针从12点为起始点旋转。 设置为指针的角度后，利用定时器每隔一秒刷新指针的位置，这样就可以达到实时显示的效果。 当指针转弯一圈后，重新运行设置时间函数 setDate()重置指针的角度。 123456789101112131415161718192021222324252627// 获取指针的transform样式，从而让其旋转 const secondHand = document.querySelector('.second-hand'); const minuteHand = document.querySelector('.minute-hand'); const hourHand = document.querySelector('.hour-hand'); const audio = document.querySelector('audio'); // 获取当前时间，从时间里设置指针 function setDate(){ const time = new Date(); const second = time.getSeconds(); const secondDeg = parseInt(second/60*360)+90; secondHand.style.transform = `rotate(${secondDeg}deg)`; const minute= time.getMinutes(); const minuteDeg = parseInt(minute/(60)*360+second/10)+90; minuteHand.style.transform = `rotate(${minuteDeg}deg)`; const hour= time.getHours(); const hourDeg = parseInt(hour/(12)*360+minute/(60)*30)+90; hourHand.style.transform = `rotate(${hourDeg}deg)`; } // 设置定时器美隔一秒时间进行刷新页面 setInterval(setDate,1000); // setDate(); // 当指针转一圈后，重置度数 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/12/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Real-time-clock-02/"},{"title":"【原生javascript项目】Image Procession with Javascipt 03","text":"引言本文利用javascripts更新css变量，实现一个简易的图像处理网页。对于图像处理部分，本网页可调节图像的边框宽度、模糊度以及边框颜色值。 网址为(https://janice143.github.io/imageProcessionwithJS/) 正文1 页面布局 页面分为三部分：标题、三个input组成的控件、图像 通过调节三个Input的值，可以实现对外边距、模糊值和颜色的改变。 一、html代码 1 标题 123456&lt;h2&gt;利用&lt;span class=&quot;text-color&quot;&gt;JS&lt;/span&gt;更新CSS自定义变量&lt;/h2&gt; &lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt;&lt;/div&gt; 2 三个input值 12345678910&lt;div class=&quot;controlers&quot;&gt; &lt;label for=&quot;spacing&quot;&gt;外边距:&lt;/label&gt; &lt;input id=&quot;spacing&quot; type=&quot;range&quot; name=&quot;spacing&quot; value=&quot;10&quot; data-unit=&quot;px&quot;&gt; &lt;label for=&quot;blur&quot;&gt;模糊值:&lt;/label&gt; &lt;input id=&quot;blur&quot; type=&quot;range&quot; name=&quot;blur&quot; value=&quot;10&quot; data-unit=&quot;px&quot;&gt; &lt;label for=&quot;color&quot;&gt;底色:&lt;/label&gt; &lt;input id=&quot;color&quot; type=&quot;color&quot; name=&quot;color&quot; value=&quot;#fecc00&quot;&gt;&lt;/div&gt; data-unit=”px”是自己设置的dataset(数据集合)。input的type类型和对应效果如图。 input的id名字一般和name一样。 3 图像 1&lt;img src=&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;&gt; 二、css代码 1 css变量 变量声明：在选择器里（任何选择器），变量名前面要加两根连词线（--）。本文里在:root根元素里声明，这是全局变量的声明方式，保证任何选择器都可以使用。变量名大小写敏感。 12345678img{ margin-top:50px; width:600px; height: 375px; padding: var(--spacing);/* var函数获取变量 */ background-color: var(--color); filter:blur(var(--blur));} 读取变量：利用var()函数读取 12345 :root{ --color:#fecc00; --spacing:10px; --blur:10px;} css变量参考网址：（https://www.ruanyifeng.com/blog/2017/05/css-variables.html） 三、javascript代码 1 suffix中文意思为 后缀。在js代码中，设置了一个suffix变量，这是因为spacing和blur的值在css中需要加上px单位，而color的值没有，所以使用了||逻辑运算。 2 this.dataset需要注意一下，在html代码中，我们设置了自定义了data-unit数据，this.dataset会取出所有自定义的数据集，比如你可以在Html中设置data-key(回想起前几天的js程序）,data-name,data-poo任何数据名字，因为是自定义。this.dataset.unit是本文在html代码中提前设置好的。 3 document.documentElement用来获取当前文档的直接子节点，对于Html文档而言，一般是。 4 style.setProperty(propertyName, value);给css样式某个属性名propertyName赋一个新值value。 5 --${this.name}为模板字面量，可以嵌入表达式的字符串字面量，${}表示一个占位符。一般的字符串是用单引号或者双引号标注的，这些字符串之间没有任何区别，而模板字面量则可以通过一个占位符来进行插值，模板字面量用反引号``实现。 6 箭头函数优点：剪短、this指向函数定义生效时所在对象。 函数声明：关键字、函数名、参数、函数体 123function functionName ([arg1 [,arg2 [...,argn]]]) { // functionBody 函数体} 没有函数名时，函数为匿名函数 1234const square = function (number) { return number * number;};// 相当于箭头函数：number=&gt;number*number; 具名函数由函数名，而且函数内部可以代指本身（迭代函数使用） 123const factorial = function fac(n) { return n &lt; 2 ? 1 : n * fac(n - 1);};console.log(factorial(3));var x = square(4);// x 得到的值为16 箭头函数；如果函数体只有一个表达式，可以不用{}符号 123const fn = () =&gt; { // do something}; 1234567// 获取Input的value，并且将value赋值给cssconst inputs = document.querySelectorAll('.controlers input');function updateValue(){ const suffix = this.dataset.unit || ''; // 给blur和spacing加单位 document.documentElement.style.setProperty(`--${this.name}`,this.value + suffix);}inputs.forEach(input=&gt;input.addEventListener('change',updateValue)); 结论完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/13/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Image-Procession-with-Javascipt-03/"},{"title":"【python】定时健康打卡网站打卡发送邮箱","text":"引言本文介绍如何编写python脚本，实现网站自动、定时健康打卡功能，打卡成功后截取当前屏幕信息，并通过发送邮件告知对方已经打卡成功。 正文思路：1 package 安装2 实现网站打卡功能3 保存当前网站截图4 发送邮件5 定时运行程序 package 安装Selenium安装 1pip install selenium ChromeDriver下载：下载与本机安装的Chrome浏览器的版本相同的ChromeDriver.exe，并放在python安装路径下的scripts路径下。 实现网站打卡功能打开浏览器，进入网站搜索 123browser = webdriver.Chrome()browser.get('这里填你要打卡的网站地址')time.sleep(2) 通过find_element_by_xpath来定位用户名和密码的输入框，并输入用户名和密码 1234uid = '你的用户名'pwd = '密码'browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[4]/input&quot;).send_keys(uid)browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[5]/input&quot;).send_keys(pwd) 通过find_element_by_xpath来定位登录输入框，并点击回车键 1browser.find_element_by_xpath(&quot;//*[@id='form1']/div[3]/div[7]/input&quot;).send_keys(Keys.ENTER) 点击健康打卡 123click_btn = browser.find_element_by_xpath(&quot;//*[@id='apply-content']/div[2]/ul[1]/li[2]&quot;)ActionChains(browser).click(click_btn).perform()# time.sleep(2) 点击填报 12click_btn2 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[4]/button&quot;)ActionChains(browser).click(click_btn2).perform() 点击 我知晓 12click_btn3 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[51]/div[1]/input&quot;)ActionChains(browser).click(click_btn3).perform() 点击上报 12click_btn4 = browser.find_element_by_xpath(&quot;//*[@id='form1']/div[52]&quot;)ActionChains(browser).click(click_btn4).perform() 截屏并保存，保存当前网站截图打卡成功后，我想保留当前网页的截图，作为打卡成功的凭证 1browser.get_screenshot_as_file(&quot;success.png&quot;) 退出浏览器 1browser.quit() 发送邮件通过发送邮件的方式，通知对方已经成功打卡。 准备用于发送信息、接收信息的邮箱 123MAIL_USER = &quot;邮箱地址&quot; # 用于发送通知的邮箱MAIL_PASS = &quot;授权码&quot; # 授权码，注意不是邮箱登录密码！！mail_to = &quot;接收信息的邮箱&quot; 发送带有图片附件images和正文mail_text的邮件 12345678910111213141516msg = MIMEMultipart()mail_text = &quot;已经成功打卡！&quot;mail_body = MIMEText(mail_text)# 设置邮件主题、发送方和接收方msg['Subject'] = &quot;每日健康打卡通知&quot;msg['From'] = MAIL_USERmsg['To'] = mail_tomsg.attach(mail_body)# 添加截图附件fp = open(&quot;success.png&quot;, 'rb')images = MIMEImage(fp.read())fp.close()images.add_header('Content-Disposition', 'attachment', filename='success.png')msg.attach(images) 登陆并发送邮件(我这里是用163邮箱) 123456smtp = smtplib.SMTP()smtp.connect('smtp.163.com')smtp.login(MAIL_USER, MAIL_PASS)smtp.sendmail(MAIL_USER, mail_to, msg.as_string())smtp.quit() 定时运行程序通过使用Win10自带的“任务计划程序”来设置运行编写的.py脚本，设置步骤如下： 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/08/20/%E3%80%90python%E3%80%91%E5%AE%9A%E6%97%B6%E5%81%A5%E5%BA%B7%E6%89%93%E5%8D%A1%E7%BD%91%E7%AB%99%E6%89%93%E5%8D%A1%E5%8F%91%E9%80%81%E9%82%AE%E7%AE%B1/"},{"title":"【原生javascript项目】Piano-Kit-01","text":"引言本文介绍如何用javascripty语法写一个简单的琴键(drum ang piano)网页，通过敲击特定键盘（音键），可以发出不同音调。 网址为(https://janice143.github.io/musicKit.github.io/) 正文1网页布局与功能 网页整体分为3个部分： 1是最顶上居中排布的乐器切换(Drum Kit, Piano Kit)组块，选中响应的kit，背景图和琴键切换为响应的内容，同时kit字体变为白色； 2是页面居中排布的琴键； 3是背景图。 琴键可以通过鼠标点击或者按下响应的键盘来操作，可以发出对应的音效（黄色字体表示音效的名称）。琴键被点击按下后，加以一定的css动画（黄色高亮边框）来区分。 2实现原理一、 html代码 1 乐器切换组块： 1234&lt;div id=&quot;switch&quot;&gt; &lt;a class=&quot;drum chosen&quot; href=&quot;#&quot; onclick=&quot;addChosenDrum()&quot;&gt;Drum Kit&lt;/a&gt; &lt;a class=&quot;piano&quot; href=&quot;#&quot; onclick=&quot;addChosen()&quot;&gt;Piano Kit&lt;/a&gt;&lt;/div&gt; 2 Drum Kit: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=&quot;pianoKit&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key1 key&quot; &gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(65)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;A&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;DO&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key2 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(83)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;S&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;RE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key3 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(68)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;D&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;MI&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key4 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(70)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;F&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;FA&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key5 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(71)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;G&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SOL&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key6 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(72)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;H&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;LA&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#&quot; onclick=&quot;clickPlaySound(74)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;J&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SI&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;audio data-key=&quot;65&quot; src=&quot;sounds/1.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;83&quot; src=&quot;sounds/2.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;68&quot; src=&quot;sounds/3.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;70&quot; src=&quot;sounds/4.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;71&quot; src=&quot;sounds/5.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;72&quot; src=&quot;sounds/6.MP3&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;74&quot; src=&quot;sounds/7.MP3&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 3 Piano Kit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;div id=&quot;drumKit&quot; class=&quot;chosen&quot;&gt; &lt;div data-key=&quot;65&quot; class=&quot;key1 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(65)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;A&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;CLAP&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;83&quot; class=&quot;key2 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(83)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;S&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;HIHAT&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;68&quot; class=&quot;key3 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(68)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;D&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;KICK&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;70&quot; class=&quot;key4 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(70)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;F&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;OPENHAP&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;71&quot; class=&quot;key5 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(71)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;G&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;BOOM&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;72&quot; class=&quot;key6 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(72)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;H&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;RIDE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;74&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(74)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;J&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;SNARE&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;75&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(75)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;K&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;TOM&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;div data-key=&quot;76&quot; class=&quot;key7 key&quot;&gt; &lt;a href=&quot;#1&quot; onclick=&quot;clickPlaySound(76)&quot;&gt; &lt;p class=&quot;key-ABC&quot;&gt;L&lt;/p&gt; &lt;p class=&quot;key-tune&quot;&gt;TINK&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;audio data-key=&quot;65&quot; src=&quot;sounds/clap.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;83&quot; src=&quot;sounds/hihat.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;68&quot; src=&quot;sounds/kick.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;70&quot; src=&quot;sounds/openhat.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;71&quot; src=&quot;sounds/boom.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;72&quot; src=&quot;sounds/ride.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;74&quot; src=&quot;sounds/snare.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;75&quot; src=&quot;sounds/tom.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;76&quot; src=&quot;sounds/tink.wav&quot;&gt;&lt;/audio&gt;&lt;/div&gt; 二、css代码 1 实现顶部的切换组块（Drum Kit, Piano Kit)固定在窗口的某个位置，不占位置，脱离标准文档流；居中排布 1234position: fixed;left:0; right:0; margin:0 auto; 2 实现琴键居中排布：用Flex 布局实现垂直、水平居中。 任何一个容器都可以指定为 Flex 布局（flex容器），display: flex即可实现。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”Item”。 容器具有6个属性： · flex-direction:水平主轴的方向 · flex-wrap:如果主轴拍不下，可以用这个属性来设置换行的形式 · flex-flow:合并了flex-direction 和flex-wrap的功能，用这个属性可以同时设置这两个属性。 · justify-content:定义了item在主轴（水平方向上）的对齐方式 ·align-items：定义了item在垂直方向上的对齐方式 · align-content：定义了多跟轴线的对齐方式 123456789#drumKit,#pianoKit{ /* background-color: red; */ /* 在需要垂直居中的父元素上，设置display:flex和align-items：center。要求：父元素必须显示设置height值 */ display: flex; flex:1; min-height: 90vh; /*vh 就是当前屏幕可见高度的100% align-items: center; /*子元素水平居中*/ justify-content: center; /*子元素垂直居中*/} 90vh表示占窗口（当前页面窗口）大小的90%。 3 键盘被点击时，js会添加playing类，其css布局为 12345.playing{ transform: scale(1.1); border-color: #ffc600; box-shadow: 0 0 1rem #ffc600;} 4 drum kit 和piano kit被选中时，js会添加chosen类名。设置css代码让选中字体变为白色以区分 123#switch .chosen{ color:white;} 三、 javascript代码 1 切换键盘(drum kit, piano kit) 对于drum kit：点击drum，添加.chosen，同时去掉piano kit 的.chosen类名；显示drum琴键，隐藏piano琴键；显示响应背景background-image。 12345678910111213141516171819202122232425262728293031// 点击a标签，切换键盘:点击piano键盘，添加chosen class，去掉drum的class; 显示对应的piano键盘;在对应的键盘中添加chosen，这样audio也可以对应 function addChosen(){ const chosen = document.getElementsByClassName(&quot;piano&quot;); const notChosen = document.getElementsByClassName(&quot;drum&quot;); chosen[0].classList.add('chosen'); notChosen[0].classList.remove('chosen'); const notChosenKit = document.getElementById(&quot;drumKit&quot;); notChosenKit.classList.remove('chosen'); notChosenKit.style.display = &quot;none&quot;; const chosenKit = document.getElementById(&quot;pianoKit&quot;); chosenKit.style.display = &quot;flex&quot;; chosenKit.classList.add('chosen'); // 换钢琴壁纸 const wallpaper = document.getElementsByTagName(&quot;html&quot;); wallpaper[0].style.backgroundImage=&quot;url(./pianoback.jpg)&quot;; } function addChosenDrum(){ const chosen = document.getElementsByClassName(&quot;drum&quot;); const notChosen = document.getElementsByClassName(&quot;piano&quot;); chosen[0].classList.add('chosen'); notChosen[0].classList.remove('chosen'); const notChosenKit = document.getElementById(&quot;pianoKit&quot;); notChosenKit.classList.remove('chosen'); notChosenKit.style.display = &quot;none&quot;; const chosenKit = document.getElementById(&quot;drumKit&quot;); chosenKit.style.display = &quot;flex&quot;; chosenKit.classList.add('chosen'); // 换鼓壁纸 const wallpaper = document.getElementsByTagName(&quot;html&quot;); wallpaper[0].style.backgroundImage=&quot;url(./drumback.jpg)&quot;; } 2 键盘敲击琴键，用keycode标注，给对应琴键添加.playing类名。设置audio.play发出音效。 1234567891011// 点击键盘字母时，对应的键添加class属性function playSound(e){ const audio = document.querySelector(`.chosen audio[data-key=&quot;${e.keyCode}&quot;]`); // console.log(audio); if (!audio) return; const key = document.querySelector(`.chosen div[data-key=&quot;${e.keyCode}&quot;]`); key.classList.add('playing');//添加playing类属性 audio.currentTime = 0; //音频重头播放 audio.play();} 3 如果连续敲击多个琴键，多个琴键都会显示过渡特效（黄色Border,放大1.2倍），为了让最后一个琴键之前的琴键过滤样式去掉，可以利用transitionend事件，让已经过渡的琴键去掉.playing类名。 12345678910// 去掉playing 类属性function removeTransition(e){ if (e.propertyName !='transform') return; this.classList.remove('playing');}const keys = document.querySelectorAll('.key');keys.forEach(key=&gt;key.addEventListener('transitionend',removeTransition));window.addEventListener('keydown',playSound); 4 鼠标点击也可以实现琴键发出音效。设置onclick事件，传入keycode参数。 1234567891011function clickPlaySound(keycode){ // data-key=keycode; const audio = document.querySelector(`.chosen audio[data-key=&quot;${keycode}&quot;]`); if (!audio) return; const key = document.querySelector(`.chosen div[data-key=&quot;${keycode}&quot;]`); key.classList.add('playing');//添加playing类属性 audio.currentTime = 0; //音频重头播放 audio.play(); // console.log(audio); }; 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Piano-Kit-01/"},{"title":"【原生javascript项目】数组操作 04","text":"引言本文介绍一下数组操作的一些常用方法。 正文1创建数组1234567const people = ['Bernhard, Sandra', 'Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd', 'Beckett, Samuel', 'Blake, William', 'Berger, Ric', 'Beddoes, Mick', 'Beethoven, Ludwig','Belloc, Hilaire', 'Begin, Menachem', 'Bellow, Saul', 'Benchley, Robert', 'Blair, Robert', 'Benenson, Peter', 'Benjamin, Walter', 'Berlin, Irving','Benn, Tony', 'Benson, Leana', 'Bent, Silas', 'Berle, Milton', 'Berry, Halle', 'Biko, Steve', 'Beck, Glenn', 'Bergman, Ingmar', 'Black, Elk', 'Berio, Luciano','Berne, Eric', 'Berra, Yogi', 'Berry, Wendell', 'Bevan, Aneurin', 'Ben-Gurion, David', 'Bevel, Ken', 'Biden, Joseph', 'Bennington, Chester', 'Bierce, Ambrose','Billings, Josh', 'Birrell, Augustine', 'Blair, Tony', 'Beecher, Henry', 'Biondo, Frank']; 2 获取数组长度1console.log(people.length); 3循环123people.forEach(function(item,index){ console.log(item,index);}) 4 数据尾部添加一个元素12let newLength = people.push('Wheeler, Ben');// newLength的结果是people的长度，不是新添加的元素内容console.log(people.length); 5 从尾部删除一个元素12let last = people.pop();console.log(people.length); 6 从头部删除一个元素12let first = people.shift();console.log(people.length); 7 从提添加一个新元素12let firstItem = people.unshift('Bernhard, Sandra');console.log(people); 8 寻找下标12let pos = people.indexOf('Blair, Tony');console.log(pos); 9 根据下标删除元素12let removeItem = people.splice(pos,1);//参数1表示Pos下标后多少个console.log(removeItem); 10 复制数组1234// 复制数组 1let newPeople1 = people; //people和newPeople1指向同一个内存// 复制数组 2let newPeople2 = people.slice(); // people和newPeople1指向不同一个内存 11 Index超出数组长度12people[100] = 'bbb';console.log(people); 12 Array.prototype.filter() 过滤12const fifteen = inventors.filter(inventor=&gt;(inventor.year&gt;=1500 &amp;&amp; inventor.year &lt; 1600));console.table(fifteen); 13 Array.prototype.map()12345const fullNames = inventors.map(inventor =&gt; (inventor.first + ' ' + inventor.last));const fullNames2 = inventors.map(inventor =&gt; `${inventor.first} ${inventor.last}`);console.log(fullNames);console.log(fullNames2); 14 Array.prototype.sort()12345678910// 升序const ordered = inventors.sort((a,b) =&gt; a.year &gt; b.year ? 1 : -1);console.table(ordered);// 降序const oldest = inventors.sort(function(a,b){ const lastInventor = a.passed - a.year; const nextInventor = b.passed - b.year; return lastInventor &gt; nextInventor ? -1:1;});console.table(oldest); 15 Array.prototype.reduce() 结果返回单个值123456// Array.prototype.reduce() 结果返回单个值const totalYears = inventors.reduce((total,inventor) =&gt; { return total + (inventor.passed - inventor.year);}, 0); // 0表示返回的单个值再加上0console.log(totalYears); 结论完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/15/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C-04/"},{"title":"【原生javascript项目】 Flex Panel 05","text":"引言本文介绍一个动态放映网页，知识点主要涉及到flex容器，以及元素点击事件。 效果网站：https://janice143.github.io/flexPanel/ 正文一、html部分主要为5个div元素将网页分为5块，横向排列。每一个div元素中有上中下三个p标签，对应3段话。 123456789101112131415161718192021222324252627&lt;div class=&quot;panels&quot;&gt; &lt;div class=&quot;panel1 panel&quot; onclick=&quot;clickOpen(1)&quot;&gt; &lt;p&gt;Hey&lt;/p&gt; &lt;p&gt;Let's&lt;/p&gt; &lt;p&gt;Dance&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel2 panel&quot; onclick=&quot;clickOpen(2)&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;Take&lt;/p&gt; &lt;p&gt;Receive&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel3 panel&quot; onclick=&quot;clickOpen(3)&quot;&gt; &lt;p&gt;Experience&lt;/p&gt; &lt;p&gt;It&lt;/p&gt; &lt;p&gt;Today&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel4 panel&quot; onclick=&quot;clickOpen(4)&quot;&gt; &lt;p&gt;Give&lt;/p&gt; &lt;p&gt;All&lt;/p&gt; &lt;p&gt;You can&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;panel5 panel&quot; onclick=&quot;clickOpen(5)&quot;&gt; &lt;p&gt;Life&lt;/p&gt; &lt;p&gt;In&lt;/p&gt; &lt;p&gt;Motion&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 二、css部分css代码主要要实现5个div元素均匀横向排列，每个div元素内有对应的背景图片、3个p标签的文本。P标签的文本在每一个div元素中也是左右居中、上下均匀排列。主要是利用了flex容器来实现。 1 flex容器参考网站：https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器的属性： flex-direction：项目的排列方向 flex-wrap：默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 flex-flow：flex-direction属性和flex-wrap属性的简写形式 justify-content：项目在主轴上的对齐方式 align-items：项目在交叉轴上如何对齐 align-content：定义了多根轴线的对齐方式 项目的属性： order：项目的排列顺序，数值越小，排列越靠前 flex-grow：定义项目的放大比例，默认为0 flex-shrink：项目的缩小比例，默认为1 flex-basis： 项目占据的主轴空间 flex：是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性 2 css字体1234&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Amatic+SC&quot;&gt;text-transform: uppercase;font-family: 'Amatic SC',cursive;text-shadow: 0 0 4px rgba(0,0,0,0.72),0 0 14px rgba(0,0,0,0.45); 3过渡样式12345transition:font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11),background 0.2s;transform:translateY(-100%); 4 背景图片1234567background-size: cover;background-position: center;.panel1 { background-image:url(https://source.unsplash.com/gYl-UtwNg_I/1500x1500); }.panel2 { background-image:url(https://source.unsplash.com/rFKUFzjPYiQ/1500x1500); }.panel3 { background-image:url(https://images.unsplash.com/photo-1465188162913-8fb5709d6d57?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;w=1500&amp;h=1500&amp;fit=crop&amp;s=967e8a713a4e395260793fc8c802901d); }.panel4 { background-image:url(https://source.unsplash.com/ITjiVXcwVng/1500x1500); }.panel5 { background-image:url(https://source.unsplash.com/3MNzGlQM7qs/1500x1500); } 5其他CSS选择器 * 将匹配文档的所有元素；&gt; 组合器选择前一个元素的直接子代的节点。 .panel &gt; *选择类名为panel的所以直接子元素 Js部分我写的程序，大致思路是在html代码里设置onclick属性，然后函数内容在js里写，不同的panel传入参数不一样 定位类名有两个以上的标签document.getElementsByClassName(panel${num} panel-open)； 1234567891011// 点击panel 12345，给对应的panel添加.panel-open属性function clickOpen(num){ const panelNumIf = document.getElementsByClassName(`panel${num} panel-open`); const panelNum = document.getElementsByClassName(`panel${num}`); // console.log(panelNumIf[0]) if (panelNumIf[0]) panelNumIf[0].classList.remove('panel-open'); else panelNum[0].classList.add('panel-open');//添加panel-open类属性 console.log(`panel${num} panel-open`); }; 别人的程序，大致思路是遍历5个Panel，监控是否有点击事件，有的话就运行toggleOpen函数，该函数里 this.classList.toggle(‘open’)表示如果this有open类名，则删除，没有则加上。 e.propertyName获取transitionend的属性名，e.propertyName.includes(‘flex’)包含flex字段的属性名 12345678910111213const panels = document.querySelectorAll('.panel');function toggleOpen() { console.log('Hello'); this.classList.toggle('open');}function toggleActive(e) { console.log(e.propertyName); if (e.propertyName.includes('flex')) { this.classList.toggle('open-active'); }}panels.forEach(panel =&gt; panel.addEventListener('click', toggleOpen));panels.forEach(panel =&gt; panel.addEventListener('transitionend', toggleActive)); 总结完整代码放在了Github上，如果读者有兴趣，不妨试一试。","link":"/myblog.github.io/2021/11/17/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Flex-Panel-05/"},{"title":"【原生javascript项目】 Fun dictionary 06","text":"作者：©Iaine 万一简介：30-day vanilla js coding challenge (30 Day Challenge)是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。本项目属于第6天项目，为了更有挑战性，我尝试实现了 单词查找 的功能。 Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/funDictionary/ 项目描述在输入框中输入一个单词，会实时匹配现有词库中所有包含该字段的单词（以一定的样式展示），每个单词中，会高亮显示出文本输入框中输入的字段。词库为json数据，在加载页面时，异步获取而来。 项目主要知识点包括： 异步操作 数组Array对象的一些方法 正则表达式 CSS transform的一些属性 项目过程html部分设置input标签用来输入单词，ul标签（列表标签）用来展示搜索的结果 JS部分 空数组直接赋值给一个dict变量，用来存储json数据中的词库 使用fetch 方法从网络中异步获取资源，解析 JSON 数据，存入数组dict 利用 filter() 方法查找单词wordToMatch，筛选的条件是正则表达式，如果string的match(regex)方法返回不是空，则filter函数返回词库中所有wordToMatch字段的单词 运用 filter() 过滤数组数据 创建正则表达式，构造过滤条件 match方法匹配 编写匹配输入的函数。在Html中显示匹配的单词，利用map方法按照原始数组元素顺序依次处理元素。 获取匹配数据 替换关键词放入高亮的标签 构造 HTML 标签数据 将匹配值的 HTML 标签放入 &lt;ul&gt; 中 编写展示匹配结果的函数 获取匹配数据 利用map方法依次处理元素，替换关键词放入高亮的标签，返回html标签数据 将匹配值的 HTML 标签放入 &lt;ul&gt; 中 获取两个主要 HTML 元素（&lt;input&gt;，&lt;ul&gt;），给 &lt;input&gt; 添加事件监听（change, keyup） CSS部分CSS**transform**属性允许旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。 项目知识点异步操作概念：程序执行任务时分两段进行，执行第一段任务后，执行其他任务，其他任务执行完后接着执行第二段任务。 异步操作的方法： 回调函数多重嵌套 缺点：出现多重嵌套，代码很容易乱成一团，无法管理，出现callback hell。 示例: 读取A文件之后，再读取B文件，之后再回到读取A文件后的操作。 12345fs.readFile(fileA, function (err, data) { fs.readFile(fileB, function (err, data) { // ... });}); Promise 它不是新的语法功能，而是一种新的写法。代码从横向发展，变成纵向发展。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function(data){ console.log(data.toString());}).then(function(){ return readFile(fileB);}).then(function(data){ console.log(data.toString());}).catch(function(err) { console.log(err);}); 参考文档：https://wiki.jikexueyuan.com/project/es6/async.html#:~:text=%E6%89%80%E8%B0%93%22%E5%BC%82%E6%AD%A5%22%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4,%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B0%B1%E5%8F%AB%E5%81%9A%E5%BC%82%E6%AD%A5%E3%80%82 fetch属于Fetch API的一个全局方法。需要接受 url 作为参数，返回值是一个 Promise 对象。若请求成功，这个对象包含了（对应 Request 的）Response，但这只是一个 HTTP 响应。 一个基本的 fetch 请求设置代码如下： 123fetch('http://example.com/movies.json') .then(response =&gt; response.json()) .then(data =&gt; console.log(data)); 这里通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 fetch() 到的资源路径，然后返回一个包含响应结果的 promise（一个 Response 对象）。 当然它只是一个 HTTP 响应，而不是真的 JSON。为了获取JSON的内容，我们需要使用 json() 方法（该方法返回一个将响应 body 解析成 JSON 的 promise）。 对象转换为数组获取的资源data为对象类型， ``{a: ‘The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).’, ab: ‘The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.’, aback: ‘Backward against the mast;-said of the sails when …uddenly checked, baffled, ordiscomfited. Dickens.’, abaft: ‘Behind; toward the stern from; as, abaft the wheelhouse. Abaftthe beam. See under Beam.’, abalone: ‘A univalve mollusk of the genus Haliotis. The shel…oast of California, clingingclosely to the rocks.’, …}` 想要转换为数组： [0:{a: 'The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).'} 1:{ab: 'The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.'}] 代码参考链接：https://juejin.cn/post/6844903602478120967 12345data =&gt; Object.keys(data).forEach(v =&gt; { let o = {}; o[v] = data[v]; dict.push(o);}) Object.keys方法是JavaScript中用于遍历对象属性的一个方法 。它传入的参数是一个对象，返回的是一个数组，数组中包含的是该对象所有的属性名。 正则表达式概念：匹配字符串的字符组合模式 创建一个正则表达式有两种方法： 1 使用正则表达式字面量，包含在斜杠之间 2 调用RegExp对象的构造函数 知识参考链接：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions 正则表达式可以被用于 RegExp 的 exec 和 test (en-US) 方法以及 String 的 match (en-US)、replace、search (en-US) 和 split (en-US) 方法。其中match方法是一个在字符串中执行查找匹配的String方法，返回一个数组，在未匹配到时会返回 null。 12345678// 匹配单词 function findWords(wordToMatch,dict){ return dict.filter(word =&gt;{ const regex = new RegExp(wordToMatch,'gi');// g:global,i:intensive if (Object.keys(word)[0].match(regex)) return word[Object.keys(word)[0]]; }) }; 一些数组和对象方法17个实用的JavaScript数组和对象的方法：https://segmentfault.com/a/1190000015301183 .filter()创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 .map()创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 .reduce()对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。 .forEach()对数组的每个元素执行一次提供的函数。 .some()判断数组中的某些元素是否通过由提供的函数实现的测试。 .every()检查是否数组中的每个值都满足条件。 .includes()检查是否一个数组包含一个确定的值。 Array.from()这是一个可以从其他数组或者字符串中创造新array的方法。 Objects.values()返回一个由给定对象自己的所有可枚举属性值的数组。 Objects.keys()返回一个由给定对象的自身可枚举属性组成的数组。 Object.entries()返回一个由一个给定对象的键值对组成的数组。 Array spread在数组中使用扩展运算符（…）可以展开数组中的元素。 Object spread扩展对象允许为一个没有更改的对象添加新的属性和方法（换句话说，创建了一个新对象) Object.freeze()防止修改现有的对象属性或者向对象添加新的属性和值。 Object.seal()停止将任何新属性添加到对象，但仍允许更改现有属性。 Object.assign()允许将对象组合在一起。 想把我的技术文章写好一点，特意参考其他优秀人的文档，感谢未枝丫，我觉得他的文档写的不错，特意模仿，顺便挂上他的JS30挑战项目链接。 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/06/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Fun-dictionary-06/"},{"title":"【原生javascript项目】Canvas 08","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第8天项目，为了更有挑战性，我实现了 移动端绘图 、画笔样式选择的功能。Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/myCanvas/ （画了个嗅嗅，一不小心暴露自己是个魔法师啦，哈哈） 项目描述利用html5 中的canvas实现的画板。在电脑端可利用鼠标移动点击进行绘图，在移动端可以通过触摸移动实现绘图。绘图的笔颜色、粗细可以调节，选中橡皮擦可对局部区域进行修改，清屏按钮可以一键清屏。 项目重点 canvas window.innerWidth lineJoin、lineWidth、lineCap strokeColor beginPath、moveTo、lineTo、stroke() 鼠标事件 mousemove: e.offsetX, e.offsetY mouseup mouseout mousedown 触摸事件 touchmove touchend touchcancel touchstart touch坐标计算的坐标偏移问题 input标签的change事件 this.value this.name this.checked 滑块input线性过渡变成非线性过渡 css的flex容器属性 display:flex align-items: center 竖直居中 justify-content: center 水平居中 项目过程html部分 三个input控件 颜色 type=”color” 粗细 type=”range” 橡皮擦 type=”checkbox” canvas标签设置画布 清屏按钮 type=”button” Js部分 获取canvas标签，并设定宽度和高度；获取四个input元素 利用getContext()获取渲染上下文，存储在变量ctx中。 在二维渲染上下文中，左上点坐标为(0,0)，向右（x轴）向下（y轴）为正 设置初始值 初始化画笔颜色（ctx.StrokeStyle）粗细（ctx.lineWidth），橡皮擦不选中(eraserChecked = false)； 设置lineCap(线的末端形状）为圆形，lineJoin（两条线段连接处形状）为圆形 编写updateValue()函数 三个控件input发生改变时，触发事件，调用该函数，更新画笔三个初始值。 编写draw()函数 设定一个用于标记绘画状态的变量，画或者不画（true or false) 判断是鼠标事件还是触摸事件，返回当前鼠标点和触摸点的坐标 赋值新的画笔参数 绘制前调用beginPath()，设定路径起点、终点 编写clearCanvas()函数 清屏的原理就是在画布上画满一个白色矩阵 所有input的监听事件，控件中的change事件，清屏是click事件 CSS部分使用over-flow:hidden来设置页面不动，这点在移动端触摸时显得必不可少。 项目知识点Canvas 创建 Canvas 元素 1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; 通过 JavaScript 来绘制 12var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d'); 基本样式属性 颜色：strokeStyle：线条描边的颜色，fillStyle：填充的颜色 线型：lineCap：笔触的形状；lineJoin：线条相较的方式；lineWidth：线条的宽度 路径绘制 beginPath()：新建一条路径 stroke()：绘制轮廓 moveTo()：绘制操作的起点 lineTo()：路径的终点 触摸屏端坐标偏移问题使用鼠标事件在canvas画布上画画，非常容易就能获取到画布上的坐标，使用（e.offsetX，e.offsetY）就行。但是对于移动端的触摸屏，必须利用【页面上的坐标】-【画布左上角的坐标】=【画布上的坐标】公式去计算当前触摸位置坐标。 changedTouches[0].clientX表示当前触摸点在页面上的坐标，e.target.offsetLeft表示画布偏离页面左上角的位置。 12x = e.changedTouches[0].clientX -e.target.offsetLeft;y = e.changedTouches[0].clientY-e.target.offsetTop; JS30的第8个项目圆满完成啦，虽然对原项目做了一些改进，但是整体上也实现了一些我自己的独特功能。PS：发现自己真的很喜欢编程，fun with front end development.希望自己能力越来越强，实现自己的程序员梦想。 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Canvas-08/"},{"title":"【原生javascript项目】Go list 10","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第10天的“待办清单”项目，我增加了 双击删除任务 、添加任务的功能。Have fun with the website! ♪(^∇^*) 网页效果：https://janice143.github.io/goList/ 项目描述利用一些 checkbox 类型的 input 元素，通过在js中实现特定功能，而设计的待办清单网页。在网页中，可以通过点击checkbox来标记任务状态，通过按住shift键可以对任务实现多项check。也可以通过点击添加来增加任务，完成的任务可以通过双击实现删除。 项目重点 类型为checkbox的input元素的点击事件，回调函数为clickCheck e.shiftKey this.checked 标记上一次点击的input，以及多选内部的Input 类型为text的input元素的change事件，回调函数为displayTask 使用createElement创建元素 使用append来在指定结点后添加html 输入文本回车后情况文本，this.value = ‘’ 监听双击事件，移除任务 checkbox后面的文本双击事件，回调函数为removeTask e.path[1].remove() 项目过程html部分 输入文本框input 定位在文本框上的div元素，点击后display: none 四个类名为task-item是checkbox和任务文本p 新添任务的占位标签，新添加的任务将会append在这里 Js部分 获取类型为checkbox的所有input，遍历点击事件 点击事件为clickCheck 多选操作的原理 123456789101112if(e.shiftKey &amp;&amp; this.checked) inputChecks.forEach(inputCheck =&gt; { console.log(inputCheck === this || inputCheck === lastChecked); if (inputCheck === this || inputCheck === lastChecked) { inBetween = !inBetween; // console.log('Starting to check them in between!'); } // console.log('行内是否',inBetween); if (inBetween) { inputCheck.checked = true; } }) 获取所有p元素，遍历双击事件 双击事件为removeTask 找到对应的任务路径，remove即可 123function removeTask(e){ console.log(e.path[1].remove());} 获取类名为add-icon的元素，监听点击事件，点击隐藏 使页面元素隐藏和显示可以有两种方式： 方式1：设置元素style属性中的display 123var t = document.getElementById('test');//选取id为test的元素t.style.display = 'none'; // 隐藏选择的元素t.style.display = 'block'; // 以块级样式显示 方式2：设置元素style属性中的visibility 123var t = document.getElementById('test');t.style.visibility = 'hidden'; // 隐藏元素t.style.visibility = 'visible'; // 显示元素 二者的区别在于设置display隐藏后不占用原来的位置，而visibility隐藏后元素位置任然被占用。 获取类型为text的input元素，监听change事件 change事件调用displayTask 动态插入html 使用createElement创建元素 使用append挂载元素 监听双击事件 123456789101112131415161718function displayTask(){ // 使用createElement创建元素 const newTaskItem = document.createElement('div'); newTaskItem.className = 'new-task-item'; const html = `&lt;div class=&quot;task-item&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;p&gt;${this.value}&lt;/p&gt;&lt;/div&gt;`; newTaskItem.innerHTML = html; newTask.append(newTaskItem); // console.log(newTask); // console.log(html); this.value = '' newTaskItem.addEventListener('dblclick',removeTask)} CSS部分 :checked 选择器 紧邻兄弟组合器：A+ B 组合器选择相邻元素，即后一个元素B紧跟在前一个A之后，并且共享同一个父节点 添加删除线 text-decoration: line-through; 项目知识点DOM 树DOM为文档对象模型，每个 HTML 标签都是一个对象。 DOM 将 HTML 表示为标签的树形结构。标签被称为 元素节点（或者仅仅是元素），并形成了树状结构：&lt;html&gt; 在根节点，&lt;head&gt; 和 &lt;body&gt; 是其子项，等。元素内的文本形成 文本节点，被标记为 ＃text。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。 利用JS修改文档 创建一个元素（DOM节点） document.createElement(tag)创建一个新 元素节点（element node） document.createTextNode(text)创建一个 文本节点 创建 div 分为 3 个步骤： 12345678// 1. 创建 &lt;div&gt; 元素let div = document.createElement('div');// 2. 将元素的类设置为 &quot;alert&quot;div.className = &quot;alert&quot;;// 3. 填充消息内容div.innerHTML = &quot;&lt;strong&gt;Hi there!&lt;/strong&gt; You've read an important message.&quot;; 这时已经创建了该元素。但到目前为止，它还只是在一个名为 div 的变量中，尚未在页面中。所以我们无法在页面上看到它。 append挂载元素 为了让 div 显示出来，我们需要将其插入到 document 中的某处。 append：document.body.append(div)。 node.append(...nodes or strings) —— 在 node 末尾 插入节点或字符串， node.prepend(...nodes or strings) —— 在 node 开头 插入节点或字符串， node.before(...nodes or strings) —— 在 node 前面 插入节点或字符串， node.after(...nodes or strings) —— 在 node 后面 插入节点或字符串， node.replaceWith(...nodes or strings) —— 将 node 替换为给定的节点或字符串。 JS30的第10个项目圆满完成啦，虽然对原项目做了一些改进，但是整体上也实现了一些我自己的独特功能。PS：中间跳了第7和9个项目，如果有时间我后面会补上滴！ 感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/09/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Go-list-10/"},{"title":"【原生javascript项目】Video player 11","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第11天的“自定义视频播放器”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/videoPlayer/ 项目描述利用video标签，以及一些div标签，在js中设置视频的播放控件，包括暂停/播放，声音调节，视频进度调节，视频播放率，跳过/退后。 项目重点 video对象的各种属性、方法和事件 paused play() pause() currentTime volume playbackRate HTML DOM offsetWidth 属性 获取元素的宽度，包含内边距（padding）和边框（border）: HTML5 data-* 自定义属性 this.dataset. data- 项目过程html部分 video标签标记视频文件 div标签和button标签实现的一些视频控件，类名为.controlers .progress进度条，.progress_filled进度条填充颜色 .player_button播放按钮 声音滑块 播放速度滑块 前进/后退按钮 Js部分 获取标签 编写自定义函数 播放按键 12const method = video.paused ? 'play' : 'pause';video[method](); 更新播放键的按键 12const icon = this.paused ? '►' : '❚ ❚';toggle.textContent = icon; 前进/后退 1video.currentTime += parseFloat(this.dataset.skip); 更新滑块的值 1video[this.name] = this.value; 更新进度条（填充颜色） 12const percent = (video.currentTime / video.duration) * 100;progressBar.style.flexBasis = `${percent}%`; 鼠标移动进度条 12const scrubTime = (e.offsetX / progress.offsetWidth) * video.duration;video.currentTime = scrubTime; 添加监听事件 视频的click,play,pause,timeupdata事件 播放按钮、前进后退按钮的click事件 滑块的change,mousemove事件 进度条的click,mousemove,mousedown,mouseup事件 CSS部分 flex容器的项目属性 flex-basis：项目占据的主轴空间（main size） flex 属性选择器 input[type=range] 项目知识点data-*自定义数据属性，可通过所属元素的 HTMLElement 接口访问，确切地说是HTMLElement.dataset ， HTMLElement.dataset[&quot;testValue&quot;] 属性访问。 注*：data-后面的命名规则 该名称不能以xml开头，无论这些字母是大写还是小写； 该名称不能包含任何分号； 该名称不能包含A至Z的大写字母 data后面的命名中有-，如 data-test-value ，可通过 HTMLElement.dataset.testValue ( 或者是HTMLElement.dataset[&quot;testValue&quot;]) 来访问，任何短线符号都会被下个字母的大写替代(驼峰拼写)。 JS30的第11个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/18/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Video-player-11/"},{"title":"【原生javascript项目】Secret code sequence 12","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第12天的“字符序列检测”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/secretCode/ 键盘输入 happy 2022 即可触发彩蛋。 项目描述通过判断键盘输入的字符串中是否含有指定字符串序列，开启网页中的隐藏彩蛋。本项目的彩蛋是 从网页 Cornify.com 中加载一个 JS 文件，调用其中的 cornify_add() 方法时，随机在页面出加载独角兽的图标和p标签。 项目重点 window的keyup事件 window.addEventListener('keyup',) e.key 数组操作 .push() .splice() .length .join() .includes() 项目过程html部分 p标签标记一段提示的文字 Js部分 声明一个变量用来存储按下的字符串序列数组 声明一个变量用来存储已知的指定字符串序列 window的键盘监听事件 将字符串指定规则切分 1pressCode.splice(-secretCode.length - 1, pressCode.length - secretCode.length) 判断是否包含指定字符串 1if (pressCode.join('').includes(secretCode)){} 随机在页面中加载独角兽图标 1cornify_add(); 项目知识点js中的splice方法的使用说明splice方法可以用来对js的数组进行删除，添加，替换等操作。 删除。第一个参数为起始位置（如果为负数，表示倒数），第二个参数为要删除几个。 array.splice(index,num) 插入。第一个参数（插入位置），第二个参数（0），第三个参数（插入的项）。 array.splice(index,0,insertValue) 替换。第一个参数（起始位置），第二参数（删除项数），第三参数（插入任意数量的项）。 array.splice(index,num,insertValue) JS30的第12个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/20/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Secret-code-sequence-12/"},{"title":"【原生javascript项目】Slide in on scroll 13","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第13天的“图片随屏幕滚动而滑入滑出”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/sliderIn/ 项目描述本项目为一个图文浏览网页，其中，当浏览到图片时（屏幕滚动到图片上），图片具有滑入特效，浏览完毕后，图片滑出。滑入滑出特效由css的translateX()实现，触发特效有javascript控制。 项目重点 window的scroll事件 window.addEventListener('scroll') 一些位置（像素值） window.scrollY 文档当前垂直滚动的像素数 window.innerHeight viewport部分的高度 sliderImage.offsetTop 当前元素顶部相对于其 offsetParent 元素的顶部的距离 未枝丫博客有图解 debounce 的作用（函数防抖） 降低事件监听的频率，使用了 Lodash 中的 debounce 方法 项目过程html部分 p标签的文字 img标签的图片 JS部分 监听window的scroll事件 触发checkSlide函数 图片滑入条件：屏幕滚动位置以及屏幕高度之和 &gt; 图片顶部距离页面距离以及图片半高；屏幕滚动位置 &lt; 图片底部距离 1234const slideInAt = (window.scrollY + window.innerHeight);const imageBottom = sliderImage.offsetTop + sliderImage.height;const isHalfShown = slideInAt &gt; (sliderImage.offsetTop + sliderImage.height / 2);const isNotScrolledPast = window.scrollY &lt; imageBottom; 函数防抖 由于每次滚动都触发监听事件，会降低 JavaScript 运行性能，所以用 debounce 函数来降低触发的次数 1234567891011121314function debounce(func, wait = 20, immediate = true) { var timeout; return function() { var context = this, args = arguments; var later = function() { timeout = null; if (!immediate) func.apply(context, args); }; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); };}; CSS部分 屏幕滚动之前，图片的状态是：不透明度为0（隐藏），x方向偏移30%（相对于图片大小），缩放95%。 1234567.align-right.slide-in {transform: translateX(30%) scale(0.95);}.slide-in.active {opacity: 1;transform: translateX(0%) scale(1);} 触发特效，图片的状态是：不透明度为1，x方向偏移0%（相对于图片大小），缩放1。 1234.slide-in.active { opacity: 1; transform: translateX(0%) scale(1);} 项目补充元素浮动作用能够实现让多个元素排在问一行,并且给这些元素设置宽度与高度。 背景在标准文档流中的元素只有两种：块级元素和行内元素。让多个元素排在同一行：行内元素的特性；给这些元素设置宽高:块级元素的特性。如果想让一些元素既要有块级元素的特点也要有行内元素的特点，只能让这些元素脱离标准文档流（脱标），浮动可以让元素脱离标准文档流，可以实现让多个元素排在同一行并且可以设置宽高。 实现浮动通过浮动属性来实现，float这个属性有两个值left向左浮动，向左移动、right向右浮动，向右移动。 浮动元素的特性 浮动元素脱离标准文档流不再占用空间； 我们可以把浮动元素理解为“漂” 浮动元素的层级比标准文档流里面的元素层级要高,会将标准文档流中的元素给压盖住 行内素浮动后，变成块状元素 清除浮动：只要有浮动那么必须有清除浮动1 为什么要清除浮动? 因为经过浮动元素会影响到下面的元素的排版布局，浮动元素的父元素没有将浮动元素包裹，只要清除了浮动，就不会影响到浮动元素的下面进行排版布局，浮动元素的父元素会将浮动元素从视觉上包裹着。 2 清除浮动有以下三种方法: 给浮动元素的父元素设置一个固定的高度 使用清除浮动的样式属性 clear.（clear:left清除左浮动, clear: right:;清除右浮动 clear: both两者都清除）,这个属性一般用在最后一个浮动元素的下面,在最后一个浮动元素的下面（不是子级，而是并列下一行）新建一个空白的div,这个div什么内容都不要放,只做一件事件，就是清除浮动 使用 overflow: hidden这个属性来清除浮动 注意*：使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围 JS30的第13个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/30/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Slide-in-on-scroll-13/"},{"title":"【原生javascript项目】Reference VS copy 14","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第14天的“JS中引用和复制区别”项目。Have fun with the website! ♪(^∇^*) 项目描述本项目主要是在javascript中对比引用和复制变量的区别，效果在console（控制台）中显示。 项目重点 对于基础类型的值，存储的是值 number string boolean 对于复杂类型的值，存储的是引用（指针） arr object regx 对于复杂类型的值，如果实现复制 arr Array.prototype.slice() Array.prototype.concat() ES6 扩展语法 Array.from() 对象 Object.assign() JSON 转换 项目过程JS部分 首先从 String、Number、Boolean 类型的值开始。 12345let age = 100;let age2 = age;console.log(age, age2); // 100 100age = 200;console.log(age, age2); // 200 100 改动age不会影响age2。 对于数组 123456const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];const team = players;console.log(players, team);team[3] = 'Lux';console.log(players, team); // [&quot;Wes&quot;, &quot;Sarah&quot;, &quot;Ryan&quot;, &quot;Lux&quot;] [&quot;Wes&quot;, &quot;Sarah&quot;, &quot;Ryan&quot;, &quot;Lux&quot;] 对数组进行和Number类型相同的复制操作，发现改动team会改变players。 结论：基础类型（number,string,boolean）将内容直接存储在栈中（大小固定位置连续的存储空间），记录的是该数据类型的值，即直接访问，基础类型赋值是复制（copy）； 复杂类型（object即广义的对象类型（arr,object,regx））将内容存储在堆中，堆所对应的栈中记录的是指针（堆的地址），外部访问时先引出地址，再通过地址去找到值所存放的位置。复杂类型赋值是地址引用。 数组的复制 方法一 Array.prototype.slice() 123const team2 = players.slice();team2[3] = 'Lux2';console.log(players, team2); 方法二 Array.prototype.concat() 123const team3 = [].concat(players);team3[3] = 'Lux3';console.log(players, team3); 方法三 ES6 扩展语法 123const team4 = [...players];team4[3] = 'Lux4';console.log(players, team4); 方法四 Array.from() 123const team5 = Array.from(players);team5[3] = 'Lux5';console.log(players, team5); 对象的复制 方法一 Object.assign() 123456const person = { name: 'Wes Bos', age: 80 };const cap2 = Object.assign({}, person, { number: 99, age: 12 });console.log(cap2); // Object {name: &quot;Wes Bos&quot;, age: 12, number: 99} 方法二 JSON 转换 12345678910111213const wes = { name: 'Wes', age: 100, social: { twitter: '@wesbos', facebook: 'wesbos.developer' }};const dev = Object.assign({}, wes);const dev2 = JSON.parse(JSON.stringify(wes));console.log(wes);console.log(dev);console.log(dev2); 项目补充ES6扩展运算符符号：... 作用：将数组或对象进行展开 例如，对于数组arr=[1,2,3] console.log(…arr)相当于for循环把arr中每个元素打印一下。 参考博客1 js 值引用和值复制 2 对象引用和复制 3 总结 ES6 扩展运算符（…） 4 未枝丫的JS30博客 JS30的第14个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/01/31/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Reference-VS-copy-14/"},{"title":"【原生javascript项目】Local storage 15","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第15天的“JS window属性： localStorage ”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/localStorage/ 项目描述本项目是一个可添加项目的点菜清单，刷新网页时，菜单信息不会清空。实现该功能的主要技术是JavaScript Window 对象的localStorage属性。 项目重点 localStorage localStorage.setItem localStorage.getItem JS取消默认行为 event.preventDefault reset() 方法 把表单中的元素重置为默认值 JSON 的方法 JSON.stringify JSON.parse 项目过程HTML部分 网页logo &lt;svg&gt;标签 菜品清单内容 标题&lt;h2&gt; 菜单项目&lt;ul&gt; 添加菜品表单&lt;form&gt; 1234567891011&lt;div class=&quot;wrapper&quot;&gt; &lt;h2&gt;LOCAL TAPAS&lt;/h2&gt; &lt;p&gt;&lt;/p&gt; &lt;ul class=&quot;plates&quot;&gt; &lt;li&gt;Loading Tapas...&lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;add-items&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;item&quot; placeholder=&quot;Item Name&quot; required&gt; &lt;input type=&quot;submit&quot; value=&quot;+ Add Item&quot;&gt; &lt;/form&gt; &lt;/div&gt; CSS部分 菜品项目添加后默认复选框⬜️没有checked 1234.plates input + label:before {content: &quot;⬜️&quot;;margin-right: 10px;} 菜品项目checked后方框变成其他图标 123.plates input:checked + label:before {content: &quot;🌮&quot;;} JS部分 form表单中若有type 属性是 “submit”的元素，则具有submit 事件 1234function addItem(){ console.log('hello')}addItems.addEventListener('submit', addItem); 当点击form中的提交按钮时，会提交表单并且刷新页面（可在控制台中看出闪现hello），这种默认行为可以通过 e.preventDefault来阻止 123function addItem(e){ e.preventDefault();} 下面开始正式编写addItem函数，用来获取form中添加的元素，然后放到items变量中存储起来 this.querySelector('[name=item]')选择type为text元素的值（输入框输入的内容） 构造一个对象 item 来存储这个信息 把item push到提前创建的items（所有菜单）中 1234567const text = (this.querySelector('[name=item]')).value;// 构造一个对象 item 来存储这个信息item = { text, // ES6中对 text: text, 的简写 done:false // 标记有没有checked}items.push(item); 执行populateList(items, itemsList)函数，把新添加的菜品显示到页面中 更新localStorage中的items数据 重置输入框的值 123populateList(items, itemsList);localStorage.setItem('items', JSON.stringify(items));this.reset(); 编写populateList函数，实现将items中的信息挂载到DOM树上 &lt;input&gt;标签实现的复选框 data-index属性标记菜品序号 &lt;label&gt;标签记录菜单的文字 12345678910function populateList(plates = [], platesList) { platesList.innerHTML = plates.map((plate, i) =&gt; { return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=${i} id=&quot;item${i}&quot; ${plate.done ? 'checked' : ''} /&gt; &lt;label for=&quot;item${i}&quot;&gt;${plate.text}&lt;/label&gt; &lt;/li&gt; `; }).join('');} 程序写到这里基本完成，但是仔细观察会发现，如果checked每个菜品，刷新页面后，这个状态会被刷新（不被保留），这是因为我们并没有更新items中done的值 所以还需编写toggleDone函数，通过菜品click事件触发 e.target.dataset.index可以获取利用data-index属性标记菜品序号 !items[index].done否操作 更新localStorage和HTML页面 12345678910function toggleDone(e) { if (!e.target.matches('input')) return; // skip this unless it's an input // console.log(e.target) const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; localStorage.setItem('items', JSON.stringify(items)); populateList(items, itemsList); }itemsList.addEventListener('click', toggleDone); 项目补充HTML &lt;input&gt; 标签的 required 属性required 属性规定必需在提交之前填写输入字段 JS-preventDefault() 取消默认行为语法：event.preventDefault() 该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。 常用情景： 如果 type 属性是 “submit”，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。 标签在form表单中时，click事件默认会提交表单刷新页面，调用可方法，可避免刷新页面 a 标签点击时，会跳转url，采用如下方式，可防止链接打开 URL： 常用情景的知识点来源于博客 JSON.parse和JSON.stringifyJSON对象在所有现代浏览器中都适用，他有两个非常有用的方法是parse()和stringify(). JSON.parse() 把一个JSON字符串转变成JS对象 1234let userStr = '{&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;}';let userObj = JSON.parse(userStr);console.log(userObj);// {name: 'Sammy', email: 'sammy@example.com', plan: 'Pro'} JSON.parse() 第二个参数可以是一个自定义函数，具有返回值 123456789let userStr = '{&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;}';let userObj = JSON.parse(userStr, (key, value) =&gt; { if (typeof value === 'string') { return value.toUpperCase(); } return value;});console.log(userObj);// {name: 'SAMMY', email: 'SAMMY@EXAMPLE.COM', plan: 'PRO'} JSON.stringify() 把一个JS对象转变成JSON字符串 12345678let userObj = { name: &quot;Sammy&quot;, email: &quot;sammy@example.com&quot;, plan: &quot;Pro&quot;};let userStr = JSON.stringify(userObj);console.log(userStr);// {&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;} JSON.stringify()可以有两个额外参数 一个replacer参数（是一个自定义函数，函数名为replacer) 123456789101112131415let userObj = { name: &quot;Sammy&quot;, email: &quot;sammy@example.com&quot;, plan: &quot;Pro&quot;};function replacer(key, value) { console.log(typeof value); if (key === 'email') { return undefined; } return value;}let userStrReplacer = JSON.stringify(userObj, replacer);console.log(userStrReplacer);// {&quot;name&quot;:&quot;Sammy&quot;,&quot;plan&quot;:&quot;Pro&quot;} 一个是space参数（是 String 或者 Number 值），用来控制间距 如果是Number，缩进为空格数(1-10) 如果是String，缩进为该字符串 123456JSON.stringify({ uno: 1, dos: 2 }, null, '\\t');// returns the string:// '{// &quot;uno&quot;: 1,// &quot;dos&quot;: 2// }' map()和forEach()的区别和理解两个方法都可以实现元素遍历，但是map方法可以用返回值，而forEach方法没有返回值 参考博客 JS-preventDefault() 取消默认行为 How To Use JSON.parse() and JSON.stringify() Example of using JSON.stringify() with localStorage map()和forEach()的区别和理解 JS30的第15个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/04/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Local-storage-15/"},{"title":"【原生javascript项目】Mouse Move Shadow 16","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第16天的“文字阴影随鼠标移动”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/mouseMoveShadow/ 项目描述本项目实现的是一个文字阴影随鼠标位置移动的特效。其中文字阴影是通过添加CSS的text-shadow属性实现的，为了让文字阴影随鼠标位置移动，需要获取当前鼠标的位置，通过一些转化变成对应的文字阴影位置。 项目重点 CSS的text-shadow属性 text-shadow: 10px 10px 0 rgba(0,0,0,1), 10px 20px 0 rgba(200,0,0,1); HTMLElement的一些只读属性 offsetWidth offsetHeight offsetLeft offsetTop 鼠标事件的一些属性 offsetX offsetY 项目过程HTML部分 类名为hero的div元素 h1标签，加了contenteditable属性，表示浏览网页的用户可以编辑 CSS部分 让网页主题内容水平、垂直居中 123display: flex;justify-content: center;align-items: center; 让文字具有阴影（后面再JS中会修改） 12345h1 { text-shadow: 10px 10px 0 rgba(0,0,0,1); /* text-shadow: 10px 10px 0 rgba(0,0,0,1), 10px 20px 0 rgba(200,0,0,1); */ font-size: 100px;} JS部分 首先创建三个变量，一个指向类名为hero的元素，一个指向h1元素，最后一个变量walk用来存储文字阴影距离原文字最大距离的一半。 监听hero上的mouseover的事件，回调函数为shadow 回调函数要实现的是，获取鼠标移动事件的位置offsetX和offsetY，通过一些公式将这两个位置变成新的位置信息，然后修改CSS样式上的text-shadow属性。 首先设置变量width和height存储hero元素的宽高信息 设置变量x和y存储鼠标移动事件的位置信息 12const { offsetWidth: width, offsetHeight: height } = hero;let { offsetX: x, offsetY: y } = e; 这里的写法采用了ES6的**解构赋值写法**，语句let { offsetX: x, offsetY: y } = e;等同于let x = e.offsetX; let y = e.offsetY; offsetX/offsetY：鼠标位置（相对于最近父元素的坐标） offsetWidth/offsetHeight：元素的宽高（width+padding+border） 转换的公式如下所示，其中x/width是一个比例系数 12const xWalk = Math.round((x / width * walk) - (walk / 2));const yWalk = Math.round((y / height * walk) - (walk / 2)); 利用JS修改CSS中的text-shadow属性，具体来说有四个文字阴影，分布在text的四个角落 123456text.style.textShadow = `${xWalk}px ${yWalk}px 0 rgba(255,0,255,0.7),${xWalk * -1}px ${yWalk}px 0 rgba(0,255,255,0.7),${yWalk}px ${xWalk * -1}px 0 rgba(0,255,0,0.7),${yWalk * -1}px ${xWalk}px 0 rgba(0,0,255,0.7)`; 程序写到这里会出现一个bug，当鼠标移动到h1时，文字阴影没有在文字中聚焦，这是因为鼠标移动到h1时，offsetX表示的是相对于h1的位置；当鼠标移动在hero上时，offsetX表示的是相对于hero的位置。 所以还需要添加在shadow函数中，首先需要做个条件判断 1234if (this !== e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop;} 写到这里程序就大体完成啦！具体代码我放在了github上。 项目补充JavaScript中event.target与this区别this一直指向函数的调用者，在本程序中，鼠标无论移动到hero上还是h1上，console.log(this)显示的一直是 123&lt;div class=&quot;hero&quot;&gt; &lt;h1 contenteditable style=&quot;text-shadow: rgba(255, 0, 255, 0.7) 241px 101px 0px, rgba(0, 255, 255, 0.7) -241px 101px 0px, rgba(0, 255, 0, 0.7) 101px -241px 0px, rgba(0, 0, 255, 0.7) -101px 241px 0px;&quot;&gt;🔥WOAH!&lt;/h1&gt;&lt;/div&gt; 而event.target指向的是触发该事件的目标节点，在本程序中，鼠标移动到hero上，显示内容和上述一样，但是移动到h1上时，显示内容为 1&lt;h1 contenteditable style=&quot;text-shadow: rgba(255, 0, 255, 0.7) 241px 101px 0px, rgba(0, 255, 255, 0.7) -241px 101px 0px, rgba(0, 255, 0, 0.7) 101px -241px 0px, rgba(0, 0, 255, 0.7) -101px 241px 0px;&quot;&gt;🔥WOAH!&lt;/h1&gt; 因此，this与event.target的区别为当含有事件冒泡时，this一直指向该函数的调用者，而event.target则指向触发该事件的目标节点 ES6 解构赋值解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。 以前，为变量赋值，只能直接指定值。 123var a = 1;var b = 2;var c = 3; ES6允许写成下面这样。 1var [a, b, c] = [1, 2, 3]; 上述为数组赋值。 对于对象赋值，可以写成在这样 1var { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; 如果变量名与属性名不一致，必须写成下面这样 1234let obj = { first: 'hello', last: 'world' };let { first: f, last: l } = obj;f // 'hello'l // 'world' 参考博客 ES6 变量的解构赋值 JavaScript中event.target与this区别 JS30的第16个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/10/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Mouse-Move-Shadow-16/"},{"title":"【原生javascript项目】Sort without Articles 17","text":"作者：©Iaine 万一简介：30 Day Challenge是 Wes Bos 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。 本项目为第16天的“文字阴影随鼠标移动”项目。Have fun with the website! ♪(^∇^*) 网页效果： https://janice143.github.io/sortWithoutArticles/ ![](https://github.com/janice143/myblog.github.io/blob/master/images/js30_Sort Without Articles17.png?raw=true) 项目描述本项目首先给定了一个内容为band名字的列表bands，在JS中，对列表进行特殊的排序操作，得到新的列表最终以列表的形式显示到网页中。 其中特殊的排序操作，具体来说，是先去除列表元素中”a, an, the”的前缀，然后按照字母排序。排序的列表还是原列表，无需使列表元素去除特定前缀。 项目重点 字符串的一些方法 String.prototype.replace() String.prototype.trim() 数组的一些方法 Array.prototype.sort() 正则表达式 /^(a |the |an )/i 项目过程HTML部分 id 属性为bands的ul元素，列表内容在JS中添加 JS部分 首先提供一个已知列表bands 将列表bands内容显示到网页中 1document.querySelector('#bands').innerHTML = bands.map(band =&gt; `&lt;li&gt;${band}&lt;/li&gt;`).join(''); 显示已经实现，下一步我们需要对bands进行一些操作，得到的新列表再按照上述方法显示到网页中。注意：无需对原列表bands进行操作，也就是不用改变bands的值 去除前缀 123function strip(bandName){ return bandName.replace(/^(a |the |an )/i,'').trim();} 排序 12345const sortedBands = bands.sort( function(a,b){ return strip(a) &gt; strip(b) ? 1 : -1 }) 程序写到这里就已经ok啦！本项目需要注意的是最后显示的内容还是原bands中的元素，但是排序方式要求去掉前缀后排序。 如果项目要求最后显示的内容是去除前缀的元素，那么下面的程序提供了一个实现思路： 去除前缀 123456// 先将bands元素中开头为a|the|an的去掉前缀，返回新的bandsfunction newBands(bands){ return bands.map(band =&gt; { return band.replace(/^(a |the |an )/i,'').trim(); })} 排序 1const sortedBands = newBands(bands).sort() 项目补充String.prototype.replace()replace(pattern,replacement) 方法返回一个新字符串，该字符串由replacement替换部分或所有的pattern匹配项后的新字符串。 pattern可以是一个字符串或者一个正则表达式，replacement可以是一个字符串或者一个每次匹配都要调用的回调函数。 如果pattern是字符串，则仅替换第一个匹配项。 原字符串不会改变。 语法1str.replace(regexp|substr, newSubStr|function) String.prototype.trim()从一个字符串的两端删除所有空白字符。 Array.prototype.sort()1arr.sort([compareFunction]) 主要讲讲有compareFunction的情况，该函数具有两个参数a,b。 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 例如比较数字，compareFunction函数可以简单的以 a 减 b，如下的函数将会将数组升序排列 1234567function compareNumbers(a, b) { return a - b;}// 也可以这样些function compareNumbers(a, b) { return a &gt; b ? 1 : -1;} 正则表达式的特殊字符 ^匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。 例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 参考博客 正则表达式中的特殊字符 JS30的第17个项目圆满完成啦，感谢阅读，有问题联系我的邮箱1803105538@qq.com.","link":"/myblog.github.io/2022/02/14/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Sort-without-Articles-17/"}],"tags":[{"name":"原生javascript项目","slug":"原生javascript项目","link":"/myblog.github.io/tags/%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE/"}],"categories":[{"name":"30个原生javascript项目","slug":"30个原生javascript项目","link":"/myblog.github.io/categories/30%E4%B8%AA%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE/"}]}
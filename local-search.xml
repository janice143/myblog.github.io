<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态规划算法讲解</title>
    <link href="/myblog.github.io/2023/06/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    <url>/myblog.github.io/2023/06/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>动态规划（dynamic programing）是一种常用的算法，主要用于最优问题的求解。其思路是通过将原问题分解为子问题，子问题有一个最优解，再将子问题的最优解组合起来得到原问题的最优解。动态规划算法的时间复杂度通常为 O(n^2) （多项式）。</p><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><p>一个问题可以通过动态规划的思路解决，该问题具有两个必要条件：</p><ul><li>具有<code>最优子结构</code>特性</li></ul><p>问题的子问题的解是最优的，并且子问题的最优解可以推到问题的最优解，就称该问题具有最优子结构特性</p><ul><li>具有<code>重复子问题</code>特性</li></ul><p>求解当前子问题时存在重复特性，该子问题被分为多个子问题，有些子问题已经被计算过。换句话说，求解f(n)和f(n-1)都要求解f(n-2)，而且求解f(n)还要求解f(n-1)，所以存在重复求解f(n-2)的情况。</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><p>关于动态规划的解题步骤，我们需要先明白几个定义：</p><ul><li>状态</li></ul><p>求解dp问题可以理解为求解dp数组。状态可以理解为数组的每个元素dp[i]，动态规划解题的关键之一在于定义状态的含义。</p><ul><li>状态转移方程</li></ul><p>可以理解为描述问题和子问题关系的数学公式，例如，$f(n)=g(f(n-1))$</p><ul><li>自顶向下和自底向上</li></ul><p>自顶向下就是先求f(n)，再求f(n-1)，再求f(n-2)。存在重复求解的缺点，所以可以用<code>备忘表</code>（Memoization）优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">函数f(n)：<br><br><span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>)<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to n<br> dp[i] = f(n-i)<br><span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><p>可以通过画节点来理解为什么是从顶到下。</p><p>自底向上就是先求f(1)，f(2)，再求f(n)。子问题按顺序求解，当求解某个子问题时，所依赖的更小子问题已经求解好了，可以直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">函数f(n)：<br><br><span class="hljs-keyword">if</span>(n === <span class="hljs-number">0</span>)<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> to n<br> dp[i] = dp[i-<span class="hljs-number">1</span>]+dp[i-<span class="hljs-number">2</span>]<br><span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><p>自底向上的代码更简洁，所以可以作为首选。</p><ul><li>base case</li></ul><p>递归结束的条件。</p><p><strong>解题步骤</strong></p><ul><li>定义状态</li><li>确定转移方程</li><li>列举base case</li><li>计算最优解<ul><li>自顶向下还是自底向上</li><li>如何优化算法（剪枝，备忘录）</li></ul></li></ul><p>很多文章会分为5个步骤，而且描述也不同，但是这些文章本质都是解释同一类型的问题。大家在阅读的时候可以多看几篇相关的文章，总结出自己的理解模式。</p><h2 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h2><p>理解动态规划的经典入门题就是求解斐波那契函数。如果没有学习动态规划，可能很多同学可以通过暴力递归求解。学习了动态规划后，你可以使用备忘录去存储已经计算过的结果，避免重复计算来优化算法。</p><h3 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> fib = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="备忘录（自顶向下）"><a href="#备忘录（自顶向下）" class="headerlink" title="备忘录（自顶向下）"></a>备忘录（自顶向下）</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> fib = <span class="hljs-function">(<span class="hljs-params">n, memo = &#123;&#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (n <span class="hljs-keyword">in</span> memo) <span class="hljs-keyword">return</span> memo[n];<br><br>  result = fib(n - <span class="hljs-number">1</span>, memo) + fib(n - <span class="hljs-number">2</span>, memo);<br>  memo[n] = result;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> fib = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> dp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> dp[n];<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到，每次计算dp[n]的时候，dp[i-1]，dp[i-2]都是已知的。这就是自底向上，按顺序求解问题。</p><h3 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h3><p>上述求解斐波那契函数可能还看不出动态规划算法里的状态和状态转移。接下来，我们通过举例”爬楼梯“的算法题来分析和理解什么是状态，什么是状态方程，以及体验如何拆分问题。</p><p>刷过leetcode的同学都知道有一个比较经典的题目叫做<a href="https://leetcode.cn/problems/climbing-stairs/">”爬楼梯“问题</a>。这个问题本质就是写斐波那契函数的求解方法，可以参考上一节，本节重点理解动态规划。</p><aside>❓ 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></aside><ol><li>怎么拆问题</li></ol><p>思考如果你在第n个阶梯，你的上一步有两种情况：你在n-1阶梯，还要爬1阶；你在n-2阶梯，还要爬2阶。</p><p>对于第1种情况，你在n-1阶梯，那么你的上一步又有两种情况：n-2或者n-3。</p><p>以此类推，可以发现，你在第3个阶梯时，上一步的两种情况是在1阶梯或者2阶梯，有2种方法可以到达：1 → 2 → 3; 1 → 3。</p><p>你在第2阶梯时，上一步就是1阶梯，只有1种方法；</p><p>你在第1阶梯时，没有上一步，只有1种方法。</p><p>所以通过分析可知，处在n阶梯位置，要综合考虑n-1阶梯和n-2阶梯位置的方法，确切地说，就是这二者的和。我们可以用数学上的函数f(n)表示处在n阶梯上对应的方法数，那么f(n)=f(n-1)+f(n-2）。</p><ol><li>考虑状态</li></ol><p>上面假设的f(n)就是状态，其实我们已经定义好了状态，就是处在n阶梯上对应的方法数，对于动态规划算法，一般状态我们用dp变量描述，此处的数据结构可以简单地使用数组即可。</p><ol><li>考虑状态方程</li></ol><p>当前问题和子问题之间的递归关系式就是dp[n]=dp[n-1] +dp[n-2]。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/20432061/">《算法导论》 Thomas</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【单测】单测入门 A Beginner&#39;s Guide to Writing Unit Tests for React Components with Jest and React Testing Library</title>
    <link href="/myblog.github.io/2023/06/21/%E3%80%90%E5%8D%95%E6%B5%8B%E3%80%91%E5%8D%95%E6%B5%8B%E5%85%A5%E9%97%A8/"/>
    <url>/myblog.github.io/2023/06/21/%E3%80%90%E5%8D%95%E6%B5%8B%E3%80%91%E5%8D%95%E6%B5%8B%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>作为一个初学者，第一次接触单测的时候，我其实有很多疑问，单测是什么，为什么要做单测，如何做单测，最佳实践是什么。</p><p>怎么罗列测试用例，如何调试代码</p><p>本文就是一篇浅浅的入门指南。主要围绕上面这些问题做一些解答和记录。</p><h2 id="单测是什么"><a href="#单测是什么" class="headerlink" title="单测是什么"></a>单测是什么</h2><p>单测就是单元测试，属于软件开发中的一个测试方法。正如其名字一样，单元测试关注的是代码中比较小的单元，可能是一个函数，一个方法，甚至一个属性。只要在逻辑上可以独立存在的，都是单元测试可进行的对象。</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>减少上线bug，可以保证我们写的代码按照预想的执行。同时，对于代码维护也可得带来更高效率。</p><h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p>主要围绕如何进行javascript代码的单元测试讲解。（单元测试是软件工程里的概念，不应该只局限与前端，由于网上的资源看起来很繁杂，我暂时没有建立起一个完整的单测认识，所以这篇文章暂时只局限于unit test with javascript）</p><h3 id="选择一个测试框架JavaScript-unit-testing-framework"><a href="#选择一个测试框架JavaScript-unit-testing-framework" class="headerlink" title="选择一个测试框架JavaScript unit testing framework"></a>选择一个测试框架JavaScript unit testing framework</h3><p>关于js的单测框架，目前使用最多的是Jest 和mocha，下面这张图给出了2016年到2021年框架使用比例图。（主要是js的发展很快，所以基于js的工具也要不断迭代和更新）</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5038ccd6-04f5-4373-9086-6180b6292a03/Untitled.png" alt="Untitled"></p><p>如果第一次接触单测，肯定要选择使用最多的，因为参考资料多，不管是学习好还是开发过程中遇到问题，都能很容易找到相关的资料。还有一个好处是，使用多意味着这个工具被维护的可能性更高且更持久。</p><h3 id="Jest测试框架"><a href="#Jest测试框架" class="headerlink" title="Jest测试框架"></a>Jest测试框架</h3><p>有两个网站我推荐看，我相信会有很多收获。</p><p><a href="https://jestjs.io/docs/getting-started">Getting Started · Jest</a></p><p><a href="https://www.softwaretestinghelp.com/jest-testing-tutorial/">Jest Tutorial - JavaScript Unit Testing Using Jest Framework</a></p><p><a href="https://www.lambdatest.com/jest">Jest Tutorial: Complete Guide to Jest Testing</a></p><p>第三个文档我只简易看目录。具体内容我觉得他写的很简陋，所以不简易看。</p><p>首先根据官网的文档，可以着手写一个简单的单元测试。测试总的来说就是输入-预测输出-判断结果的过程（<strong>input - expected output - assert the result）</strong></p><p>我认为一个技术官网上的东西初学的时候不需要全部看完，技术官网是一个工具网站，我们可以把他看成是一个字典，遇到不认识的字的时候再使用它。对于一个技术网站，首先就是要快速了解这个技术最基本的几个东西是什么，比如说jest，最基本的就是如何输入命令使用、积累一些常用的matchers。如何判断哪些最基本，你可以根据js的基本知识来学习，在学js的时候，逻辑运算、字符串什么都是是常用的，所以学习jest的时候你需要了解一些对应的匹配器；页面上的交互经常涉及到一些click,change事件，这是jest有一些mock函数需要了解。等等。</p><h3 id="测什么"><a href="#测什么" class="headerlink" title="测什么"></a>测什么</h3><p>How do I know what to test?当你对jest有个初步的实操之后，下一个关注的问题是测什么？</p><p>如果是写一个页面的话，页面上每个组件、每个交互理论上都需要测试。如果自己罗列，难免有遗漏的地方，所以在jest中有个coverage的概念（<strong><strong>Code coverage in Jest）</strong></strong>，可以把它理解为Jest的一个命令或者工具，可以告诉我们代码中哪些需要测的地方。执行完这个命令后，甚至有一个可视化的Html页面可以直观地看到测试覆盖率。</p><h3 id="test-React-with-Jest"><a href="#test-React-with-Jest" class="headerlink" title="test React with Jest"></a><strong><strong>test React with Jest</strong></strong></h3><p>了解到这里，我们知道了简单的基于js的单元测试，使用的单测框架是jest。为了最佳实践，下一步我们要把单测和前端框架结合，以react框架为例，还是因为react使用的最多。</p><p>针对react组件库的测试，需要用到另一个有用工具</p><p><a href="https://testing-library.com/docs/react-testing-library/intro">React Testing Library | Testing Library</a></p><p>另外推荐阅读这两篇文章</p><p><a href="https://www.softwaretestinghelp.com/testing-react-apps-using-jest/">Jest React Tutorial - How To Test React Apps Using Jest Framework</a></p><p><a href="https://www.valentinog.com/blog/testing-react/">Testing React Components with react-test-renderer, and the Act API</a></p><p>我目前还是有疑问，snapshot到底在什么时候推荐使用。这个问题我还在思考中。尽管我搜索了不少答案，甚至问了chatgpt，我还是没有一个具体答案。</p><h3 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h3><p>不重要但是必不可少的是我们得知道如何调试代码。</p><p><a href="https://www.softwaretestinghelp.com/jest-configuration-and-debugging/">Jest Configuration And Debugging Jest Based Tests</a></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h2><p>have fun！这篇文章并没有给出具体的命令，也没有代码实例，只是给出了一些初步的理解，以及如何找到最佳实践，其中给了一些参考博客。我觉得对于一个有基础的前端开发基础，但是缺乏软件工程完整体系，且想了解单侧的同学来说，这篇文章会有一点点帮助。</p>]]></content>
    
    
    <categories>
      
      <category>unit test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unit test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>useCallback使用讲解</title>
    <link href="/myblog.github.io/2023/05/28/useCallback%E4%BD%BF%E7%94%A8%E8%AE%B2%E8%A7%A3/"/>
    <url>/myblog.github.io/2023/05/28/useCallback%E4%BD%BF%E7%94%A8%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>作为 react 框架内置的 hooks 之一，我们知道这个 hook 可以实现缓存，进而提升页面性能。那么这个 hook 究竟可以在什么场景下使用呢？本文针对这个问题进行了探讨。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">const</span> cachedFn = useCallback(fn, dependencies);<br></code></pre></td></tr></table></figure><p>可以看到，useCallback 的入参有两个：函数和依赖。返回的是一个函数定义。</p><p>useCallback 可以缓存函数定义，只有当依赖中的数据更新后，才会重新创建函数，否则，使用的函数是上一次渲染时存储的函数。</p><h2 id="理解-useCallback"><a href="#理解-useCallback" class="headerlink" title="理解 useCallback"></a>理解 useCallback</h2><ol><li>普通的函数定义</li></ol><p>通过点击按钮让数字增加的时候，由于 cnt 的 state 更新，导致整个组件重新渲染，函数 increment 重新创建。</p><iframe src="https://codesandbox.io/embed/friendly-easley-m8f49g?fontsize=14&hidenavigation=1&module=%2Fsrc%2Fpages%2Fnormal-fn.js&theme=dark"  style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;"  title="friendly-easley-m8f49g"  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><ol><li>普通函数包裹了 useCallback</li></ol><p>increment 函数被 useCallback 包裹，当点击按钮时，cnt 更新，组件重新渲染。但是 cnt 加到 1 后就无法继续增长。</p><p>这是因为 useCallback 缓存了 increment 函数，每次点击按钮的时候，使用的是上一次缓存的函数，这个时候 cnt 的值都是 0，所以后面点击按钮时， cnt 无法继续往上加。</p><iframe src="https://codesandbox.io/embed/friendly-easley-m8f49g?fontsize=14&hidenavigation=1&initialpath=useCallback-case&module=%2Fsrc%2Fpages%2FuseCallback-case.js&theme=dark"  style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;"  title="friendly-easley-m8f49g"  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>如果想让 cnt 继续累加，可以在 useCallback 的第二个参数上绑定依赖：<code>[cnt]</code>。</p><p>但是这个做法并没有体现 useCallback 的缓存优势，更糟糕的是，这种错误使用 useCallback，需要额外产生监视 cnt 变化的性能消耗。</p><p>但是好在我们观察到了使用 useCallback 和不使用的区别。这是理解 useCallback 的第一步。</p><ol start="3"><li>useCallback 缓存的是什么</li></ol><p>缓存的是具有相同内存地址的函数定义。每次重新创建一个函数，该变量都会指向不同的内存地址，useCallback 缓存的上上一个创建函数时的内存指针。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-string">&quot;string&quot;</span> === <span class="hljs-string">&quot;string&quot;</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> === <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">true</span> === <span class="hljs-literal">true</span> <span class="hljs-comment">// true</span><br>&#123;&#125; === &#123;&#125; <span class="hljs-comment">// false</span><br>[] === [] <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">const</span> f = <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;Hi&#x27;</span><br><span class="hljs-keyword">const</span> f1 = f<br><span class="hljs-keyword">const</span> f2 = f<br><br>f1 === f1 <span class="hljs-comment">// true</span><br>f1 === f2 <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ol start="4"><li>为什么要缓存函数定义？</li></ol><p>如果函数作为 react 的 hooks 上的依赖，或者子组件的参数等场景，如果不使用 useCallback 进行缓存，每次函数创建都会返回一个新的函数定义（有点像创建一个变量，然后赋值空对象，这些对象执行的内存都不同，所以===时不相等），这样就会导致 hooks 内部重新执行或者子组件重新渲染。</p><h2 id="useCallback-使用场景"><a href="#useCallback-使用场景" class="headerlink" title="useCallback 使用场景"></a>useCallback 使用场景</h2><ol><li>减少组件重新渲染：子组件传入一个函数，且子组件被 React.memo 缓存了。</li></ol><p>shippingForm 是一个人为增加了性能的组件，每次 count 增加的时候，该组件都要重新渲染，每次渲染性能都消耗很大，所以可以看到，点击+的时候，页面会出现很卡的效果。</p><p>但是当我们勾选（或取消）dark mode，发现这个页面切换是非流畅。这是因为 ShippingForm 并没有重新渲染。为什么呢？</p><p>每次切换白天/黑夜背景的时候，theme 的状态更新导致 productPage 重新渲染，由于 useCallback 的使用，handleSubmit 函数没有重新创建，所以传递给子组件 ShippingForm 的 props 没有改变，由于 React.memo 的使用，ShippingForm 没有重新渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aside">&lt;aside&gt;<br>  💡  注：React.memo的用法是用来包裹整个组件，当props参数都不变（引用不变）时，组件不会重新渲染。<br>&lt;/aside&gt;<br></code></pre></td></tr></table></figure><iframe src="https://codesandbox.io/embed/elegant-chatelet-5urqn7?fontsize=14&hidenavigation=1&module=%2FProductPage.js&theme=dark"  style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;"  title="elegant-chatelet-5urqn7"  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><ol start="2"><li>减少函数重新创建</li></ol><p>state 状态变化，导致页面重新渲染，为了减少函数创建，可以使用 useCallback 进行缓存</p><p>只看下面代码中的 useEffect 和 addGuessedLetter 函数，每次触发按键事件，guessedLetters 的值会更新，使得页面渲染，如果不使用 useCallback，addGuessedLetter 函数会在每次渲染的时候重新创建。</p><p>我们并不希望他重新创建，如果这个函数内部没有 setState，我们可以放到组件外面解决这个问题，但是这个函数有。为了减少函数创建，可以给这个函数包裹 useCallback，并且不要添加任何依赖。这样可以保证 addGuessedLetter 函数只被创建一次。尽管这个函数只被创建了一次，但是每次 setGuessedLetters 都会用到上一个 guessedLetters 的值，这是因为<code>setGuessedLetters((curLetters) =&gt; [...curLetters, letter]);</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于 useCallback 何时使用问题，其实主要把握一个点就行：useCallback 的功能就是缓存函数定义，如果你不希望函数由于重新创建产生新的定义，而导致多余渲染或者不必要重复执行，那就可以用 useCallback 进行缓存。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://react.dev/reference/react/useCallback#examples-rerendering">react 文档官方示例</a></p></li><li><p><a href="https://www.freecodecamp.org/news/better-react-performance-usecallback-vs-usememo/">Better React Performance – When to Use the useCallback vs useMemo Hook</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>React Hooks</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>【leetcode124】Binary Tree Maximum Path Sum</title>
    <link href="/myblog.github.io/2023/05/23/leetcode124%20Binary%20Tree%20Maximum%20Path%20Sum/"/>
    <url>/myblog.github.io/2023/05/23/leetcode124%20Binary%20Tree%20Maximum%20Path%20Sum/</url>
    
    <content type="html"><![CDATA[<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>Given a binary tree, return the maximun sum of the path. A path is a sequence of adjacent nodes which are connected by an edge. The node in a path can only show once. Particulary, a single node is a special path, and the sum of this path is the value of the node.</p><p>you can see the examples in the source link of this leetcode problem.</p><p><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/">https://leetcode.com/problems/binary-tree-maximum-path-sum/description/</a></p><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>Any node can be a path, thus it has a sum value. If a node can not split to left or right, the maximum sum of the path starting from this node is the value of itself.</p><p>If a node can split to the next node, and the child node can no longer split, the maximum sum of path is max(left.val,0) + max(0,right.val) + root.val.</p><p>If a node can split to the next node, and the child node can also split, what is the maximun sum of path?</p><p>It’s definately not <em>max sum of the left node + max sum of right node</em>, because in some case there will a illigel path where a single node show more than once. Each node only allow to split to one direction. In order to get the maximun sum, we take the larger direction, that is max(pathSum(root.left)+root.val, pathSum(root.right)+root.val, this can determin which way to go to get the maximum value.</p><p>and the maximum sum of path is max(pathSum(root.left),0) + max(0,pathSum(root.right)) + root.val.</p><p>Note that the maximum result need to update every time you get a maximum number of a node.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * function TreeNode(val, left, right) &#123;</span><br><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="hljs-comment"> *     this.left = (left===undefined ? null : left)</span><br><span class="hljs-comment"> *     this.right = (right===undefined ? null : right)</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;TreeNode&#125;</span> <span class="hljs-variable">root</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxPathSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> maxValue = [-<span class="hljs-literal">Infinity</span>];<br>    getMaxSum(root,maxValue)<br>    <span class="hljs-keyword">return</span> maxValue[<span class="hljs-number">0</span>]<br>&#125;;<br><br><span class="hljs-keyword">const</span> getMaxSum = <span class="hljs-function">(<span class="hljs-params">root, maxValue</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">const</span> left = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>,getMaxSum(root.left, maxValue))<br>    <span class="hljs-keyword">const</span> right = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>,getMaxSum(root.right,maxValue))<br>    maxValue[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(maxValue[<span class="hljs-number">0</span>],left+right+root.val)<br>    <span class="hljs-built_in">console</span>.log(maxValue[<span class="hljs-number">0</span>],left,right)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(root.val+left, root.val+right)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React 学习01</title>
    <link href="/myblog.github.io/2022/10/15/React-%E5%AD%A6%E4%B9%A001/"/>
    <url>/myblog.github.io/2022/10/15/React-%E5%AD%A6%E4%B9%A001/</url>
    
    <content type="html"><![CDATA[<p>学习链接：</p><ol><li><strong><strong><a href="https://scrimba.com/learn/learnreact#">Learn React for free</a></strong></strong></li><li>B站****<a href="https://www.bilibili.com/video/BV1wy4y1D7JT">尚硅谷<em>React教程</em>（2022加更，B站超火<em>react教程</em>）</a>**</li></ol><p>两个学习链接一个是英文，一个是中文。两个我都在用，对比了一下，国内的教程一般时间很长，但是基本都是干货，知识是直接投喂的，重难点也会讲得很清楚。国外的教程更侧重趣味性，看的过程需要自主思考，边看边操练，讲的过程中是对CSS和JS的整个运用，不仅仅是学习react，除此之外，国外的教学视频一般更短一点，一般是通过做小demo学习框架知识，哦！对了，没有做笔记的过程。</p><p>react 17文档：<a href="https://17.reactjs.org/docs/getting-started.html">https://17.reactjs.org/docs/getting-started.html</a></p><p>react 18文档：<a href="https://reactjs.org/docs/getting-started.html">https://reactjs.org/docs/getting-started.html</a></p><h3 id="组件定义的两种方式"><a href="#组件定义的两种方式" class="headerlink" title="组件定义的两种方式"></a>组件定义的两种方式</h3><ol><li><p>函数：适用于简单组件的定义（简单组件就是没有state响应式）</p><p> function Welcome(props) {<br>   return <h1>Hello, {props.name}</h1>;<br> }</p></li><li><p>类：适用于有state的组件</p><p> class Welcome extends React.Component {<br>   render() {</p><pre><code class="hljs"> return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</code></pre><p>   }<br> }</p></li></ol><h3 id="利用Vite工具工程化"><a href="#利用Vite工具工程化" class="headerlink" title="利用Vite工具工程化"></a>利用Vite工具工程化</h3><ol><li><code>npm create vite@latest</code></li><li><code>npm install</code></li></ol><h3 id="react脚手架创建react-app"><a href="#react脚手架创建react-app" class="headerlink" title="react脚手架创建react app"></a>react脚手架创建react app</h3><pre><code class="hljs">npx create-react-app my-appcd my-appnpm start</code></pre><h3 id="组件实例的三大核心属性"><a href="#组件实例的三大核心属性" class="headerlink" title="组件实例的三大核心属性"></a>组件实例的三大核心属性</h3><ol><li><strong>props</strong></li></ol><p>理解：组件使用是的自定义属性，有点像vue的子组件的props属性</p><ul><li><p>props属性是只读的，组件内部无法修改props属性值（和Vue一样，父组件到子组件的数据是单向流动的）</p></li><li><p><a href="https://17.reactjs.org/docs/typechecking-with-proptypes.html">props类型限制的方式</a></p><p>  import PropTypes from ‘prop-types’;<br>  class Greeting extends React.Component {</p><pre><code class="hljs">render() &#123;  return (    &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;  );&#125;</code></pre><p>  }<br>  Greeting.propTypes = {</p><pre><code class="hljs">name: PropTypes.string</code></pre><p>  };<br>  Greeting.defaultProps = {</p><pre><code class="hljs">name: &quot;Lucus&quot;</code></pre><p>  };</p><p>  // 可以写成静态方法/属性<br>  class Greeting extends React.Component {</p><pre><code class="hljs">  static propTypes = &#123;    name: PropTypes.string  &#125;;  static defaultProps = &#123;    name: &quot;Lucus&quot;  &#125;;  render() &#123;    return (      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;    );  &#125;</code></pre><p>  }</p></li><li><p>扩展属性</p><p>  const person = {</p><pre><code class="hljs">    name: &#39;Jace&#39;,    age: 18,    sex: &quot;男&quot;&#125;</code></pre><p>  ReactDOM.render(&lt;Person {…person} /&gt;, root)</p></li></ul><ol><li><strong>state</strong></li></ol><p>理解：响应式状态，是一个对象，里面的数据是响应式的，有点像Vue的data</p><pre><code class="hljs">class Clock extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;date: new Date()&#125;;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Hello, world!&lt;/h1&gt;        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;      &lt;/div&gt;    );  &#125;&#125;// 简写形式，不写构造函数class Clock extends React.Component &#123;  state = &#123;date: new Date()&#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Hello, world!&lt;/h1&gt;        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><ul><li><p>state中的数据不能直接改变，而是通过setState({})</p></li><li><p>组件中自定义方法中的this为undefined，</p><p>解决方式1：bind强制绑定；</p><p>解决方式2：箭头函数（写成赋值语句+箭头函数的形式<code>tick=()⇒&#123;&#125;</code>）</p><p>类里面可以直接写赋值语句，无需关键字声明，相当于给类添加一个属性；并不是所有组件的自定义方法中的this为undefined，要看谁调用，如果是事件处理回调的，那就是Undefined，因为类默认会开启严格模式，这时候This不指向window，而是undefined.</p></li></ul><ol><li><strong>refs</strong></li></ol><p>理解：标签可以用ref属性标识自己，换句话说，可以通过访问refs属性获取节点</p><p>使用方法：</p><ul><li><p><code>creatRef</code>创建：使用<code>this.myRef.current</code> 获取</p><p>  this.myRef = React.createRef();</p><div ref={this.myRef} /> // 已有标签可以添加ref  <CustomTextInput ref={this.textInput} /> // 通过类创建的自定义组件也可以添加ref，但是函数创建的组件不行，因为没有实例</li><li><p>回调函数形式</p><p>  this.inputElement = null<br>  &lt;input</p><pre><code class="hljs">  type=&quot;text&quot;  ref=&#123;el =&gt; this.inputElement = el&#125;/&gt;</code></pre><p>  // 上述的写法为内联形式，在页面更新的时候会调用两次，第一次是null，第二次才是节点el<br>  // 这是因为react每次render的时候，都要重新创建新的实例，所以react要先清空ref的值，然重新赋值<br>  // 可以通过绑定函数的形式避免这个问题，但是影响不大<br>  this.inputElement = null<br>  setTextInputRef = element =&gt; {</p><pre><code class="hljs">this.textInput = element;</code></pre><p>  };<br>  &lt;input</p><pre><code class="hljs">type=&quot;text&quot;ref=setTextInputRef</code></pre><p>  /&gt;</p></li><li><p>字符串形式（不推荐）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">`&lt;input <span class="hljs-built_in">ref</span>=<span class="hljs-string">&quot;input1&quot;</span>/&gt;<br>  <span class="hljs-keyword">this</span>.<span class="hljs-built_in">ref</span>s.input1获取`<br></code></pre></td></tr></table></figure></li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p><code>onXxx</code> 的形式，如<code>onClick, onChange, onFoucs</code> 。为了更好的兼容，所以没有直接使用原生JS事件。</p><p>通过<code>event.target</code> 获取该事件的DOM元素对象，能不使用ref，则不使用。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>17版本以下的声明周期（18版本有些不一样）</p><p><img src="!%5B%5D(https://github.com/janice143/myblog.github.io/blob/master/images/react_life.png?raw=true)"></p><ol><li><strong>初始化阶段:</strong> 由ReactDOM.render()触发—初次渲染<ol><li>constructor()</li><li>componentWillMount() // 即将挂载</li><li>render()</li><li>componentDidMount() // 挂载完毕</li></ol></li><li><strong>更新阶段:</strong> 由组件内部this.setSate()或父组件重新render触发<ol><li>shouldComponentUpdate() // 返回true或者false控制组件是否更新（是否继续后面的流程）</li><li>componentWillUpdate() //组件即将更新</li><li>render()</li><li>componentDidUpdate() // 组件已经更新</li></ol></li><li><strong>卸载组件:</strong> 由ReactDOM.unmountComponentAtNode()触发<ol><li>componentWillUnmount()</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录第二次vue-nodejs-mongodb项目服务器部署</title>
    <link href="/myblog.github.io/2022/09/17/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%BA%8C%E6%AC%A1vue-nodejs-mongodb%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/myblog.github.io/2022/09/17/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%BA%8C%E6%AC%A1vue-nodejs-mongodb%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="记录第二次vue-nodejs-mongodb项目服务器部署"><a href="#记录第二次vue-nodejs-mongodb项目服务器部署" class="headerlink" title="记录第二次vue-nodejs-mongodb项目服务器部署"></a>记录第二次vue-nodejs-mongodb项目服务器部署</h1><p>最近我的腾讯云服务器快要到期了，又租了一个一年的配置一样的云服务器。新服务器又开始了部署问题，在部署之前，我查了一下是否能两台服务器数据之前在线迁移，确实有类似的经验博客，但是我看了一下都不适合我，而且我的两个服务器严格来说是轻量应用服务器，看了官方的教程，也没有找到两个轻量应用服务器之间的在线数据迁移，然后我就开始了重新部署。</p><p>好在我之前把第一次部署的要点记录下来了，大家有需要可以查看【<a href="https://juejin.cn/post/7111593698797846565#heading-24">记录第一次vue-nodejs-mongodb项目服务器部署</a>】。</p><p>这次我按照这个博客重新部署，中途遇到了一些新问题，所以在这里记录了下来。</p><p>在记录之前，先放出我部署成功的个人项目链接</p><p>👉👉👉 <a href="http://43.143.81.10:8080/home">师大Buy 校园闲置交易平台</a> 👈👈👈</p><p>（和之前的版本有一些差异，技术也用了vue3，最近再往ts方向完善）</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>请结合上一篇博客看本文章。【<a href="https://juejin.cn/post/7111593698797846565#heading-24">记录第一次vue-nodejs-mongodb项目服务器部署</a>】</p><h3 id="nodejs安装和配置"><a href="#nodejs安装和配置" class="headerlink" title="nodejs安装和配置"></a>nodejs安装和配置</h3><p>在安装nodejs之后，我需要把建立软连接，但是这一步骤我却没有成功，使用<code>npm -v</code>，<code>node -v</code>说是命令不存在。<code>cd</code>到<code>usr/local/bin</code>目录下面，显示有这两个文件，但是颜色是红色的。</p><p><strong>解决方案</strong>：使用下列语句重新建立软连接。</p><p><code>ln -s /usr/local/src/node-v16.15.1-linux-x64/bin/node /usr/local/bin</code></p><p><code>ln -s /usr/local/src/node-v16.15.1-linux-x64/bin/npm /usr/local/bin</code></p><p>ln命令需要用绝对路径，不能相对路径。比如node在/root/node/bin，使用ln node/bin/node /usr/bin/node不行，而应该ln /root/node/bin/node /usr/bin/node。</p><p>下面是最新的步骤：</p><pre><code class="hljs"># 1 安装wgetyum -y install wget# 2 切换到/usr/local/src目录，选择这个文件夹存放nodejscd /usr/local/src# 3 去nodejs下载官网复制下载链接，我的服务器是centos 8, 64位，所以我选择了https://nodejs.org/dist/v16.15.1/node-v16.15.1-linux-x64.tar.xz# 4 使用 wget 安装方式wget https://nodejs.org/dist/v16.15.1/node-v16.15.1-linux-x64.tar.xz# 这时候这个压缩包就在当前文件夹下，现在需要解压它# 5 解压xz -d node-v16.15.1-linux-x64.tar.xztar -xvf node-v16.15.1-linux-x64.tar# 6 建立软连接ln -s /usr/local/src/node-v16.15.1-linux-x64/bin/node /usr/local/binln -s /usr/local/src/node-v16.15.1-linux-x64/bin/npm /usr/local/bin# 这时候你可以切换到/usr/local/bin目录，看看有没有npm，node文件夹，有的话说明成功了# 7 试试node,npms是否能使用node -vnpm -v# 打印出了版本好就说明没问题</code></pre><h3 id="mongodb安装"><a href="#mongodb安装" class="headerlink" title="mongodb安装"></a><strong>mongodb安装</strong></h3><p>在配置好yum源后，我开始使用<code>yum install -y mongodb-org</code>命令安装mongodb，但是遇到如下报错</p><blockquote><p>Linux：CentOS 8报错(yum源更新报错)：“failovermethod” does not exist 与 Failed to download metadata for repo ‘appstream’解决方法</p></blockquote><p><a href="https://www.cnblogs.com/nhdlb/p/16512888.html">这篇博客</a>写的很好，也给出了对应的解决方案，我在这里也可以记录一下：</p><p><strong>问题一</strong></p><p><code>Configuration: OptionBinding with id “failovermethod” does not exist（配置：ID 为 “failovermethod” 的 OptionBinding 不存在）</code></p><p><strong>解决步骤</strong></p><pre><code class="hljs"># 切换目录cd /etc/yum.repos.d/# 备份源文件信息tar zcf /home/yum.repos.d.tar.gz /etc/yum.repos.d/# 清除无用的源文件信息rm -rf CentOS-*.rpmsave# 修改CentOS-Epel.repo文件,注释CentOS-Epel.repo源文件中的failovermethod=priority这里我直接用xftp软件，可视化修改（可视化对我来说很重要，原谅我是个视觉动物）</code></pre><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19667f0644c64cd5985241b263b6deb4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p><strong>问题2</strong></p><p><code>Error: Failed to download metadata for repo ‘appstream’: Cannot prepare internal mirrorlist: No URLs in mirrorlist</code></p><p><strong>解决步骤</strong></p><pre><code class="hljs"># 进入/etc/yum.repos.d目录cd /etc/yum.repos.d/## 修改所有源的链接地址# 注释掉mirrorlist链接路径sed -i &#39;s/mirrorlist=/#mirrorlist=/g&#39; /etc/yum.repos.d/CentOS-*# 解开并修改baseurl链接路径sed -i &#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#39; /etc/yum.repos.d/CentOS-*# 重建缓冲yum clean all &amp;&amp; yum makecache## 修改源地址为阿里地址# 继续第二步进行修改baseurl链接路径# 修改为阿里源路径sed -i &#39;s|baseurl=http://mirrors.tencentyun.com/epel/$releasever/Everything/$basearch|baseurl=http://mirrors.aliyun.com/epel-archive/8/Everything/$basearch|g&#39; /etc/yum.repos.d/CentOS-Epel.reposed -i &#39;s|baseurl=http://vault.centos.org/$contentdir/$releasever/BaseOS/$basearch/os/|baseurl=http://mirrors.aliyun.com/centos-vault/8.5.2111/BaseOS/$basearch/os/|g&#39; /etc/yum.repos.d/CentOS-Linux-BaseOS.reposed -i &#39;s|baseurl=http://vault.centos.org/$contentdir/$releasever/AppStream/$basearch/os/|baseurl=http://mirrors.aliyun.com/centos-vault/8.5.2111/AppStream/$basearch/os/|g&#39; /etc/yum.repos.d/CentOS-Linux-AppStream.reposed -i &#39;s|baseurl=http://vault.centos.org/$contentdir/$releasever/extras/$basearch/os/|baseurl=http://mirrors.aliyun.com/centos-vault/8.5.2111/extras/$basearch/os/|g&#39; /etc/yum.repos.d/CentOS-Linux-Extras.repo# 重建缓冲yum clean all &amp;&amp; yum makecache</code></pre><p>这个问题到底就解决了！</p><h3 id="mongodb的数据转移"><a href="#mongodb的数据转移" class="headerlink" title="mongodb的数据转移"></a>mongodb的数据转移</h3><p>我需要把mongodb的数据从原来的服务器移到最新的服务器，这里涉及到数据库的拷贝问题。主要用到4个指令：<code>mongodump</code> 数据备份 和 <code>mongorestore</code>数据恢复；<code>mongoexport</code> 集合导出 和<code>mongoimport</code> 集合导入</p><p><code>**mongodump</code> 数据备份 和 <code>mongorestore</code>数据恢复**</p><ol><li><code>mongodump</code> 数据备份</li></ol><p>语法：<code>mongodump -h dbhost -d dbname -o dbdirectory``-h</code>： MongDB所在服务器地址，一般是127.0.0.1:27017，可以通过在xshell输入mongo看到<code>-d</code>： 需要备份的数据库实例，例如：test<code>-o</code>： 备份的数据存放位置，例如：/home/mongodump/，当然该目录需要提前建立，这个目录里面存放该数据库实例的备份数</p><p>对于我而言，我的备份命令如下，🧨🧨🧨<strong>记住这里是在老服务器上操作</strong>🧨🧨🧨</p><pre><code class="hljs">mongodump -h 127.0.0.1:27017 -d schoolstore -o /home/mongodump/</code></pre><p>之后再home/mongodump文件下可以看到schoolstore文件夹，里面是我项目用到的数据库。</p><ol><li>传输文件</li></ol><p>把通过Xftp，把home/mongodump下的schoolstore文件夹传输给本地，在本地传输给新服务器，放到home/mongodump下。</p><p>（xftp我的神）</p><ol><li><code>mongorestore</code> 数据恢复</li></ol><p>语法：<code>mongorestore -h dbhost -d dbname --dir dbdirectory</code> <code>-h</code>： MongoDB所在服务器地址 <code>-d</code>： 需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2 <code>--dir</code>： 备份数据所在位置，例如：/home/mongodump/itcast/</p><p>对于我而言，我的备份命令如下，🧨🧨🧨<strong>记住这里是在新服务器上操作</strong>🧨🧨🧨</p><pre><code class="hljs">mongorestore -h 127.0.0.1:27017 -d schoolstore --dir /home/mongodump/schoolstore</code></pre><ol><li>检验</li></ol><p>利用xshell里连接新服务器，输入<code>mongo</code> 。</p><p>在mongo控制台里输入show dbs，显示所有数据库，可以看到多了schoolstore 数据库。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c3e7f5a1d3f47aaaaf9ca6a75591ba2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p><code>**mongoexport</code> 集合导出 和<code>mongoimport</code> 集合导入**</p><p>转移了数据库，但是这个数据库我在新的服务器里还不能直接使用。因为我的数据库存储了图片的url链接，链接都用了老服务的域名。所以我需要批量更新。</p><p>我的解决办法如下：</p><ol><li><code>**mongoexport</code>** 导出集合</li></ol><p>我的数据集合是schoolstore下的products，我需要把它导出为json文件，然后传输到本地，用vscode搜索老域名，替换成新域名。</p><pre><code class="hljs">mongoexport -h 127.0.0.1:27017 -d schoolstore -c products -o /home/test.json</code></pre><ol><li><code>**mongoimport**</code> 导入在本地替换好新的域名后，再把他传输给服务器，替换老的json文件。现在需要把这个json文件批量导入到schoolstore下的products集合。</li></ol><p>在导入之前先清空一下products的数据。</p><pre><code class="hljs"># 清空集合的数据db.schoolstore.deleteMany(&#123;&#125;)# 导入mongoimport -h 127.0.0.1:27017 -d schoolstore -c products —file /home/test.json</code></pre><h3 id="mongodb常用指令"><a href="#mongodb常用指令" class="headerlink" title="mongodb常用指令"></a>mongodb常用指令</h3><p>下面给一些常用的mongodb指令，其他的用到在积累。</p><pre><code class="hljs">mongo     进入mongodb命令行show dbs    显示数据库列表use dbname    切换/创建dbname数据库，大小写敏感show collections    显示数据库中的集合db.集合名称.find(&#123;&#125;) 查看某一个集合的所有数据</code></pre><h3 id="pm2建立软连接"><a href="#pm2建立软连接" class="headerlink" title="pm2建立软连接"></a>pm2建立软连接</h3><p>安装pm2的时候，需要用到pm2指令，前提需要像Node和npm一样建立软连接，和node一样</p><p><code>ln -s /usr/local/src/node-v16.15.1-linux-x64/bin/pm2 /usr/local/bin</code></p><h3 id="本项目有关地址"><a href="#本项目有关地址" class="headerlink" title="本项目有关地址"></a>本项目有关地址</h3><ol><li><a href="https://juejin.cn/post/7111593698797846565#heading-24">记录第一次vue-nodejs-mongodb项目服务器部署</a></li><li><a href="https://janice143.github.io/myblog.github.io/">我的个人博客地址，里面偶尔会做一些笔记</a></li><li><a href="http://43.143.81.10:8080/home">本项目部署地址</a></li><li>[我的github项目</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>可视化拖拽平台——低代码编辑器（第四届字节青训营项目）</title>
    <link href="/myblog.github.io/2022/09/17/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8B%96%E6%8B%BD%E5%B9%B3%E5%8F%B0%E2%80%94%E2%80%94%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E9%A1%B9%E7%9B%AE%EF%BC%89/"/>
    <url>/myblog.github.io/2022/09/17/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8B%96%E6%8B%BD%E5%B9%B3%E5%8F%B0%E2%80%94%E2%80%94%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E9%A1%B9%E7%9B%AE%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>青训营前端结业项目答辩汇报文档</p><p>一、项目介绍</p><blockquote><p>项目名称：字节青训营Low-Code项目</p><p>团队：six god</p><p>项目服务地址 <a href="http://18.222.123.50:82/">http://18.222.123.50:82</a></p><p>Github 地址: <a href="https://github.com/giraffecat/LowCode">https://github.com/giraffecat/LowCode</a></p></blockquote><h3 id="1-1-项目背景及意义"><a href="#1-1-项目背景及意义" class="headerlink" title="1.1 项目背景及意义"></a>1.1 项目背景及意义</h3><p>在前端开发中，组件化思想是一个非常重要的思想。前端组件化开发可以很大程度地降低系统中各个功能的耦合性，提高代码复用率，例如像Bootstrap、elementUI等这些UI组件库，这些组件库对前端工程化、以及降低代码的维护难度，具有很大的帮助。</p><p>低代码平台解决的最大问题就是复用，除此之外，对于开发人员来说，这个平台能够显著提升开发效率，甚至还能让不具备编码技能的设计人员实现页面的构建和代码的产出。为了满足这些业务的需求，我们团队搭建了一款针对于H5页面开发的Low-Code平台，支持组件拖拽、配置、页面预览等多种功能，可快速实现页面的可视化搭建。</p><h3 id="1-2-低代码平台概要"><a href="#1-2-低代码平台概要" class="headerlink" title="1.2 低代码平台概要"></a>1.2 低代码平台概要</h3><p>低代码平台主要是由「物料组件区」、「画布区」、「属性编辑区」这三个部分组成的。其中物料组件区负责展示可拖拽的组件，画布组件区负责渲染组件，对其进行可视化展示，属性编辑器负责修改选中组件的属性。针对这三者的职责，我们大概设计出了所需要实现的基本功能：</p><p>对于物料组件区，保证其是可拖拽的，并且能与画布区进行交互；对于画布区，可看成这是一个巨大的容器，具有对组件数据的渲染功能；对于属性编辑器，需要获取组件的实时数据，实现与对应组件的联动逻辑。</p><p>为了实现这些功能，本团队基于Vue.js框架以及element ui 组件库，采用JSON schema和vuex的全局数据管理和联动方案，以及vuedraggable插件实现组件的拖拽，为低代码平台提供一种可行的解决思路。</p><p>二、项目分工</p><p>本团队共有5人，大部分是准研三的学生。在队长的合理安排和明确分工下，各个成员各司其职，最终共同完成了本项目的主要功能。</p><p>整体页面展示图：</p><p><img src="https://files.catbox.moe/a5gfh1.png"></p><p>三、项目实现</p><p>项目服务地址 <a href="http://18.222.123.50:82。">http://18.222.123.50:82。</a></p><h3 id="3-1-技术选型"><a href="#3-1-技术选型" class="headerlink" title="3.1 技术选型"></a>3.1 技术选型</h3><p>项目采用 Vue2 + VueRouter + VueX + ElementUI实现，同时采用vuedraggable插件实现组件的拖拽。</p><h3 id="3-2-架构设计"><a href="#3-2-架构设计" class="headerlink" title="3.2 架构设计"></a>3.2 架构设计</h3><p>整个项目架构可以分为四个部分，分别是顶部菜单栏、物料组件区、画布区、属性配置区。</p><ol><li><h4 id="顶部菜单栏"><a href="#顶部菜单栏" class="headerlink" title="顶部菜单栏"></a>顶部菜单栏</h4></li></ol><p>主要实现的是页面管理功能，包括添加、清除、删除操作，以及调整画布大小、渲染、Github第三方登录功能。</p><ol start="2"><li><h4 id="物料组件区"><a href="#物料组件区" class="headerlink" title="物料组件区"></a>物料组件区</h4></li></ol><p>展示了一些基本的常用的可拖拽式的物料组件。其中包括两个容器组件，以及其他组件。</p><ol start="3"><li><h4 id="画布区"><a href="#画布区" class="headerlink" title="画布区"></a>画布区</h4></li></ol><p>渲染拖拽过来的物料组件，通过根据属性编辑区数据来实时更新渲染内容。同时可以实现组件的选中，对选中的组件进行删除和复制操作。</p><ol start="4"><li><h4 id="属性编辑区"><a href="#属性编辑区" class="headerlink" title="属性编辑区"></a>属性编辑区</h4></li></ol><p>可以可视化选中组件的属性，调节属性的参数，更好后的参数可以传给画布进行实时的渲染。</p><h3 id="3-3-项目代码介绍"><a href="#3-3-项目代码介绍" class="headerlink" title="3.3 项目代码介绍"></a>3.3 项目代码介绍</h3><p>主要从要解决的5个核心问题来介绍本项目的代码。</p><ol><li><h4 id="可拖拽组件是如何初始化的？"><a href="#可拖拽组件是如何初始化的？" class="headerlink" title="可拖拽组件是如何初始化的？"></a>可拖拽组件是如何初始化的？</h4></li></ol><p>我们定义一套JSON格式数据规范来描述组件的属性值，主要包括name（名称）, icon（图标）, fields（样式）属性，其中fields属性有包含label（名称）, type（类型）, value（值）属性。</p><p>以button组件为例：</p><p><img src="https://s6.jpg.cm/2022/09/17/PULdlw.png"></p><p>JSON数据在全局自动数据注册函数（registerSchema.js）的作用下，将物料数据全部信息存储在全局变量$initializing、 $fields上。所以左侧的物料组件是通过遍历$initializing数据展示的。</p><p><img src="https://s6.jpg.cm/2022/09/17/PULeE8.png"></p><p><img src="https://s6.jpg.cm/2022/09/17/PULlhi.png"></p><p>$initializing、 $fields在后续的可视化拖拽页面中也扮演着渲染与物料配置之间的纽带。</p><ol start="2"><li><h4 id="画布是如何渲染的？"><a href="#画布是如何渲染的？" class="headerlink" title="画布是如何渲染的？"></a>画布是如何渲染的？</h4></li></ol><p>前提要把物件拖拽到画布中。本项目选择了vuedraggable插件来实现组件的拖拽。</p><p>vuedraggable一款基于Sortable.js实现的vue拖拽插件。支持移动设备。可以在不同组件间拖拽，使用起来也很简单，总之是一款非常优秀的vue拖拽组件。每个组件其实都是一个vuedraagable容器。</p><blockquote><p>Options 表示draggable 列表配置项，group用于分组（相同的组之间可以相互拖拽），sort定义是否可以拖拽(false 不可以拖拽到当前组)，animation定义动画时间</p><p>clone事件，handleClone用来将组件的Json数据深度拷贝到渲染数据中</p></blockquote><p>当从物料区选择组件拖拽到画布上时，首先会将组件的元数据进行深度拷贝，插入到当前的渲染物料数据中。画布组件一直处于watch的监视状态，一旦有组件掉落，就会触发widgets属性（我们用来描述整个画布中组件的所有数据）的更新。有了最新的widgets数据，就可以对其中和UI组件相关的属性进行渲染。</p><pre><code class="hljs">watch: &#123;    widgets: &#123;      handler(val) &#123;        // console.log(&quot;widgets&quot;, val)        this.list = val;      &#125;,      immediate: true,      deep: true,    &#125;,    list: &#123;      handler(val) &#123;        this.$emit(&quot;update:widgets&quot;, val);      &#125;,      immediate: true,      deep: true,    &#125;,  &#125;,</code></pre><p>同时，画布还有选中组件的功能，主要是功能给每个组件设置click事件触发，当被点击时，会加上选中的样式，显示出工具栏。</p><ol start="3"><li><h4 id="属性编辑器是如何实现数据联动的？"><a href="#属性编辑器是如何实现数据联动的？" class="headerlink" title="属性编辑器是如何实现数据联动的？"></a>属性编辑器是如何实现数据联动的？</h4></li></ol><p>为画布上的组件添加点击事件，使其能够在点击时设置右侧属性编辑面板的内容，同时改变属性编辑区的数据，会触发选中组组件的样式更新。所以这里很重要的是属性编辑区和画布区组件的通信。</p><p>层级很复杂，我们使用适用于多层组件通信的方案provide/inject，属性编辑区组件直接传递给选中组件一个this，这样选中组件可以实时获取到属性编辑区组件最新的值，而且属性编辑区组件也能拿到选中组件的数据。</p><p>如下面的代码所示：</p><pre><code class="hljs">// 属性编辑区组件&#123;provide() &#123;    return &#123;      chontrol: this, // inject响应式监听    &#125;;  &#125;,  data() &#123;    return &#123;      widgets: [],      curComponent: undefined,    &#125;;  &#125; &#125;// 在选中组件中，选中物料setcurComponent(cmp) &#123;  this.show = true; // 选中样式可见  this.chontrol.curComponent = cmp; // 设置当前组件的数据curComponent  &#125;</code></pre><p>可以看到我们的属性编辑区的面板，对于同一样类型的属性，我们采用相同的模板来进行可视化操作。这是本项目的一个特色之一，就是我们抽象了出数组、图片上传、对象、跳转等十多个的属性编辑组件，组件的类型记录在物料组件的JSON数据type属性中。这样可以便于更好地规范和管理组件数据，同时提高开发效率，后期新增物料组件时，可以通过拖拽属性编辑组件，直接导出物料组件的JSON数据，避免了繁琐的手动编辑数据工作。</p><p><img src="https://s6.jpg.cm/2022/09/17/PULVnk.png"></p><ol start="4"><li><h4 id="页面管理如何实现？"><a href="#页面管理如何实现？" class="headerlink" title="页面管理如何实现？"></a>页面管理如何实现？</h4></li></ol><p>利用状态管理仓库vuex来管理一些经常用到、且容易变动的数据，比如pages数据, widgets数据。画布中每一次的变动（widgets对象改变），都会触发仓库中widgets数据更新，而pages数据是一个对象数组，记录了每一个页面的widgets， id, name的值。</p><pre><code class="hljs">watch: &#123;    widgets: &#123;      handler(val) &#123;        // 更新此时的widgets        this.$store.commit(&quot;setWidgets&quot;, val);        // 更新pages中的widgets        this.$store.commit(&quot;updateWidgets&quot;, val);      &#125;,      immediate: true,      deep: true,    &#125;,  &#125;,  mounted() &#123;    this.newPage();    eventBus.$on(&#39;updateCurPage&#39;,(cur)=&gt;&#123;      this.curPage = cur    &#125;)  &#125;,</code></pre><p>必要的时候，用全局事件总线辅助。</p><ol start="5"><li><h4 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h4></li></ol><p>基本和画布数据的可视化一样，但是值得注意的是，这里的组件的点击事件不再是选中。</p><p>isPreview判断当前的操作是预览还是编辑状态。</p><p>四、测试结果</p><p>功能测试：</p><ol><li><p>组件拖动、嵌套正常</p></li><li><p>组件基本属性编辑正常</p></li><li><p>当前画布清空、预览正常</p></li><li><p>画布新建、删除、切换正常</p></li><li><p>点击按钮后在自定义页面间跳转正常</p></li><li><p>图片上传正常</p></li></ol><p>五、Demo 演示视频 （必填）</p><p>查看链接</p><p><a href="https://izrq7ytia1.feishu.cn/docx/doxcn1pskXveSpTGds6KwVXWIqc">https://izrq7ytia1.feishu.cn/docx/doxcn1pskXveSpTGds6KwVXWIqc</a></p><p>六、项目总结与反思</p><p>本项目的主要核心特色在于：</p><ol><li><p>采用JSON schema和vuex的全局数据管理和联动方案，其中JSON格式的数据用来将物料组件抽象化，vuex状态管理仓库用来动态管理画布中的组件等数据。使用vuedraggable插件实现组件的拖拽。</p></li><li><p>抽象出数组、图片上传、对象、跳转等11个更高级的属性编辑组件，组件的类型记录在物料组件的JSON数据中，可以便于更好地管理组件数据，同时提高开发效率，后期新增物料组件时，可以通过拖拽属性编辑组件，直接导出物料组件的JSON数据，避免了繁琐的手动编辑数据工作。</p></li><li><p>设置了页面管理功能，配合页面跳转属性编辑组件，使得按钮等物料组件不再是静态的内容，而是具有实际点击事件、可以完成页面跳转的更具有交互性的组件</p></li></ol><p>目前仍存在的问题：发布功能有待实现</p><p>已识别出的优化项</p><ol><li><p>丰富物料库的内容，比如除了基本的组件外，添加常用模板（header, footer等）</p></li><li><p>完善页面管理的功能，比如撤销等</p></li><li><p>完善物料组件的细节功能，比如说文字组件的字体、字号等，让物料库的属性更加精细，灵活性、可调性更高</p></li><li><p>完善后端接口，使得前端构建的页面可以存储在服务器上，不容易丢失</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一次发布npm</title>
    <link href="/myblog.github.io/2022/08/20/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%91%E5%B8%83npm/"/>
    <url>/myblog.github.io/2022/08/20/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%91%E5%B8%83npm/</url>
    
    <content type="html"><![CDATA[<p>本文介绍如何打包发布自己写的组件库到npm上。</p><h2 id="本项目配置"><a href="#本项目配置" class="headerlink" title="本项目配置"></a>本项目配置</h2><p>本项目是使用vue 2.x + vue cli3搭建的UI组件库。目录结构如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">public<br>src<br>    examples <span class="hljs-regexp">//</span> 展示组件库使用示例<br>VUI<br>    packages <span class="hljs-regexp">//</span> 组件的源文件<br>    theme <span class="hljs-regexp">//</span> 组件用到的统一主题样式文件<br>    index.js<br><br><br></code></pre></td></tr></table></figure><p>在本项目中，因为还没有将项目发布npm，所以通过在<code>main.js</code> 文件使用以下指令引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> vui <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../VUI&quot;</span>;<br>Vue.use(vui);<br></code></pre></td></tr></table></figure><h2 id="发布npm"><a href="#发布npm" class="headerlink" title="发布npm"></a>发布npm</h2><ol><li>首先修改<code>package.json</code>文件，增加<code>lib</code>指令。</li></ol><p>在该指令中，</p><ul><li><code>--target</code>: 构建目标，默认为应用模式。这里修改为 <code>lib</code> 启用库模式。</li><li><code>--dest</code> : 输出目录，默认 <code>dist</code>。这里我们改成 <code>lib</code></li><li><code>[entry]</code>: 最后一个参数为入口文件，默认为 <code>src/App.vue</code>。这里我们指定编译 <code>VUI/index.js</code> 组件库目录。</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>   <span class="hljs-string">&quot;lib&quot;</span>: <span class="hljs-string">&quot;vue-cli-service build --target lib --name vui --dest lib VUI/index.js&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改好后，通过<code>npm run lib</code>指令就可以将组件库打包，可以发现新增了一个  <code>lib</code>文件夹。</p><p>这条命令会生成一个 lib 文件夹，将所有的组件打包。然后 <code>npm publish</code> 发布到 <code>npm</code>仓库。</p><ol start="2"><li>配置 <code>package.json</code> 文件中发布到 npm 的字段</li></ol><ul><li><code>name</code>: 包名，该名字是唯一的。可在 npm 官网搜索名字，如果存在则需换个名字。</li><li><code>version</code>: 版本号，每次发布至 npm 需要修改版本号，不能和历史版本号相同。</li><li><code>description</code>: 描述。</li><li><code>main</code>: 入口文件，该字段需指向我们最终编译后的包文件。</li><li><code>keyword</code>：关键字，以空格分离希望用户最终搜索的词。</li><li><code>author</code>：作者</li><li><code>private</code>：是否私有，需要修改为 false 才能发布到 npm</li><li><code>license</code>： 开源协议</li></ul><p>本项目配置如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;view-ui-components&quot;</span>,<br> <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.1.0&quot;</span>,<br> <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;基于 Vue.2x 的UI组件库&quot;</span>,<br> <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;lib/vui.umd.min.js&quot;</span>,<br> <span class="hljs-string">&quot;keyword&quot;</span>: <span class="hljs-string">&quot;vue ui components, custom ui, element&quot;</span>,<br> <span class="hljs-string">&quot;private&quot;</span>: <span class="hljs-literal">false</span>,<br><br></code></pre></td></tr></table></figure><ol start="3"><li>添加 <code>.npmignore</code> 文件，设置忽略发布文件</li></ol><p>我们发布到 npm 中，只有编译后的 <code>lib</code> 目录、package.json、README.md才是需要被发布的。所以我们需要设置忽略目录和文件。和 <code>.gitignore</code> 的语法一样，具体需要提交什么文件，看各自的实际情况。</p><pre><code class="hljs"># 忽略目录examples/packages/public/# 忽略指定文件vue.config.jsbabel.config.js*.map</code></pre><ol start="5"><li>登录npm开始发布</li></ol><p>设置npm的源 </p><p><code>npm config set registry http://registry.npmjs.org</code></p><p>这时候会遇到下列提示：</p><blockquote><p>npm notice Beginning October 4, 2021, all connections to the npm registry - including for package installation - must use TLS 1.2 or higher. You are currently using plaintext http to connect. Please visit the GitHub blog for more information: <a href="https://github.blog/2021-08-23-npm-registry-deprecating-tls-1-0-tls-1-1/">https://github.blog/2021-08-23-npm-registry-deprecating-tls-1-0-tls-1-1/</a></p></blockquote><p>则是因为从2021年10月4日开始，所有与npm网站和npm注册表的连接（包括软件包安装）必须使用TLS 1.2或更高版本。</p><p>使用以前命令安装相关环境</p><blockquote><p>npm install -g <a href="https://tls-test.npmjs.com/tls-test-1.0.0.tgz">https://tls-test.npmjs.com/tls-test-1.0.0.tgz</a></p></blockquote><p>安装成功后会显示如下内容</p><blockquote><p>Hello! The tls-test package was successfully downloaded and installed.<br>Congratulations! Your package manager appears to support TLS 1.2.<br><a href="mailto:&#x74;&#108;&#x73;&#x2d;&#116;&#101;&#x73;&#116;&#x40;&#49;&#46;&#x30;&#x2e;&#48;">&#x74;&#108;&#x73;&#x2d;&#116;&#101;&#x73;&#116;&#x40;&#49;&#46;&#x30;&#x2e;&#48;</a><br>added 1 package from 1 contributor in 3.718s</p></blockquote><p>之后继续执行以下步骤</p><pre><code class="hljs">//注意是httpsnpm config set registry https://registry.npmjs.org npm login</code></pre><p>这是我遇到了<code>npm ERR! code E426</code><br>npm ERR! 426 Upgrade Required - PUT <a href="http://registry.npmjs.org/-/user/org.couchdb.user:iaine">http://registry.npmjs.org/-/user/org.couchdb.user:iaine</a></p><p>需要升级 <code>npm install -g npm@latest</code></p><p>接着继续登录</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">npm config <span class="hljs-keyword">set</span> registry <span class="hljs-comment">http:</span>//<span class="hljs-comment">registry.npmjs.org</span><br>npm <span class="hljs-comment">login</span><br>npm <span class="hljs-comment">publish .</span><br></code></pre></td></tr></table></figure><p>经过这些步骤，过一会会受到邮件，提示你已经成功发布一个npm库了！</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">npm install view-ui-components<br><br><span class="hljs-keyword">import</span> viewUiComponents <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;view-ui-components&#x27;</span> <span class="hljs-comment">//引入库</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;view-ui-components/lib/vui.css&#x27;</span> <span class="hljs-comment">// 引入样式</span><br>Vue.use(viewUiComponents)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一次在vue-cli3 使用 webpack-bundle-analyzer 插件</title>
    <link href="/myblog.github.io/2022/08/19/vue-cli3%E4%BD%BF%E7%94%A8-webpack-bundle-analyzer%E6%8F%92%E4%BB%B6/"/>
    <url>/myblog.github.io/2022/08/19/vue-cli3%E4%BD%BF%E7%94%A8-webpack-bundle-analyzer%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>webpack-bundle-analyzer</code> 作为可视化的 <code>webpack</code> 打包后文件的分析插件，是比较成熟的方案。</p><p><code>webpack-bundle-analyzer作用</code>:</p><ol><li>认识打包后的文件和大小；</li><li>以便优化打包后的文件。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs">npm install webpack-bundle-analyzer -D复制代码</code></pre><h2 id="vue-config-js配置"><a href="#vue-config-js配置" class="headerlink" title="vue.config.js配置"></a>vue.config.js配置</h2><pre><code class="hljs">module.exports = &#123;    chainWebpack: config =&gt; &#123;        config        .plugin(&#39;webpack-bundle-analyzer&#39;)        .use(require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin)    &#125;,&#125;复制代码</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code class="hljs">npm run serve (这时会执行webpack-bundle-analyzer插件功能 完成优化后可自行删掉 配置 )</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>打开网站后，看到如下结<img title="null" src="https://github.com/janice143/myblog.github.io/blob/master/images/webpack_bundle1.png?raw=true" alt="null" data-align="inline"></p><p>可以看到，在这里项目中， chunk-vendors.js 文件很大，大概占74%。这个文件是什么？</p><p>chunk-vendors.js 文件一般是第三方模块或供应商模块。通常，<code>/node_modules</code> 中的第三方包都会打包到 <code>chunk-vendors.js</code> 中，自然会出现文件过大的问题。</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="方式1-Gizp压缩"><a href="#方式1-Gizp压缩" class="headerlink" title="方式1 Gizp压缩"></a>方式1 Gizp压缩</h3><p>使用 compression-webpack-plugin 插件，将文件压缩成gzip文件。（在Vite项目里用vite-plugin-commpression插件）</p><p>安装插件——npm安装。</p><p>了解到还有一种brotli压缩，和gzip算是目前主流的压缩程序，但是前者只适用于https通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save-dev compression-webpack-plugin<br></code></pre></td></tr></table></figure><h3 id="方式2-配置分割"><a href="#方式2-配置分割" class="headerlink" title="方式2 配置分割"></a>方式2 配置分割</h3><p>通过 <code>webpack</code> 前端配置，将第三方包分开打包，这样不会将所有第三方包都打包到 <code>chunk-vendors.js</code> 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">configureWebpack: &#123;<br>    <span class="hljs-comment">// 开启分离 js</span><br>     <span class="hljs-attr">optimization</span>: &#123;<br>      <span class="hljs-attr">splitChunks</span>: &#123;<br>        <span class="hljs-attr">minSize</span>: <span class="hljs-number">10000</span>,<br>        <span class="hljs-attr">maxSize</span>: <span class="hljs-number">250000</span>,<br>      &#125;<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><h3 id="方式3-CND链接"><a href="#方式3-CND链接" class="headerlink" title="方式3 CND链接"></a>方式3 CND链接</h3><p>比如将有些大的 <code>js</code>、<code>css</code> 通过 <code>cdn</code> 的方式链接，可以多种方案配合一起使用的。</p><p>下图是我使用方法2得到的结果，可以看到原来的问价被分割成了很多js文件。</p><img title="null" src="https://github.com/janice143/myblog.github.io/blob/master/images/webpack_bundle2.png?raw=true" alt="null" data-align="inline"><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://juejin.cn/post/7055082226655952903#heading-5">vue3.0 + typescript + webpack-bundle-analyzer实现代码分析和CDN - 掘金</a></p><p><a href="https://stackoverflow.com/questions/51816020/how-to-break-the-js-files-into-chunks-in-vue-cli-3-with-webpack-performance-obje">https://stackoverflow.com/questions/51816020/how-to-break-the-js-files-into-chunks-in-vue-cli-3-with-webpack-performance-obje</a></p><p><a href="https://blog.bitsrc.io/5-methods-to-reduce-javascript-bundle-size-67f2e1220457">https://blog.bitsrc.io/5-methods-to-reduce-javascript-bundle-size-67f2e1220457</a></p><p><a href="https://juejin.cn/post/6999913086165467172#heading-3">Vue 打包 chunk-vendors.js 文件过大导致页面加载缓慢解决方案 - 掘金</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3+vite项目性能优化</title>
    <link href="/myblog.github.io/2022/08/19/vue3-vite%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/myblog.github.io/2022/08/19/vue3-vite%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>经历三次重构</p><h3 id="开启gzip压缩"><a href="#开启gzip压缩" class="headerlink" title="开启gzip压缩"></a>开启gzip压缩</h3><h4 id="什么是gzip"><a href="#什么是gzip" class="headerlink" title="什么是gzip"></a>什么是gzip</h4><p>一种类似winRaR的文件压缩程序。用于在服务器给客户端传送内容的时候，对内容进行压缩（压缩效果很明显），从而可以缩短页面加载时间，提高网站性能。</p><blockquote><p>gzip对纯文本内容可压缩到原大小的40%。但png、gif、jpg、jpeg这类图片文件并不推荐使用gzip压缩（svg是个例外），首先经过压缩后的图片文件gzip能压缩的空间很小。事实上，添加标头，压缩字典，并校验响应体可能会让它更大。</p></blockquote><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p>服务器可以给文件进行gzip压缩，这需要消耗服务器的性能。同时，前端也在打包资源文件时，也可以打包成gzip压缩包，这样可以省去服务器压缩的时间，减少一些服务端的消耗。</p><p>所以现在的一半做法是</p><ol><li>前端使用vite-plugin-compression插件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> viteCompression <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite-plugin-compression&#x27;</span>; <span class="hljs-comment">// 开启gzip压缩</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineConfig(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    viteCompression() <br>  ],<br></code></pre></td></tr></table></figure><ol start="2"><li>服务器配置nginx<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 开启</span><br>gzip on;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 开启gzip静态压缩功能</span><br>gzip_static on; <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> gzip缓存大小</span><br>gzip_buffers 4 16k;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> gzip http版本</span><br>gzip_http_version 1.1;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> gzip 压缩级别 1-10</span> <br>gzip_comp_level 5;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> gzip 压缩类型</span><br>gzip_types text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br>gzip_vary on;<br><br></code></pre></td></tr></table></figure></li></ol><h4 id="效果查看"><a href="#效果查看" class="headerlink" title="效果查看"></a>效果查看</h4><p>在前端使用插件压缩后，利用npm run build进行打包，可以在控制台上看到比较直观的压缩结果</p><p><img src="E:\webbb\iainesBlog\source\images\vue3_1.png"></p><p>750kb的文件压缩了70%。</p><p>同时，将网页部署到服务器上后，打开网页调试，可以看到如下所示的响应头</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f6730c0872d47f4be16fc6d8a93e2fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="request header"></p><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ol><li><a href="https://juejin.cn/post/6844903887871148046#heading-1">前端性能优化gzip初探（补充gzip压缩使用算法brotli压缩的相关介绍) - 掘金</a></li></ol><h3 id="图片CDN"><a href="#图片CDN" class="headerlink" title="图片CDN"></a>图片CDN</h3><p>如果图片不要求高清，可以使用<a href="https://tinypng.com/">tinypng</a>压缩；</p><p>其次，选择图片格式为webp，体积更小；</p><p>使用CDN加载图片，<a href="https://link.juejin.cn/?target=https://www.jsdelivr.com/" title="https://www.jsdelivr.com/">jsdelivr</a> 是一个免费的开源CDN，可以免费加速托管在Github上的图片（但是很不稳定）</p><h4 id="参考博客-1"><a href="#参考博客-1" class="headerlink" title="参考博客"></a>参考博客</h4><p><a href="https://juejin.cn/post/6900907445120401416">使用CDN加载博客图片 - 掘金</a></p><h3 id="首屏渲染时间"><a href="#首屏渲染时间" class="headerlink" title="首屏渲染时间"></a>首屏渲染时间</h3><p>在<code>Lighthouse</code>中我们可以得到 FMP 值，FMP（全称 First Meaningful Paint，翻译为首次有效绘制）表示页面的主要内容开始出现在屏幕上的时间点，它是我们测量用户加载体验的主要指标。我们可以认为<code>FMP</code>的值就是首屏时间，但是浏览器并没有把<code>FMP</code>的数据提供出来。</p><ol><li><p><a href="https://zhuanlan.zhihu.com/p/350657764">统计页面首屏时间，很多人第一步就错了</a></p></li><li><p><a href="https://juejin.cn/post/6962742206692065287#heading-2">如何统计首屏渲染时间 - 掘金</a></p></li></ol><p>lighthouse总结</p><p><a href="https://www.cnblogs.com/sugartang/p/15811844.html">使用Lighthouse更好推动项目性能优化，性能指标详解，优化方法，需要关注指标分析 - 糖~豆豆 - 博客园</a></p><p>性能测量的工具</p><ol><li><p>浏览器</p><p>●Lighthouse(Chrome)</p><p>Network monitor</p><p>Performance monitor</p></li><li><p>第三方</p><p>PageSpeed Insights(Google)<br>·webPage Test<br>GTMetrics (actually Lighthouse)</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git 多人协作流程</title>
    <link href="/myblog.github.io/2022/08/17/git-%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <url>/myblog.github.io/2022/08/17/git-%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone *** # 下载远程仓库的代码<br>git branch develop master    # 从master分支上新建develop分支<br>git checkout develop    # 切换到develop分支<br><span class="hljs-meta">#</span><span class="bash"> 此处可进行功能开发，并add和commit到develop分支</span><br>在多人协作中，可以新建自己的分支，<br>git checkout -b dev1<br><br>在这条分支上开发完后，可以把这条分支合并到develop分支上，<br>git checkout develop // 切换到develop分支<br>git merge dev1 // 合并dev1<br><br>很多时候合并会报错，因为很有可能团队其他人也在develop分支上进行修改了，这时候需要拉取远端的代码，查看更新，解决冲突<br>git pull origin develop    # 更新远端代码，看develop分支是否有更新（无更新）<br><br>检查没问题后，提交到远程仓库<br>git add . <br>git commit -m &quot;message&quot;<br>git push origin develop # 推送develop分支到远端的origin/develop<br><br>一般来讲，在push之前最后pull一下<br><br><br>当你完成一个develop分支的代码更新之后，你再次回到dev1分支，或者新建其他分支，继续完善项目，首先你需要git pull origin develop拉取最新的代码<br><br>如果需要删除分支，<br>git checkout -d dev1<br><br>强制切换分支<br>git checkout develop -f<br><br><br></code></pre></td></tr></table></figure><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ol><li><p><a href="https://zhuanlan.zhihu.com/p/23478654">图文详解如何利用Git+Github进行团队协作开发</a></p></li><li><p><a href="https://juejin.cn/post/6844904168033894414#heading-9">使用Git进行多人协作开发</a></p></li></ol><h2 id="详细步骤版"><a href="#详细步骤版" class="headerlink" title="详细步骤版"></a>详细步骤版</h2><p>1、首先，你需要在远程仓库创建一个新的项目（github、gitee或是你自己的远程服务器），这个新的项目默认会有一个主分支 <strong>master</strong>,现在你需要新建一个 <strong>dev</strong> 分支，这个dev分支就是所谓的主战场，在以后的开发中，就在这个<strong>dev</strong>以及<strong>dev</strong>下的分支进行开发。</p><p>2、然后使用git命令***git clone***到一个空的文件夹</p><p>3、克隆下来的这个项目相当于你在远程创建的那个项目的镜像，所以现在你本地的项目里也有个<strong>dev</strong>分支，当然也有<strong>master</strong>分支，现在切换到dev分支 *<strong>git checkout dev*</strong></p><p>4、现在就可以在这个dev分支上新建自己的分支愉快的开发了，命令 *<strong>git checkout -b dev1*</strong></p><p>5、由于是多人开发，另一个人也可以以同样的方式（经历2、3、4步骤后）新建一个自己的分支<strong>dev2</strong> 命令*<strong>git checkout -b dev2*</strong></p><p>6、在dev1 或 dev2 开发完成后，需要提交到本地仓库，在dev1分支下使用命令 git add . 和 git commit -a -m ‘commit msg’</p><p>7、提交完之后，需要汇总到<strong>dev</strong>分支上，先切回<strong>dev</strong>分支，命令***git checkout dev***，这个时候是没有你在dev1上修改或添加的东西的，需要合并之后才会有；</p><p>8、合并 在<strong>dev</strong>分支下使用命令 *<strong>git merge dev1*</strong></p><p>现在就可以在dev分支下看到你在dev1分支下修改的东西了</p><p>9、提交 合并到dev分支之后就是提交到远程仓库的dev分支，可以先看一下现在都有什么分支，命令 *<strong>git branch -a*</strong></p><p>10、提交到远程dev 命令 *<strong>git push origin dev*</strong></p><p>11、现在远程仓库的dev分支上已经是最新的代码了；最后再把远程的dev分支合并到远程的master主分支上就可以了。一般主分支主要是存放比较稳定版本的版本，dev分支才是最活跃的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记录第一次vue-nodejs-mongodb项目服务器部署</title>
    <link href="/myblog.github.io/2022/06/21/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1vue-nodejs-mongodb%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/myblog.github.io/2022/06/21/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1vue-nodejs-mongodb%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>记录自己第一次部署项目，中间遇到很多errors，但好在花了两天时间成功部署了。先放出部署成功的项目链接</p><p>👉👉👉      <a href="http://101.34.27.188:8080/">师大Buy 校园闲置交易平台</a>     👈👈👈</p><p>（先注册一个账号使用即可体验）</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>本项目包含三个子项目</p><ol><li>前台展示</li><li>后台管理</li><li>后端nodejs服务器+mongodb数据库</li></ol><p>大概流程</p><ul><li><p>开发好前端与后端程序</p></li><li><p>购买服务器（和域名）</p></li><li><p>安全组、开放端口与设置规则</p></li><li><p>xshell操作</p></li><li><p>服务器上安装 和配置node，mongodb 所需环境</p></li><li><p>nginx设置代理</p></li><li><p>上传项目代码到服务器上</p></li><li><p>启动 express 服务器</p></li></ul><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>我的服务器信息：</p><ul><li>腾讯云轻量服务器</li><li>运算组件：2核CPU、2GB内存 (通用型-2核2G-40G-300G)</li><li>系统盘：40GB SSD云硬盘 (通用型-2核2G-40G-300G)</li><li>流量包：300GB/月流量包 (通用型-2核2G-40G-300G)</li><li>地域：上海</li><li>镜像：CentOS 8</li></ul><p>买好服务器后可以进入控制台，对服务器进行操作。可以尝试一下开机关机，之后最重要的是重置密码，这个密码后面通过xshell登录的时候经常用到，所以要记住。</p><h2 id="安全组、开放端口与设置规则"><a href="#安全组、开放端口与设置规则" class="headerlink" title="安全组、开放端口与设置规则"></a>安全组、开放端口与设置规则</h2><p>在腾讯云控制台的搜索框中搜索安全组，打开<code>云服务器 -网络安全-安全组</code>。里面可以设置一些安全组规则，意思就是这里可以打开一些端口，以便项目使用。</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_1.png?raw=true"></p><p>一开始可以新建安全组，使用一些默认的安全组规则。下面这张图展示就是默认的安全组规则，可以看到他已经放通了22,80等端口可以使用。</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_2.png?raw=true"></p><p>本项目中的三个项目分别使用了8080（前台），9528(后台)，3000（后端），27017（数据库）端口，所以要用到这些端口，我们就得自己去开放，因为默认的安全组这些端口是没有开放的。</p><p>开放这些端口的时候，需要在安全组里添加（可以在原来默认的安全组里新添，也可以新建安全组），也需要在服务器的防火墙里添加，只有这两个地方都放通了，端口才能访问。</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_3.png?raw=true"></p><h2 id="登录和操作服务器"><a href="#登录和操作服务器" class="headerlink" title="登录和操作服务器"></a>登录和操作服务器</h2><h3 id="xshell操作"><a href="#xshell操作" class="headerlink" title="xshell操作"></a>xshell操作</h3><p>我电脑是windows系统，所以安装了xshell来登录服务器。如果是 mac系统，好像可以直接在终端，通过<code>ssh root@公网IP</code>命令行连接到服务器。因为我没用过，所以这里只讲xshell如何登录和操纵。</p><p>安装xshell的时候记得顺带安装xftp，可以用来上传文件，不仅如此，我还发现可以用来浏览文件夹，甚至修改编辑文件，很好用！</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_4.png?raw=true"></p><p>打开xshell的时候，会弹出一个会话框，选择新建一个会话，然后命名一下，点击连接，这时候会弹出一个输入密码的对话框，输入一开始你在浏览器上的服务器控制台上重置的密码，就登录了。</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_5.png?raw=true"></p><p><em>centos</em>是基于linux建立的操作系统，所以用的指令和linux一样。而linux指令其实和DOS是一样的，只是命令的表达上可能有点儿不一样，所以遇到这个黑框不要害怕。</p><p>下面说一下xshell里面常用的linux指令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> 进入目录<br><span class="hljs-built_in">ls</span> 查看当前目录下的文件<br>mkdir  创建文件夹<br><span class="hljs-built_in">mv</span> 移动或重命名<br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span>  删除整个文件夹<br></code></pre></td></tr></table></figure><p>大概知道这些你就有了部署项目的基础了，中途如果遇到其他的需要，可以上网查看。</p><p>你可以先试试<code>ls</code>，看看当前文件夹里有什么文件，这感觉就好像是在windows系统上浏览文件夹，只不过在windows上是可视化的操作界面。</p><h3 id="xftp使用"><a href="#xftp使用" class="headerlink" title="xftp使用"></a>xftp使用</h3><p>xftp是个很好用的可视化界面，一开始我是看别人说用来上传文件的，但是后来我用的时候，我发现它很好用来浏览文件，找回了使用windows一样的感觉。</p><p>当你进入xftp软件的时候，首先也会弹出一个会话框，新建会话，重命名，然后连接，输入密码。和使用xshell一样。</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_6.png?raw=true"></p><p>要传什么文件给服务器，先在右框中选择文件夹（新建文件夹），找好存放的位置后，在左框中浏览你电脑的文件，找到对应的文件后右键 传输。</p><p>值得注意的是，在连接服务器后，初始文件夹的位置是/root，你可以从xftp软件的右框中看到，也可以在xshell里面<code>ls</code>看到。</p><p>在xftp软件上右框的文件夹中有 … (三个点)，点击一下，可以返回上一级，你会发现，这里有很多初始文件夹。知道这些文件夹的存在，对于我们下一步的操作很重要，这里暂时放开，我们继续后面。</p><h2 id="服务器上安装node，mongodb"><a href="#服务器上安装node，mongodb" class="headerlink" title="服务器上安装node，mongodb"></a>服务器上安装node，mongodb</h2><p>浏览到这里，我们已经知道一些基本的xshell指令，知道如何通过xshell登录服务器，通过xftp上传文件。下面我们开始在服务器上安装项目所需环境。</p><p>一般在新服务器创建后，建议先升级一下 CentOS：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y update<br></code></pre></td></tr></table></figure><p>在升级之后，我的yum指令就下载不了东西了，报错<code>Fix Failed to download metadata for repo</code>，<a href="https://techglimpse.com/failed-metadata-repo-appstream-centos-8/">解决办法</a>是</p><p><strong>Step 1:</strong> Go to the <code>/etc/yum.repos.d/</code> directory.</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@autocontroller</span> ~]<span class="hljs-meta"># cd /etc/yum.repos.d/</span><br></code></pre></td></tr></table></figure><p><strong>Step 2:</strong> Run the below commands</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@autocontroller</span> ~]<span class="hljs-meta"># sed -i <span class="hljs-string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br>[root<span class="hljs-symbol">@autocontroller</span> ~]<span class="hljs-meta"># sed -i <span class="hljs-string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br></code></pre></td></tr></table></figure><p>**Step 3:**现在yum就可以使用了</p><h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><p>网上的博客描写安装Nodejs很多，甚至还不一样，很容易踩坑，但是我推荐看<a href="https://juejin.cn/post/6844903605040857095">这篇博客</a>，另外我也在这讲一下步骤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1 安装wget</span><br>yum -y install wget<br><br><span class="hljs-comment"># 2 切换到/usr/local/src目录，选择这个文件夹存放nodejs</span><br><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/src<br><br><span class="hljs-comment"># 3 去nodejs下载官网复制下载链接，我的服务器是centos 8, 64位，所以我选择了</span><br>https://nodejs.org/dist/v16.15.1/node-v16.15.1-linux-x64.tar.xz<br><br><span class="hljs-comment"># 4 使用 wget 安装方式</span><br>wget https://nodejs.org/dist/v16.15.1/node-v16.15.1-linux-x64.tar.xz<br><br><span class="hljs-comment"># 这时候这个压缩包就在当前文件夹下，现在需要解压它</span><br><span class="hljs-comment"># 5 解压</span><br>xz -d node-v16.15.1-linux-x64.tar.xz<br>tar -xvf node-v16.15.1-linux-x64.tar<br><br><span class="hljs-comment"># 6 建立软连接</span><br>ln -s /node-v16.15.1-linux-x64/bin/node /usr/<span class="hljs-built_in">local</span>/bin<br>ln -s /node-v16.15.1-linux-x64/bin/npm /usr/<span class="hljs-built_in">local</span>/bin<br><br><span class="hljs-comment"># 这时候你可以切换到/usr/local/bin目录，看看有没有npm，node文件夹，有的话说明成功了</span><br><span class="hljs-comment"># 7 试试node,npms是否能使用</span><br>node -v<br>npm -v<br><br><span class="hljs-comment"># 打印出了版本好就说明没问题</span><br></code></pre></td></tr></table></figure><h3 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h3><p>推荐看<a href="https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-red-hat/#verify-that-mongodb-has-started-successfully">官网的步骤</a>  （有官方看官方，否则看别人的博客很容易踩坑）</p><p>官网给出了如何在centos上下载mongodb 5，我也在这里写出步骤</p><h4 id="1-配置yum"><a href="#1-配置yum" class="headerlink" title="1 配置yum"></a>1 配置yum</h4><p>xftp的作用来了，打开该软件，在<code>/etc/yum.repos.d</code>文件夹下创建<code>mongodb-org-5.0.repo</code>文件，选择记事本打开，粘贴下面代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[mongodb-org-5.0]<br>name=MongoDB Repository<br>baseurl=https://repo.mongodb.org/yum/redhat/<span class="hljs-variable">$releasever</span>/mongodb-org/5.0/x86_64/<br>gpgcheck=1<br>enabled=1<br>gpgkey=https://www.mongodb.org/static/pgp/server-5.0.asc<br></code></pre></td></tr></table></figure><p>这个操作就好像告诉yum去指定的baseurl去下载资源，不配置的话yum不指导哪里找资源下载。</p><h4 id="2-安装mongodb安装包"><a href="#2-安装mongodb安装包" class="headerlink" title="2 安装mongodb安装包"></a>2 安装mongodb安装包</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y mongodb-org<br></code></pre></td></tr></table></figure><h4 id="3-验证安装结果"><a href="#3-验证安装结果" class="headerlink" title="3 验证安装结果"></a>3 验证安装结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -qa |grep mongodb<br></code></pre></td></tr></table></figure><p>如果输出很多Mongodb相关的包时，说明你的服务器已经有这些包了</p><h4 id="4-data目录和log目录"><a href="#4-data目录和log目录" class="headerlink" title="4 data目录和log目录"></a>4 data目录和log目录</h4><p>默认情况下，MongoDB 会创建一下<code>mongod</code>用户，该用户会使用data和log目录</p><ul><li><code>/var/lib/mongo</code> (the data directory)</li><li><code>/var/log/mongodb</code> (the log directory)</li></ul><p>我们这里就使用它默认的一个位置来存放mongodb的data和log。</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_7.png?raw=true"></p><h4 id="5-启动MongoDB服务"><a href="#5-启动MongoDB服务" class="headerlink" title="5 启动MongoDB服务"></a>5 启动MongoDB服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mongod.service<br></code></pre></td></tr></table></figure><p>我这里启动报错，后来我看到了<a href="https://askubuntu.com/questions/823288/mongodb-loads-but-breaks-returning-status-14#comment1255871_823288">这篇文章</a>，（看高赞回答），我发现权限错误，我的<code>/tmp/mongodb-27017.lock</code>所有者是root，需要改为mongod。</p><blockquote><p>permission settings on <code>/var/lib/mongodb</code> and <code>/tmp/mongodb-27017.lock</code> are wrong. You will have to change the owner to monogdb user</p></blockquote><p>在xshell输入一下指令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">chown -R mongod:mongod /var/lib/mongodb<br>chown mongod:mongod /tmp/mongodb-27017.sock<br></code></pre></td></tr></table></figure><h4 id="6-验证服务开启"><a href="#6-验证服务开启" class="headerlink" title="6 验证服务开启"></a>6 验证服务开启</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">执行: mongo<br>输出： MongoDB <span class="hljs-keyword">shell</span> <span class="hljs-keyword">version</span> v5.<span class="hljs-number">0.9</span><br>connecting <span class="hljs-keyword">to</span>: mongod<span class="hljs-variable">b:</span>//<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">27017</span>/?compressors=disabled&amp;gssapiServiceName=mongodb<br><br></code></pre></td></tr></table></figure><p>到现在我们已经完成了部署难点的很大一部分。下面我们看看怎么在服务器运行我们三个项目</p><h2 id="nginx设置代理"><a href="#nginx设置代理" class="headerlink" title="nginx设置代理"></a>nginx设置代理</h2><p>不需要懂nginx原理，我们可以先使用它看看。</p><p>参考<a href="https://zhuanlan.zhihu.com/p/431796992">这篇文章</a>，我这里也引用一下</p><h3 id="先查看服务器是否有nginx"><a href="#先查看服务器是否有nginx" class="headerlink" title="先查看服务器是否有nginx"></a>先查看服务器是否有nginx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">whereis nginx<br></code></pre></td></tr></table></figure><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yum install -y nginx<br></code></pre></td></tr></table></figure><h3 id="查看nginx安装目录"><a href="#查看nginx安装目录" class="headerlink" title="查看nginx安装目录"></a>查看nginx安装目录</h3><p>命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">whereis nginx<br></code></pre></td></tr></table></figure><h3 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h3><p><strong>启动</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">nginx<br></code></pre></td></tr></table></figure><p>直接输入nginx即可启动服务，打开浏览器，访问服务器公网地址，出现如下界面则代表启动成功。</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_8.png?raw=true"></p><p>这里访问默认的是80端口，因为nginx服务就是默认的80端口，如果不能访问，大致有几种原因：</p><ul><li>nginx未启动</li><li>服务器安全组未加入80端口</li><li>nginx配置错误</li></ul><p><strong>停止</strong></p><p>停止nginx服务，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">nginx -s stop<br></code></pre></td></tr></table></figure><p>此时访问浏览器则无法访问。</p><p><strong>重启</strong></p><p>重启nginx服务，一般用于修改配置文件之后，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">nginx -s reload<br></code></pre></td></tr></table></figure><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><p>nginx启动后，在浏览器上输入公网地址，就可以打开默认的一个html页面。</p><p>但是这个页面和端口都是默认的，如果需要显示我们自己的页面，就需要配置nginx，配置文件为<code>/etc/nginx/nginx.conf</code>，使用xftp找到该文件夹，并打开编辑。</p><p>也可以在xshell上cd找到并vim打开，但是这个很不方便，不能快速复制粘贴和定位。所以推荐使用我用xftp发现的隐藏功能。</p><p>在配置文件中，重点看server 对象，要改的也是这个对象，我的配置如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs bash">  <br><span class="hljs-comment"># 默认端口</span><br>   server &#123;<br>       listen       80 default_server;<br>       listen       [::]:80 default_server;<br>       server_name  _;<br>       root         /usr/share/nginx/html;<br><br>       <span class="hljs-comment"># Load configuration files for the default server block.</span><br>       include /etc/nginx/default.d/*.conf;<br>       location / &#123;<br>       &#125;<br>       error_page 404 /404.html;<br>           location = /40x.html &#123;<br>       &#125;<br>       error_page 500 502 503 504 /50x.html;<br>           location = /50x.html &#123;<br>       &#125;<br>   &#125;<br><br><span class="hljs-comment"># 前台展示的打开的服务代理</span><br>server &#123;<br>       listen       8080;<br>       server_name  localhost;<br>root         /root/lan/schoolstore/frontshop/dist;<br><br>       <span class="hljs-comment"># Load configuration files for the default server block.</span><br>       <span class="hljs-comment"># include /etc/nginx/default.d/*.conf;</span><br><br>       location / &#123;<br>root   /root/lan/schoolstore/frontshop/dist;<br>           index  index.html;<br>           try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ @router;<br>           autoindex on;<br>      &#125;<br>   <br>    location @router&#123;<br>           rewrite ^.*$ /index.html last;<br>       &#125;<br><br>       location /api/ &#123;<br>           proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>           proxy_pass http://0.0.0.0:3000;<br>       &#125;<br><br>       gzip on;<br><br>       gzip_buffers 32 4k;<br><br>       gzip_comp_level 6;<br><br>       gzip_min_length 200;<br><br>       gzip_types text/css text/xml application/javascript;<br><br>       gzip_vary on;<br><br>       <span class="hljs-comment">#error_page  404              /404.html;</span><br>       <span class="hljs-comment"># redirect server error pages to the static page /50x.html</span><br>       <span class="hljs-comment">#</span><br>       error_page   500 502 503 504  /50x.html;<br>       location = /50x.html &#123;<br>           root   html;<br>       &#125;<br>   &#125;<br><br><span class="hljs-comment"># 后台管理的服务代理</span><br>server &#123;<br>       listen       9528;<br>       server_name  localhost;<br>root         /root/lan/schoolstore/cms/dist;<br><br>       <span class="hljs-comment"># Load configuration files for the default server block.</span><br>       <span class="hljs-comment"># include /etc/nginx/default.d/*.conf;</span><br><br><span class="hljs-comment"># 找到要渲染的页面</span><br>       location / &#123;<br>           <span class="hljs-comment"># try_files $uri $uri/ /index.html;</span><br>root   /root/lan/schoolstore/cms/dist;<br>           index  index.html;<br>           try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ @router;<br>           autoindex on;<br>      &#125;<br>   <span class="hljs-comment"># 找到路由</span><br>    location @router&#123;<br>           rewrite ^.*$ /index.html last;<br>       &#125;<br>      <span class="hljs-comment"># 后端数据</span><br>       location /api/ &#123;<br>           proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>           proxy_pass http://0.0.0.0:3000;<br>       &#125;<br><br>       gzip on;<br><br>       gzip_buffers 32 4k;<br><br>       gzip_comp_level 6;<br><br>       gzip_min_length 200;<br><br>       gzip_types text/css text/xml application/javascript;<br><br>       gzip_vary on;<br><br>       <span class="hljs-comment">#error_page  404              /404.html;</span><br>       <span class="hljs-comment"># redirect server error pages to the static page /50x.html</span><br>       <span class="hljs-comment">#</span><br>       error_page   500 502 503 504  /50x.html;<br>       location = /50x.html &#123;<br>           root   html;<br>       &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>主要就是修改root 和 location。</p><p>我开了两个代理的：前台展示打开的服务代理8080，和管理后台打开的服务代9528，这个项目是分开端口访问的。<br>修改配置文件后 执行<code> nginx -s reload</code>，如果项目已经上传，理论上访问ip:8080可以打开前台展示项目，访问ip:9528，可以打开后台展示项目。但是我们现在没讲到上传文件。所以会访问不成功，而80端口我还保留了默认的页面，还是可以访问到的，不妨试一试。</p><h2 id="上传项目代码到服务器"><a href="#上传项目代码到服务器" class="headerlink" title="上传项目代码到服务器"></a>上传项目代码到服务器</h2><p>主要有三个项目的文件需要上传：前台，后台，后端</p><p>我们先把后端部署好，前台上传比较容易，并且后端部署好后，前台部署可以拿到数据。</p><h3 id="在服务器上使用nodejs"><a href="#在服务器上使用nodejs" class="headerlink" title="在服务器上使用nodejs"></a>在服务器上使用nodejs</h3><p>不着急直接上传nodejs文件，我们先看看服务器上nodejs怎么使用，因为一开始对于一个服务器小白来说，我们要上传什么东西都不知道，要不要打包也不知道，上传后端和前台一样也不知道。所以带着这些疑问，我们先上网搜搜，怎么在服务器上使用nodejs。</p><p>参考<a href="https://help.aliyun.com/document_detail/50775.html">文章</a> ，主要看【步骤二：部署测试项目】，本文这里也给出步骤，主要是参考了这篇文章。</p><p>1 打开vscode，在自己电脑里新建一个example.js文件，复制一下代码，然后node example.js就可以在<a href="http://localhost:3000/%E7%9C%8B%E5%88%B0%C2%B7%60hello">http://localhost:3000/看到·`hello</a> word`</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> hostname = <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>;<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123; <br>    res.statusCode = <span class="hljs-number">200</span>;<br>    res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/plain&#x27;</span>);<br>    res.end(<span class="hljs-string">&#x27;Hello World\n&#x27;</span>);<br>&#125;); <br><br>server.listen(port, hostname, <span class="hljs-function">() =&gt;</span> &#123; <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Server running at http://<span class="hljs-subst">$&#123;hostname&#125;</span>:<span class="hljs-subst">$&#123;port&#125;</span>/`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这是在自己电脑运行的效果，现在我们要想这个example.js文件放到服务器上，然后再服务器上运行，最后在自己电脑的浏览器上输入对应网址，可以看到同样的<code>hello world</code>。</p><p>2 把example.js文件通过xftp上传到服务器上的/root文件夹下。然后再xshell中切换到该文件夹。通过<code>ls</code>指令可以看到该js文件，输入一以下指令运行该js文件。（和在自己电脑的控制台上一样）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node example.js<br></code></pre></td></tr></table></figure><p>打开浏览器并访问<code>http://&lt;ECS实例公网IP地址&gt;:&lt;项目端口号&gt;</code>。本示例中，&lt;项目端口号&gt;为3000。你会发现该文件运行了同样效果。</p><p><strong>这就是node在服务器上的使用，总的来说，其实和在自己电脑运行一样，也就是说我们要把js文件上传到服务器，如果项目大的话，会有很多文件夹，还会有node modules，所以这些也要上传。这些文件都有，node js文件就可以运行了！</strong></p><h3 id="在服务器上部署Node-js-MongoDB-项目"><a href="#在服务器上部署Node-js-MongoDB-项目" class="headerlink" title="在服务器上部署Node.js + MongoDB 项目"></a>在服务器上部署Node.js + MongoDB 项目</h3><p>我的后端项目还用到了数据库，刚才我们只学到node项目怎么部署，但是node+mongodb呢？现在我们来看看</p><p>参考<a href="https://www.youtube.com/watch?v=-oTdaFDvLo4">教学视频</a></p><p>下面的讲解是假设你已经知道了怎么在自己电脑上开发node+mongodb项目，如果不知道建议先掌握这部分知识，再来看服务器上的部署。</p><p>重点是在node 项目文件里设置Mongodb数据库连接，这个链接怎么看呢？在xshell里输入mongo就可以看到，</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_9.png?raw=true"></p><p>图中红色框就是你的数据库的连接地址。但是在node项目里，？后面的字符串不需要写进入，同时还要也一个明确的数据库名称，我的数据库连接如下图所示。</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_10.png?raw=true"></p><p>处理好mongodb的连接地址，下面的步骤其实和Node项目一样，接下来我们真正开始讲解本项目的部署。</p><h3 id="上传本项目后端代码"><a href="#上传本项目后端代码" class="headerlink" title="上传本项目后端代码"></a>上传本项目后端代码</h3><p>有的博客说可以用git上传，大概的意思就是服务器其实也是一台电脑，在这台里面通过git拉取项目，前提是你已经在自己的电脑里把项目文件git到了github上。但是这样很复杂，服务器这台电脑还需要配置git使用，不然就会没有权限，拉取不到项目文件。我弄了一会没弄出来我就另辟蹊径了。</p><p>我的方式：</p><p>1 在自己电脑里把项目上传到github上，忽略node modules等开发文件，(我的电脑使用git很久了，已经配置好了，如果第一次使用，也是要配置的，但是在可视化的windows上配置应该比centos上配置容易点)。</p><p>2 上传之后在git clone拉取下来</p><p>3 把新文件同xftp上传到服务器上</p><p>4 xshell切换到项目文件下，输入<code>node install</code>下载项目所需包</p><p>5 node server.js文件运行即可</p><h4 id="pm2使用"><a href="#pm2使用" class="headerlink" title="pm2使用"></a>pm2使用</h4><blockquote><p> PM2 是一个守护进程管理器，它将帮助您管理和保持您的应用程序在线</p></blockquote><p>其实说到这里后端项目就已经部署好了，但是很多博客都介绍了pm2这个工具，这个工具可以替代node server.js，同样让后端启动，但是不同的是，pm2的使用可以保证项目永久运行在服务器上，且不会一报错后端服务器就挂了，而且运行中还可以进行其他操作。</p><p>1 安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g pm2<br></code></pre></td></tr></table></figure><p>2 切换当前工作目录到项目server.js文件夹中，执行指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 start server.js<br></code></pre></td></tr></table></figure><p>pm2的其他操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">pm2 stop server.js <span class="hljs-regexp">//</span> 关闭<br>pm2 list <span class="hljs-regexp">//</span>查看所用已启动项目<br></code></pre></td></tr></table></figure><p>到现在为止后端已经部署完毕了</p><h3 id="上传本项目前端代码"><a href="#上传本项目前端代码" class="headerlink" title="上传本项目前端代码"></a>上传本项目前端代码</h3><p>前端代码上传比较容易，参考<a href="https://zhuanlan.zhihu.com/p/431796992">文章</a></p><p>我的项目是vue项目，所以npm run build打包出一个dist文件夹即可。然后把这个文件夹上传到服务器。此时无需重启nginx，刷新浏览器，可以看到我们的网站已经部署成功了</p><p><strong>前台</strong></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_11.png?raw=true"></p><p><strong>后台</strong></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/server_12.png?raw=true"></p><h2 id="本项目有关地址"><a href="#本项目有关地址" class="headerlink" title="本项目有关地址"></a>本项目有关地址</h2><p>部署项目重点参考了三篇文章</p><p>1 <a href="https://segmentfault.com/a/1190000017143278">服务器小白的我,是如何成功将 node+mongodb 项目部署在服务器上并进行性能优化的</a></p><p>2 <a href="https://juejin.cn/post/7004678485788590111#heading-14">记录react+node+mongodb项目部署到服务器的过程</a></p><p>3 <a href="https://zhuanlan.zhihu.com/p/431796992">前端Vue项目打包部署实战教程</a></p><p>非常推荐看这三篇，少走很多弯路。</p><p>我的个人博客地址，里面偶尔会做一些笔记</p><p><a href="https://janice143.github.io/myblog.github.io/">https://janice143.github.io/myblog.github.io/</a></p><p>本项目部署地址</p><p><a href="http://101.34.27.188:8080/#/home">http://101.34.27.188:8080/#/home</a></p><p>我的github项目</p><p><a href="https://github.com/janice143?tab=repositories">https://github.com/janice143?tab=repositories</a></p><p>一些bug清单，附带解决问题的网站</p><p>1 <a href="https://qdmana.com/2022/03/202203131953219539.html">nginx配置500内部错误</a></p><p>2 <a href="https://developer.aliyun.com/article/92134">ECS服务器部署Nodejs出现错误Error: Listen EADDRNOTAVAIL</a></p><p>3 mongodb的导入json文件</p><p><code>mongoimport --jsonArray --db schoolstore --collection categories --file cat.json</code></p><p>4 <a href="https://techglimpse.com/failed-metadata-repo-appstream-centos-8/">linux服务器升级后，yum安装出错</a></p><hr><p>前端小菜鸟，研二在校生（马上要研三了），非科班，物电学院，专业你猜</p><p>大二接触前端，但是有了专业课老师上课要抽同学讲课，然后我就学了一下简单的三件套，做了个转盘抽签网页，没做出来，但是我再网上找了代码改了改弄出来了。这是我第一次的前端开发 😁😁😁</p><p>大二大三是人生巅峰，拿国奖，发SCI了，觉得自己有搞研究的天分，准备本专业考研了。</p><p>到了研究生发现自己不适合读博，想找工作，不想当物理老师，不想从事本专业，然后又开始拿起前端三件套，进阶前端之路了。I have no idea what I’m doing…</p><p>最近提前批、秋招要来了，好紧张，我要冲去找工作了！</p><p>祝我好运！</p><p>have fun here!</p><p>对了，后面还有很多文章想写的，等我有时间都会给它写了！</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【前端面试-JS】基础面试题</title>
    <link href="/myblog.github.io/2022/05/26/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-JS%E3%80%91%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/myblog.github.io/2022/05/26/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-JS%E3%80%91%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="JS-基础面试"><a href="#JS-基础面试" class="headerlink" title="JS 基础面试"></a>JS 基础面试</h1><h2 id="延迟加载js方式"><a href="#延迟加载js方式" class="headerlink" title="延迟加载js方式"></a>延迟加载js方式</h2><ul><li><p>async</p><ul><li><p> 后台下载</p></li><li><p> 执行会中断页面渲染</p></li><li><p> 下载好后立刻执行，没有顺序（谁先下载完谁先执行）</p></li></ul></li><li><p>defer </p><ul><li>后台下载</li><li>不会中断页面渲染（等页面渲染完后执行）</li><li>顺次执行（多个js文件会按先后顺序执行）</li></ul></li></ul><p><img src="http://www.growingwiththeweb.com/images/2014/02/26/async-vs-defer-twitter.png" alt="async vs defer attributes - Growing with the Web"></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>string, number, boolean, undefined, null, symbol（, bigint)</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>object(包括数组等)</p><h3 id="数据类型的隐式转换"><a href="#数据类型的隐式转换" class="headerlink" title="数据类型的隐式转换"></a>数据类型的隐式转换</h3><blockquote><p>true+1 // 2</p><p>‘name’ + true // ‘nametrue’ （字符串和其他类型相加，都是转化成字符串）</p><p>undefined + 1 // NaN（是一个number)</p><p>typeof null // object</p></blockquote><h2 id="null-和undefined-区别"><a href="#null-和undefined-区别" class="headerlink" title="null 和undefined 区别"></a>null 和undefined 区别</h2><p><code>undefined</code></p><p>一个变量最原始的状态；此处应该有一个值，但是还没有定义；转为数值时为NaN</p><ul><li>变量被声明了，但没有赋值</li><li>调用函数时，但没有传递实参</li><li>访问对象上不存在的属性或者未定义的变量</li><li>函数没有返回值时，默认返回undefined</li></ul><p><code>null</code></p><p> 表示一个被人为的重置为空对象；该处的值为空；转为数值时为0</p><p>典型用法：</p><ul><li><p>作为函数的参数，表示该函数的参数不是对象。</p></li><li><p>作为对象原型链的终点。</p></li></ul><p>在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。</p><h2 id="和-区别"><a href="#和-区别" class="headerlink" title="== 和 === 区别"></a>== 和 === 区别</h2><p>== </p><p>比较的是值</p><p>===</p><p>不仅比较值，还比较类型</p><h2 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>js是单线程，但是有异步处理。js是同步任务执行完毕后再去执行异步任务。</p><h3 id="什么是宏任务和微任务"><a href="#什么是宏任务和微任务" class="headerlink" title="什么是宏任务和微任务"></a>什么是宏任务和微任务</h3><p>微任务： <code>promise.then</code></p><p>宏任务：定时器，用户交互事件，ajax，读取文件</p><h3 id="js异步执行原则"><a href="#js异步执行原则" class="headerlink" title="js异步执行原则"></a>js异步执行原则</h3><p>1 同步</p><p>2 <code>process.nextTick</code></p><p>3 异步</p><p>3.1 微任务： <code>promise.then</code></p><p>3.2 宏任务：定时器，用户交互事件，ajax，读取文件</p><p>4 <code>setImmediate</code>方法</p><blockquote><p>注意：</p><p>同步的任务都执行完后，才会执行事件循环的内容。</p><p>要执行宏任务，前提是清空所有微任务。</p></blockquote><p>js代码执行流程： 同步执行完后 =&gt; 事件循环（宏任务和微任务） =&gt; 微任务 =&gt; 宏任务 =&gt; 微任务 … </p><img src="/myblog.github.io/images/js_question_eventloop.png" alt="在这里插入图片描述" style="zoom: 80%;" /><p>进入事件循环：请求，定时器，事件…</p><h2 id="JS作用域"><a href="#JS作用域" class="headerlink" title="JS作用域"></a>JS作用域</h2><p>1 除函数外，js没有块级作用域</p><p>2 作用域链：内部可以访问到外部的变量，但是外部不能访问内部的变量。</p><p>注意：如果有内部，优先查找内部，如果没有，就查找外部</p><p>3 声明变量没有用var let const，那这个变量就是全局的(window的)</p><p>4 js变量提升机制</p><p>5 优先级： 声明变量 &gt; 声明普通函数 &gt; 参数 &gt; 变量提升</p><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li>变量提升</li><li>变量覆盖</li><li>没有块级作用域</li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li>声明之后必须赋值</li><li>定义的值不可修改</li><li>其他和let一样</li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>没有变量提升</li><li>不允许重复声明</li><li>所声明的变量，只在let命令所在的代码块内有效</li></ul><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>使用 <code>let</code> 或 <code>const</code> 声明的变量，在声明赋值没有到达之前，访问该变量都会导致报错，就连一直以为安全的 <code>typeof</code> 也不再安全</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;  <span class="hljs-comment">//函数作用域开始，TDZ开始</span><br>    <span class="hljs-built_in">console</span>.log(temp)  <span class="hljs-comment">//ReferenceError: temp is not defined</span><br>    <span class="hljs-comment">//声明</span><br>    <span class="hljs-keyword">let</span> temp  <br>    <span class="hljs-built_in">console</span>.log(temp)  <span class="hljs-comment">//ReferenceError: Cannot access &#x27;temp&#x27; before initialization</span><br>    <span class="hljs-comment">//赋值</span><br>    temp = <span class="hljs-number">345</span>  <span class="hljs-comment">//TDZ结束</span><br>    <span class="hljs-built_in">console</span>.log(temp)  <span class="hljs-comment">//345</span><br>    <span class="hljs-comment">//块级作用域结束</span><br>&#125;<br><span class="hljs-comment">//在块级作用域外访问</span><br><span class="hljs-built_in">console</span>.log(temp)  <span class="hljs-comment">//ReferenceError: temp is not defined</span><br><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：任何在暂时性死区内访问变量的企图都会导致 <strong>运行时错误</strong>（Runtime Error）。只有执行到变量的声明语句时，该变量才会从暂时性死区内被移除并可以安全使用。</p><h2 id="JS对象"><a href="#JS对象" class="headerlink" title="JS对象"></a>JS对象</h2><p>1 对象通过new操作符构建的，所以对象不相等(=== 是false)</p><p>2 对象是引用类型（地址）</p><p>3 对象的key是字符串类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">a = &#123; <span class="hljs-attr">aa</span>: <span class="hljs-number">1</span> &#125;<br>b = &#123; <span class="hljs-attr">bb</span>: <span class="hljs-number">2</span> &#125;<br>c = &#123; <span class="hljs-attr">cc</span>: <span class="hljs-number">3</span> &#125;<br>a[b] = <span class="hljs-string">&#x27;123&#x27;</span><br>a[c] = <span class="hljs-string">&#x27;456&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(a[b]) <span class="hljs-comment">// 456</span><br><br>b和c是对象，当成为a的属性的时候，会变成字符串，值是[object object]。c会覆盖b的值。<br>相当于a = &#123;<br><span class="hljs-string">&#x27;[object object]&#x27;</span>:<span class="hljs-number">456</span>,<br><span class="hljs-attr">aa</span>:<span class="hljs-number">1</span><br>&#125; <br></code></pre></td></tr></table></figure><p>4 对象如何找属性或者方法（原型链）</p><p>对象本身找 =&gt; 构造函数找 =&gt; 对象原型找 <code>__proto__</code>=&gt; 构造函数原型找  prototype =&gt; 对象上一层原型查找 </p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>判断对象的类型，原理是通过判断对象的原型链中是不是能找到构造函数的 <code>prototype</code>。</p><blockquote><p>语法 <code>object instanceof constructor</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params">make, model, year</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.make = make;<br>  <span class="hljs-built_in">this</span>.model = model;<br>  <span class="hljs-built_in">this</span>.year = year;<br>&#125;<br><span class="hljs-keyword">const</span> auto = <span class="hljs-keyword">new</span> Car(<span class="hljs-string">&#x27;Honda&#x27;</span>, <span class="hljs-string">&#x27;Accord&#x27;</span>, <span class="hljs-number">1998</span>);<br><br><span class="hljs-built_in">console</span>.log(auto <span class="hljs-keyword">instanceof</span> Car);<br><span class="hljs-comment">// expected output: true</span><br><br><span class="hljs-built_in">console</span>.log(auto <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);<br><span class="hljs-comment">// expected output: true</span><br></code></pre></td></tr></table></figure><h2 id="判断变量是否是数组"><a href="#判断变量是否是数组" class="headerlink" title="判断变量是否是数组"></a>判断变量是否是数组</h2><p>1 <code>isArray</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(arr))<br></code></pre></td></tr></table></figure><p>2 <code>instanceof</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)<br></code></pre></td></tr></table></figure><p>3 原型<code>prototype</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-built_in">Object</span>.prototype.toString.call(arr).indexOf(<span class="hljs-string">&#x27;Array&#x27;</span>) &gt; -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>4 <code>isPrototypeOf</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-built_in">Array</span>.prototype.isPrototypeOf(arr)<br></code></pre></td></tr></table></figure><p>5 <code>constructor</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>arr.constructor.toString().indexOf(<span class="hljs-string">&#x27;Array&#x27;</span>) &gt; -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="new-操作符具体做了什么"><a href="#new-操作符具体做了什么" class="headerlink" title="new 操作符具体做了什么"></a>new 操作符具体做了什么</h2><p>1 创建了一个空对象</p><p>2  将空对象的原型，指向构造函数的原型</p><p>fn.prototype === new fn().<code>__proto__</code></p><p>3 将空对象作为构造函数的上下文（改变this的方向）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-comment">// this指向window</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Foo()) <span class="hljs-comment">// Foo &#123;name: &#x27;aa&#x27;&#125; this指向new出来的对象</span><br><br></code></pre></td></tr></table></figure><p>4 对构造函数有返回值的处理判断</p><p>如果返回的是基本类型，则没有影响，如果是对象，则就是返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-comment">// this指向window</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">11</span><br>    <span class="hljs-comment">// return &#123;&#125;</span><br>    <span class="hljs-comment">// return [1,2,3]</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Foo()) <span class="hljs-comment">// Foo &#123;name: &#x27;aa&#x27;&#125; 返回的11没有影响</span><br><br></code></pre></td></tr></table></figure><h3 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">fn,...args</span>)</span>&#123;<br>    <span class="hljs-comment">// 创建一个空对象</span><br><span class="hljs-keyword">const</span> obj = &#123;&#125;<br>    <span class="hljs-comment">// 将空对象的原型，指向构造函数的原型</span><br>    Obeject.setPrototypeOf(obj,fn.prototype)<br>    <span class="hljs-comment">// 将空对象作为构造函数的上下文(改变this指向)</span><br>    <span class="hljs-keyword">const</span> result = fn.apply(obj,args)<br>    <span class="hljs-comment">// 对构造函数的有返回值的处理判断</span><br>    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ? result : obj<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="1-闭包是什么"><a href="#1-闭包是什么" class="headerlink" title="1 闭包是什么"></a>1 闭包是什么</h3><p>闭包是一个函数加上创建函数的作用域链接，闭包“关闭”了函数的自由变量。</p><p>通俗的描述：函数嵌套函数，内部函数就是闭包</p><p>正常情况下，函数执行完后，内部的变量会销毁，但是有了闭包后，函数内部的变量就可以保存。等内部的函数（闭包）执行外后，该变量才会被销毁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> lis = <span class="hljs-built_in">document</span>.getElmentsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>) <span class="hljs-comment">// 加上lis长度为5</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;lis.length;i++)&#123;<br>lis[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>alert(i)<br>&#125;<br>&#125;<br><span class="hljs-comment">// 每次点击列表的某个元素，都显示5</span><br><span class="hljs-comment">// 下面看加了闭包</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;lis.length;i++)&#123;<br>    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;<br>        lis[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            alert(i)<br>        &#125;<br>    &#125;)(i)<br>&#125;<br><span class="hljs-comment">// 每次点击列表的某个元素，对应显示下标0,1,2,3,4</span><br></code></pre></td></tr></table></figure><h3 id="2-闭包解决什么问题"><a href="#2-闭包解决什么问题" class="headerlink" title="2 闭包解决什么问题"></a>2 闭包解决什么问题</h3><ul><li><p>延长变量的生命周期（原理是内部函数可以访问到外部函数的局部变量）</p></li><li><p>实现模块化功能（创建私有环境）</p><p>vue 的组件中的data是一个函数就是利用闭包的思想，可以保护组件的数据不被其他组件影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cal = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span>&#123;<br>        reurn a+b<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> a-b<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>        add,<br>        sub<br>    &#125;<br>&#125;)()<br><br><span class="hljs-built_in">console</span>.log(cal.add()) <span class="hljs-comment">// 30</span><br><span class="hljs-built_in">console</span>.log(cal.sub()) <span class="hljs-comment">// -10</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-闭包缺点"><a href="#3-闭包缺点" class="headerlink" title="3 闭包缺点"></a>3 闭包缺点</h3><p>变量驻留在内存中，造成内存损耗</p><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>每个对象都有原型对象，原型对象上的所有属性和方法，该对象都能访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> cat = &#123;<br><span class="hljs-attr">name</span>:<span class="hljs-string">&quot;喵喵&quot;</span><br>&#125;<br>cat.__proto__.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;吃鱼&quot;</span>)<br>&#125;<br>cat.eat() <span class="hljs-comment">// 吃鱼</span><br></code></pre></td></tr></table></figure><h3 id="获取原型的方法"><a href="#获取原型的方法" class="headerlink" title="获取原型的方法"></a>获取原型的方法</h3><ul><li><p>通过对象的<code>__proto__</code></p></li><li><p>通过构造函数（或者类）的<code>prototype</code></p><p>new 创建的是一个对象。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;喵喵&quot;</span>,<span class="hljs-number">2</span>)<br>Cat.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;吃鱼&quot;</span>)<br>&#125;<br>cat.eat() <span class="hljs-comment">// 吃鱼</span><br></code></pre></td></tr></table></figure><h3 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h3><p>1 类</p><p>ES5创建对象用构造函数，ES6创建对象用<code>class</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span></span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.age = age<br>    &#125;<br>&#125;<br>Cat.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;吃鱼&quot;</span>)<br>&#125;<br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;喵喵&quot;</span>,<span class="hljs-number">2</span>)<br>cat.eat() <span class="hljs-comment">// 吃鱼</span><br></code></pre></td></tr></table></figure><p>2 继承</p><ul><li>ES6</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">username,password</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.username = username<br>    <span class="hljs-built_in">this</span>.password = password<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">login</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;log in&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Admin</span> <span class="hljs-title">extend</span> <span class="hljs-title">User</span></span>&#123;<br><span class="hljs-function"><span class="hljs-title">deletePerson</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;删除了一个用户&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> admin = <span class="hljs-keyword">new</span> Admin()<br>admin.login() <span class="hljs-comment">// log in</span><br></code></pre></td></tr></table></figure><ul><li>ES5： prototype</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">username,password</span>)</span>&#123;<br><span class="hljs-built_in">this</span>.username = username<br><span class="hljs-built_in">this</span>.password = password<br>    <span class="hljs-built_in">this</span>.login()&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;log in&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Admin</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.deletePerson()&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;删除了一个用户&quot;</span>)<br>&#125;<br>    <br>&#125;<br>Admin.prototype = <span class="hljs-keyword">new</span> User()<br><span class="hljs-keyword">let</span> admin = <span class="hljs-keyword">new</span> Admin()<br>admin.login() <span class="hljs-comment">// log in</span><br></code></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ol><li><p>原型链是什么</p><p>一个对象有原型，其原型又是一个对象，该对象也有原型，可以看，一直往上，有一条原型链存在。（最顶端是<code>Obejct.prototype</code>)</p></li><li><p>解决什么问题</p><p>对象共享属性和共享方法</p></li><li><p>谁有原型</p><p>函数：prototype</p><p>对象：<code>__proto__</code></p></li><li><p>对象查找属性或者方法的顺序</p><p>对象本身找 =&gt; 构造函数找 =&gt; 对象原型找 <code>__proto__</code>=&gt; 构造函数原型找  prototype =&gt; 对象上一层原型查找 </p></li></ol><h3 id="JS继承"><a href="#JS继承" class="headerlink" title="JS继承"></a>JS继承</h3><p>1 ES6</p><p>2 原型链</p><p>3 构造函数继承</p><p>4 组合式继承</p><h2 id="call-apply-bind区别"><a href="#call-apply-bind区别" class="headerlink" title="call, apply, bind区别"></a>call, apply, bind区别</h2><h3 id="共同点：功能一致"><a href="#共同点：功能一致" class="headerlink" title="共同点：功能一致"></a>共同点：功能一致</h3><ul><li>改变this指向，</li><li>语法：函数.call() 、函数.apply()、函数.bind()</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>call, apply可以立即执行，bind不会立即执行（返回的是一个函数）</li><li>参数：apply第二个参数是数组，call和bind有多个参数是需要挨着写(arg1,arg2,arg3,…)</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>继承：子类可以继承父类的方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;吃东西&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"></span>)</span>&#123;<br>    Animal.call(<span class="hljs-built_in">this</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat()<br>cat.eat() <span class="hljs-comment">// 吃东西</span><br></code></pre></td></tr></table></figure><ul><li>求最大值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>,arr)) <span class="hljs-comment">// 求最大值</span><br><span class="hljs-comment">// Math.max(...arr)</span><br></code></pre></td></tr></table></figure><p>2 bind</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> bnt = <span class="hljs-built_in">document</span>.getElmentById(<span class="hljs-string">&#x27;btn&#x27;</span>)<br><span class="hljs-keyword">const</span> hls = <span class="hljs-built_in">document</span>.getElmentById(<span class="hljs-string">&#x27;hls&#x27;</span>)<br>bnt.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id)<br>&#125;.bind(hls)<br></code></pre></td></tr></table></figure><h3 id="手写bind-call-aplly"><a href="#手写bind-call-aplly" class="headerlink" title="手写bind, call, aplly"></a>手写bind, call, aplly</h3><ul><li><p>手写<code>bind</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj,...args</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...rest</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">this</span>.call(obj,...args,...rest)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>手写<code>call</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, ...args</span>) </span>&#123;<br>    <span class="hljs-comment">// this表示f.myCall的f函数</span><br>    obj.fn = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">const</span> result = obj.fn(...args)<br>    <span class="hljs-comment">// 删除 fn</span><br>    <span class="hljs-keyword">delete</span> obj.fn<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>手写<code>apply</code></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, args</span>) </span>&#123;<br>    <span class="hljs-comment">// this表示f.myCall的f函数</span><br>    obj.fn = <span class="hljs-built_in">this</span><br>    <span class="hljs-keyword">const</span> result = obj.fn(...args)<br>    <span class="hljs-comment">// 删除 fn</span><br>    <span class="hljs-keyword">delete</span> obj.fn6ew<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><h3 id="1-普通函数或作为对象属性"><a href="#1-普通函数或作为对象属性" class="headerlink" title="1 普通函数或作为对象属性"></a>1 普通函数或作为对象属性</h3><p>函数作为对象的属性被调用的时候，其<code>this</code>指向调用该函数的对象，否则其<code>this</code>指向<code>window</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 指向window</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;OBJ&#x27;</span>, fn &#125;;<br><br>fn(); <span class="hljs-comment">// window（相当于window.fn()） </span><br><br>obj.fn();<span class="hljs-comment">// &#123;name: &#x27;OBJ&#x27;, fn: function() &#123;console.log(this)&#125;&#125; // obj</span><br><br><span class="hljs-keyword">const</span> fn1 = obj.fn; <br>fn1(); <span class="hljs-comment">// window</span><br></code></pre></td></tr></table></figure><h3 id="2-事件绑定"><a href="#2-事件绑定" class="headerlink" title="2 事件绑定"></a>2 事件绑定</h3><p>在进行事件绑定的时候，事件绑定函数中的<code>this</code>是绑定事件的元素</p><h3 id="3-构造函数-new-Fn"><a href="#3-构造函数-new-Fn" class="headerlink" title="3 构造函数(new Fn)"></a>3 构造函数(<code>new Fn</code>)</h3><p>构造函数(<code>new Fn</code>)执行，函数中的<code>this</code>是当前类的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">const</span> Fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x = <span class="hljs-number">200</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;;<br><br><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">new</span> Fn(); <span class="hljs-comment">// 200</span><br><br></code></pre></td></tr></table></figure><h3 id="4-箭头函数"><a href="#4-箭头函数" class="headerlink" title="4 箭头函数"></a>4 箭头函数</h3><p>箭头函数中没有自身的<code>this</code>，所用到的<code>this</code>都是其最近父级上下文中的<code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//  &#123;x:100, fn: function() &#123;...&#125;&#125; // obj</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// window 定时器是全局的</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// &#123;x:100, fn: function() &#123;...&#125;&#125; // obj</span><br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>, fn &#125;;<br><br>obj.fn();<br><br></code></pre></td></tr></table></figure><h3 id="5-call-apply-bind改变this指向"><a href="#5-call-apply-bind改变this指向" class="headerlink" title="5 call/apply/bind改变this指向"></a>5 <code>call/apply/bind</code>改变<code>this</code>指向</h3><p><code>call/apply/bind</code>传入的第一个参数即为函数的<code>this</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">200</span> &#125;;<br><span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;;<br><br>fn(); <span class="hljs-comment">// 100</span><br>fn.call(obj); <span class="hljs-comment">// 200</span><br>fn.apply(obj); <span class="hljs-comment">// 200</span><br><br><span class="hljs-keyword">const</span> fixedThisFn = fn.bind(obj);<br>fixedThisFn(); <span class="hljs-comment">//200</span><br><br></code></pre></td></tr></table></figure><ul><li><p><code>call</code>在执行时，第一个参数为<code>this</code>指向，之后的参数为<code>fn</code>执行时的参数</p></li><li><p><code>apply</code>在执行时，第一个参数为<code>this</code>指向，之后的参数为<code>fn</code>执行时的参数组成的数组，数组的每一项会和<code>fn</code>的每一个参数进行对应</p></li><li><p><code>bind</code>在执行时，第一个参数为预先传入<code>this</code>指向，之后的参数为实际调用<code>fn</code>前预先传入的参数，返回值为一个函数<code>fixedThisFn</code>，<code>fixedThisFn</code>内部会调用<code>fn</code>并指定其<code>this</code>指向</p></li></ul><h2 id="promiss和async函数"><a href="#promiss和async函数" class="headerlink" title="promiss和async函数"></a><code>promiss</code>和<code>async</code>函数</h2><h3 id="1-promiss用法"><a href="#1-promiss用法" class="headerlink" title="1 promiss用法"></a>1 <code>promiss</code>用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Promiss(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">11</span>)<br>    resolve(<span class="hljs-number">22</span>)<br>&#125;)<br><span class="hljs-comment">// .then的data是resolve里的，只有调用resolve才会执行.then</span><br>p.then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-async函数"><a href="#2-async函数" class="headerlink" title="2 async函数"></a>2 <code>async</code>函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> functin <span class="hljs-function"><span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(fun()) <span class="hljs-comment">// 返回一个promiss</span><br><br><span class="hljs-comment">// ------------- 上面这代码和下面的代码等效 ----------------</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promiss(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        resolve(<span class="hljs-number">1</span>)<br>    &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-async-await"><a href="#3-async-await" class="headerlink" title="3 async await"></a>3 <code>async await</code></h3><p><code>await</code> 后面是一个<code>promiss</code>对象，可以拿到<code>resolve</code>的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Promiss(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>resolve(<span class="hljs-number">1</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> Promiss(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>resolve(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> p1<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> p2<br>    <span class="hljs-built_in">console</span>.log(a,b) <span class="hljs-comment">// 1,2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-手写promiss"><a href="#4-手写promiss" class="headerlink" title="4 手写promiss"></a>4 <a href="https://juejin.cn/post/7100754145891581983#heading-2">手写<code>promiss</code></a></h3><p>一个简单的 <code>Promise</code> 的粗糙实现，关键点在于</p><ol><li>有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）</li><li><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</li><li>设置两个队列，<code>onResolvedCallbacks</code>，<code>onRejectedCallbacks</code>，用于存放成功和失败的回调函数，当状态发生改变时依次从数组中取出执行。</li><li>利用<code>setTimeout</code>实现<code>resolve</code>和<code>rejected</code>异步</li><li><code>then</code>返回<code>promiss</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prom</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;PENDING&quot;</span><br>        <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">undefined</span><br>        <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">undefined</span><br>        <span class="hljs-comment">// 保存尚未fulfilled的then中的回调函数(异步)</span><br>        <span class="hljs-built_in">this</span>.onResolvedCallbacks = [];<br>        <span class="hljs-comment">// 保存尚未rejected的then中的回调函数(异步)</span><br>        <span class="hljs-built_in">this</span>.onRejectedCallbacks = [];<br>        <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;RESOLVED&quot;</span><br>                <span class="hljs-built_in">this</span>.value = value<br>                <span class="hljs-comment">// 判断成功回调是否存在，如果存在就调用</span><br>                <span class="hljs-comment">// 循环回调数组. 把数组前面的方法弹出来并且直接调用</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.onResolvedCallbacks.length) &#123;<br>                    <span class="hljs-built_in">this</span>.onResolvedCallbacks.shift()(value)<br>                &#125;<br>            &#125;)<br>        &#125;<br>        <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-built_in">this</span>.state = <span class="hljs-string">&quot;REJECTED&quot;</span><br>                <span class="hljs-built_in">this</span>.reason = reason<br>                <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.onRejectedCallbacks.length) &#123;<br>                    <span class="hljs-built_in">this</span>.onRejectedCallbacks.shift()(reason)<br>                &#125;<br>            &#125;)<br>        &#125;<br>        fn(resolve, reject)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled</span>)</span> &#123;<br>        <span class="hljs-comment">// 当传入的then回调函数为空的时候。。创建对应的空函数</span><br>        onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function">() =&gt;</span> &#123; &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;RESOLVED&quot;</span>) &#123;<br>            <span class="hljs-keyword">const</span> result = onFulfilled(<span class="hljs-built_in">this</span>.value);<br>            <span class="hljs-comment">// 需要返回一个 Promise</span><br>            <span class="hljs-comment">// 如果状态为 resolved，直接执行</span><br>            <span class="hljs-keyword">return</span> Prom.resolve(result);<br>        &#125; <br>        <span class="hljs-comment">// then方法执行时如果状态是等待态，就将其回调函数存入对应数组</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state === <span class="hljs-string">&quot;PENDING&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Prom(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-comment">// 新增等待态判断，此时异步代码还未走完，回调入数组队列</span><br>                <span class="hljs-built_in">this</span>.onResolvedCallbacks.push(onFulfilled)<br>            &#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(onRejcted) &#123;<br>        onRejcted = <span class="hljs-keyword">typeof</span> onRejcted === <span class="hljs-string">&quot;function&quot;</span> ? onRejcted : <span class="hljs-function">() =&gt;</span> &#123; &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;REJECTED&quot;</span>) &#123;<br>            <span class="hljs-keyword">const</span> reason = onRejcted(<span class="hljs-built_in">this</span>.reason);<br>            <span class="hljs-keyword">return</span> Prom.reject(reason);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;PENDING&quot;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Prom(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>                <span class="hljs-comment">// 新增等待态判断，此时异步代码还未走完，回调入数组队列</span><br>                <span class="hljs-built_in">this</span>.onRejectedCallbacks.push(onRejcted)<br>            &#125;);<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="可枚举、不可枚举"><a href="#可枚举、不可枚举" class="headerlink" title="可枚举、不可枚举"></a>可枚举、不可枚举</h2><p>对象的属性所有的特性有以下几种：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">value:属性的值<br>writable:如果为false，属性的值就不能被重写。<br>get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。<br>set:一旦目标属性被赋值，就会调回此方法。<br>configurable:如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被无效化。<br><br><span class="hljs-section">### enumerable:是否能在for...in循环中遍历出来或在Object.keys中列举出来。</span><br></code></pre></td></tr></table></figure><p>其中<code>enumerable</code>表示可枚举特性(true为可，false为不可)。</p><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><p>基本类型存储在栈内存中，对象存储在堆内存中</p><h3 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1 浅拷贝"></a>1 浅拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copy</span>(<span class="hljs-params">obj</span>)</span>&#123;<br><span class="hljs-keyword">let</span> newObj = &#123;&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj)&#123;<br>newObj[i] = obj[i]<br>&#125;<br><span class="hljs-keyword">return</span> newObj<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点：对象的属性只能是基本类型，不能是对象，所以该方法只能进行浅拷贝</p><h3 id="2-深拷贝（对象里面包含对象的拷贝）"><a href="#2-深拷贝（对象里面包含对象的拷贝）" class="headerlink" title="2 深拷贝（对象里面包含对象的拷贝）"></a>2 深拷贝（对象里面包含对象的拷贝）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copy</span>(<span class="hljs-params">obj</span>)</span>&#123;<br><span class="hljs-keyword">let</span> newObj = &#123;&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj)&#123;<br><span class="hljs-keyword">if</span>(obj[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>)&#123;<br>newObj[i] = copy(obj[i])<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>newObj[i] = obj[i]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> newObj<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-对象的拷贝"><a href="#3-对象的拷贝" class="headerlink" title="3 对象的拷贝"></a>3 对象的拷贝</h3><ul><li><p>方法一 Object.assign()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Wes Bos&#x27;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">80</span><br> &#125;;<br><span class="hljs-keyword">const</span> cap2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, person, &#123; <span class="hljs-attr">number</span>: <span class="hljs-number">99</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span> &#125;);<br><span class="hljs-built_in">console</span>.log(cap2); <span class="hljs-comment">// Object &#123;name: &quot;Wes Bos&quot;, age: 12, number: 99&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>方法二 JSON 转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> wes = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Wes&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">social</span>: &#123;<br>    <span class="hljs-attr">twitter</span>: <span class="hljs-string">&#x27;@wesbos&#x27;</span>,<br>    <span class="hljs-attr">facebook</span>: <span class="hljs-string">&#x27;wesbos.developer&#x27;</span><br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> dev2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(wes));<br><span class="hljs-built_in">console</span>.log(dev2);<br></code></pre></td></tr></table></figure></li></ul><h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>防止触发事件过于频繁，只执行最后一次</p><h4 id="1-手写防抖"><a href="#1-手写防抖" class="headerlink" title="1 手写防抖"></a>1 手写防抖</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> inp = ducoment.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>)<br>inp.onchange = debounce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.value)<br>&#125;,<span class="hljs-number">500</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn,delay</span>)</span>&#123;<br><span class="hljs-keyword">let</span> t = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(t !== <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">clearTimeout</span>(t)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            t = <span class="hljs-built_in">setTimeout</span>(()=&#123;<br>                fn.call(<span class="hljs-built_in">this</span>)<br>            &#125;,delay)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-防抖应用场景"><a href="#2-防抖应用场景" class="headerlink" title="2 防抖应用场景"></a>2 防抖应用场景</h4><ol><li>登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖</li><li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖</li><li>文本编辑器实时保存，当无任何更改操作一秒后进行保存</li></ol><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>控制执行次数</p><h4 id="1-手写节流"><a href="#1-手写节流" class="headerlink" title="1 手写节流"></a>1 手写节流</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> inp = ducoment.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>)<br><span class="hljs-built_in">window</span>.onscroll = throttle(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;滚动&quot;</span>)<br>&#125;,delay)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn,delay</span>)</span>&#123;<br><span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            <span class="hljs-built_in">setTimeout</span>(()=&#123;<br>                fn.call(<span class="hljs-built_in">this</span>)<br>            flag = <span class="hljs-literal">true</span><br>            &#125;,delay)<br>        &#125;<br>    flag = <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-节流应用场景"><a href="#2-节流应用场景" class="headerlink" title="2 节流应用场景"></a>2 节流应用场景</h4><ol><li><code>scroll</code> 事件，每隔一秒计算一次位置信息等</li><li>浏览器播放事件，每个一秒计算一次进度信息等</li><li>input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖)</li></ol><h3 id="总结-简要答案"><a href="#总结-简要答案" class="headerlink" title="总结 (简要答案)"></a>总结 (简要答案)</h3><ul><li>防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。**代码实现重在清零 <code>clearTimeout</code>**。防抖可以比作等电梯，只要有一个人进来，就需要再等一会儿。业务场景有避免登录按钮多次点击的重复提交。</li><li>节流：控制流量，单位时间内事件只能触发一次，与服务器端的限流 (Rate Limit) 类似。**代码实现重在开锁关锁 <code>timer=timeout; timer=null</code>**。节流可以比作过红绿灯，每等一个红灯时间就可以过一批。</li></ul><ul><li><strong>debounce:</strong> Grouping a sudden burst of events (like keystrokes) into a single one.</li><li><strong>throttle:</strong> Guaranteeing a constant flow of executions every X milliseconds. Like checking every 200ms your scroll position to trigger a CSS animation.</li></ul><h2 id="ES6-filter函数"><a href="#ES6-filter函数" class="headerlink" title="ES6 filter函数"></a>ES6 filter函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-comment">// cur 当前值； idx 当前值的下标； arr 数组对象</span><br><span class="hljs-keyword">const</span> b = arr.filter(<span class="hljs-function">(<span class="hljs-params">cur,idx,arr</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> cur&gt;<span class="hljs-number">3</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">//12345</span><br><span class="hljs-built_in">console</span>.log(b) <span class="hljs-comment">// 45</span><br></code></pre></td></tr></table></figure><h2 id="forEach-和map区别"><a href="#forEach-和map区别" class="headerlink" title="forEach 和map区别"></a><code>forEach</code> 和<code>map</code>区别</h2><ol><li><code>forEach</code><ul><li>没有返回值</li><li>不会被break打断</li><li>遍历的是<code>value</code></li></ul></li><li><code>map</code><ul><li>有返回值，返回是数组，默认返回值是undefined</li><li>不会被break打断</li><li>遍历的是<code>value</code>和<code>key</code></li></ul></li></ol><h2 id="ES6-解构"><a href="#ES6-解构" class="headerlink" title="ES6 解构"></a>ES6 解构</h2><h3 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> list = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">let</span> first = list[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">let</span> second = list[<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">let</span> [first, second] = list;<br><br><span class="hljs-comment">// 解构中交换数据</span><br><span class="hljs-keyword">let</span> car1 = <span class="hljs-string">&#x27;bmw&#x27;</span>;<br><span class="hljs-keyword">let</span> car2 = <span class="hljs-string">&#x27;audi&#x27;</span><br>[car2, car1] = [car1, car2]<br></code></pre></td></tr></table></figure><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> family = &#123;<br>    <span class="hljs-attr">father</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-attr">mother</span>: <span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> &#123; father, mother &#125; = family;<br><br><span class="hljs-comment">// 解构对象并重命名变量</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">father</span>: f, <span class="hljs-attr">mother</span>:m &#125; =  &#123;<span class="hljs-attr">father</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-attr">mother</span>: <span class="hljs-string">&#x27;2&#x27;</span>&#125;<br><span class="hljs-built_in">console</span>.log(f); <span class="hljs-comment">// &#x27;1&#x27;</span><br><br><span class="hljs-comment">// 函数解构</span><br><span class="hljs-keyword">const</span> family = &#123;<br>    <span class="hljs-attr">father</span>: <span class="hljs-string">&#x27;baba&#x27;</span>,<br>    <span class="hljs-attr">mother</span>: <span class="hljs-string">&#x27;mama&#x27;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">&#123; father &#125;</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(father)<br>&#125;<br>log(family) <span class="hljs-comment">// baba</span><br></code></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="常用的正则表达式有哪些？"><a href="#常用的正则表达式有哪些？" class="headerlink" title="常用的正则表达式有哪些？"></a>常用的正则表达式有哪些？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// （1）匹配 16 进制颜色值</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;<br><br><span class="hljs-comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;<br><br><span class="hljs-comment">// （3）匹配 qq 号</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;<br><br><span class="hljs-comment">// （4）手机号码正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^1[34578]\d&#123;9&#125;$/g</span>;<br><br><span class="hljs-comment">// （5）用户名正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;<br></code></pre></td></tr></table></figure><h2 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h2><h2 id="类数组转化为数组的方法"><a href="#类数组转化为数组的方法" class="headerlink" title="类数组转化为数组的方法"></a>类数组转化为数组的方法</h2><p>题目描述:类数组拥有 length 属性 可以使用下标来访问元素 但是不能使用数组的方法 如何把类数组转化为数组?</p><p>实现代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arrayLike=<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>)<br><br><span class="hljs-comment">// 1.扩展运算符</span><br>[...arrayLike]<br><span class="hljs-comment">// 2.Array.from</span><br><span class="hljs-built_in">Array</span>.from(arrayLike)<br><span class="hljs-comment">// 3.Array.prototype.slice</span><br><span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike)<br><span class="hljs-comment">// 4.Array.apply</span><br><span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, arrayLike)<br><span class="hljs-comment">// 5.Array.prototype.concat</span><br><span class="hljs-built_in">Array</span>.prototype.concat.apply([], arrayLike)<br></code></pre></td></tr></table></figure><h2 id="为什么0-1-0-2-0-3，如何让其相等"><a href="#为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="为什么0.1+0.2 ! == 0.3，如何让其相等"></a>为什么0.1+0.2 ! == 0.3，如何让其相等</h2><p>在开发过程中遇到类似这样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n1 = <span class="hljs-number">0.1</span>, n2 = <span class="hljs-number">0.2</span><br><span class="hljs-built_in">console</span>.log(n1 + n2)  <span class="hljs-comment">// 0.30000000000000004</span><br>复制代码<br></code></pre></td></tr></table></figure><p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(n1 + n2).toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// 注意，toFixed为四舍五入</span><br>复制代码<br></code></pre></td></tr></table></figure><p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p>]]></content>
    
    
    <categories>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前端面试-VUE】VUE合集</title>
    <link href="/myblog.github.io/2022/05/20/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-VUE%E3%80%91VUE%E5%90%88%E9%9B%86/"/>
    <url>/myblog.github.io/2022/05/20/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-VUE%E3%80%91VUE%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### 谈谈vuex原理？</span><br>1 执行Vue.use。会执行vuex的install方法，会往全局混入一个mixin，只有一个属性beforeCreate，它的作用是让每个组件可以访问到this.$store属性。<br><br>2 执行new Vuex.Store。将传入的配置进行格式化处理，会递归注册每个module的state、mutations、actions、getters属性，将每个module的mutations、actions、getters放入一个对象里，对应的key前面会加上模块名，而state会放入一个有上下级关系的对象里。<br><br>3 内部会重写commit和dispatch，当前模块触发状态变更时，自动在要触发的commit和dispatch前面加上模块名。<br><br>4 最后会提供一些map开头的语法糖使用。<br><br><br><br><br><span class="hljs-section">### vuex是什么？怎么使用？哪种功能场景使用它？</span><br>1 状态管理模式。可以看成一个数据仓库，集中管理项目公共数据的，所有组件都可以访问并更改。（统一管理，数据共享，程序可维护性高）<br><br>2 具有state、mutations、actions、getters、module属性。<br>state 有数据； <br>mutations 唯一能更改数据的地方，有点像vue实例的方法；(只能写同步的方法，异步操作写字actions上)<br>actions 提交mutations，不能直接修改state;<br>getters 计算属性;<br>moudle 小仓库，store分割成模块，每个模块拥有自己的 state、mutations、actions、getters、甚至是嵌套子模块<br><br>3 单向数据流<br><br>4 大型项目中比较常用，非关系组件传递数据比较方便<br><br>5 使用<br>5.1 Vue.use 使用vuex插件<br>5.2 new Vuex.Store 创建一个store 实例：里面有state，mutations,actions，getters属性。state初始化数据，mutations、actions和getters可以写方法，actions需要提交mutations才能改变state，getters是计算属性，用来简化数据<br><br>5.3 在Vue 组件中， 可以通过 this.$store 访问store实例，<br>mutations的方法可以通过<span class="hljs-code">`store.commit`</span>调用，触发状态变更。<br>actions  的方法可以通过 <span class="hljs-code">`store.dispatch`</span> 方法触发，如果要改变数据的话，需要再提交mutations<br>getters  的方法直接通过<span class="hljs-code">`store.getters`</span>调用<br><br>5.4 使用mapState、mapMutations、mapActions、mapGetters等辅助函数可以一次性获取仓库的数据或者属性等<br></code></pre></td></tr></table></figure><img src="/myblog.github.io/images/vue_vuex.png" alt="在这里插入图片描述" style="zoom: 80%;" /><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### 双向绑定和 vuex 是否冲突</span><br>1 问题出现的场景：<br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;obj.message&quot;</span>&gt;</span></span><br><br>这里的 obj 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，v-model 会试图直接修改 obj.message。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。<br><br>所以确实会有冲突<br><br>2 解决方案<br>2.1 在input中绑定value(vuex中的state)，然后监听input的change或者input事件，在事件回调中调用mutation修改state的值<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;updateMessage&quot;</span>&gt;</span></span><br><br>// ...<br>computed: &#123;<br>  ...mapState(&#123;<br><span class="hljs-code">    message: state =&gt; state.obj.message</span><br><span class="hljs-code">  &#125;)</span><br><span class="hljs-code">&#125;,</span><br><span class="hljs-code">methods: &#123;</span><br><span class="hljs-code">  updateMessage (e) &#123;</span><br><span class="hljs-code">    this.$store.commit(&#x27;updateMessage&#x27;, e.target.value)</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br><br>2.2 使用带有setter的双向绑定计算属性。<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span></span><br><br>// ...<br>computed: &#123;<br>  message: &#123;<br><span class="hljs-code">    get () &#123;</span><br><span class="hljs-code">      return this.$store.state.obj.message</span><br><span class="hljs-code">    &#125;,</span><br><span class="hljs-code">    set (value) &#123;</span><br><span class="hljs-code">      this.$store.commit(&#x27;updateMessage&#x27;, value)</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br><br><span class="hljs-section">### 聊聊Vuex 的设计思想</span><br><br>把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！<br><br>通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。<br><br><span class="hljs-section">### 为什么 Vuex 的 mutation 不能做异步操作</span><br>1 设计理念。人为规定不能在mutation中使用异步，强行建议做同步操作，将它作为一个无副作用的函数，使得状态可预测的，方便维护。将有副作用的函数放在action中，同步修改放在mutation中<br><br>2 异步操作的副作用。vuex中在mutation中使用异步，程序也不会报错，所以对结果是没有影响的。但是异步操作是成功还是失败不可预测，什么时候进行异步操作也不可预测；当异步操作成功或失败时，如果不 commit(mutation) 或者 dispatch(action)，Vuex 就不能捕获到异步的结果，从而进行相应的操作<br><br><span class="hljs-section">### vuex持久化存储</span><br>1 不能持久化存储，页面一刷新或者关闭就没了<br>2 解决方案：<br>2.1 localStorage<br>2.2 使用插件，比如vue-persist（本质上也是localStorage)<br><br><br><br></code></pre></td></tr></table></figure><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### 对于MVVM的理解</span><br>一个框架，一个理念<br><br>1 为什么有这个框架<br>前端的历史，不从web1.0，web2.0讲起，而是将MVC框架，因为MVVM本质上是MVC的改进版<br><br>1.1 MVC<br>Model View Controller，即模型-视图-控制器。用户访问操作网页会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数据。将结果返回给前端,页面重新渲染。<br><br>1.2 MVC特点<br>特点：单向通信；View和Model直接进行通信<br><br>1.3 痛点<br>随着前端应用的复杂程度越来越复杂，View和Model之间随着业务量的不断庞大，那么MVC就暴露出了三个痛点问题：<br><br>◆ 开发者在代码中大量调用相同的 DOM API，处理繁琐 ，操作冗余，使得代码难以维护。<br>◆ 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。<br>◆ 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。<br><br>所以MVVM就出现了，并且可以解决上述问题。<br><br>2 MVVM这个框架是什么<br><br>MVVM 是 Model-View-ViewModel 的缩写。<br>Model: 代表数据模型，数据层<br>View: 视图层，用户操作界面。<br>ViewModel：业务逻辑层。<br>View通过View-Model的DOM Listeners将事件绑定到Model上，而Model则通过Data Bindings来管理View中的数据，View-Model从中起到一个连接桥的作用。<br><br>MVVM框架与MVC框架的主要区别有两点：<br>◆ 实现数据与视图的分离<br>◆ 数据双向绑定。<br>通过数据来驱动视图，开发者只需要关心数据变化，DOM操作被封装了。<br><br><br>总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。<br><br><br><br><br><br><br><span class="hljs-section">### 为什么使用前端框架?</span><br><br>1 组件化: 高度的组件化可以是我们的工程易于维护、易于组合拓展。<br>2 天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。<br>3 生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案<br><br><br><br><br><br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### MVVM-脏数据检测</span><br><br><br><br><span class="hljs-section">### 当新入职一家公司时，如何快速搭建开发环境并让应用跑起来</span><br><br><br></code></pre></td></tr></table></figure><h2 id="MVVM-数据劫持"><a href="#MVVM-数据劫持" class="headerlink" title="MVVM-数据劫持"></a>MVVM-数据劫持</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### Object.defineProperty</span><br><br><span class="hljs-code">`语法`</span> Object.defineProperty(obj,prop,descriptor)<br><br><span class="hljs-code">`参数`</span><br><span class="hljs-code">    obj:目标对象</span><br><span class="hljs-code">    prop:需要定义的属性或方法的名称</span><br><span class="hljs-code">    descriptor:目标属性所拥有的特性</span><br><span class="hljs-code">`可供定义的特性列表`</span><br><span class="hljs-code"></span><br><span class="hljs-code">    value:属性的值</span><br><span class="hljs-code">    writable:如果为false，属性的值就不能被重写。</span><br><span class="hljs-code">    get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。</span><br><span class="hljs-code">    set:一旦目标属性被赋值，就会调回此方法。</span><br><span class="hljs-code">    configurable:如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被无效化。</span><br><span class="hljs-code">    enumerable:是否能在for...in循环中遍历出来或在Object.keys中列举出来。</span><br><span class="hljs-code"></span><br><br>-----------------------------------------------------------------------------------------------------------<br><span class="hljs-section">下面这段代码演示了object.defineProperty的使用，可以发现当我们访问或者修改对象的属性的时候，可以触发getter和setter函数</span><br><span class="hljs-section">--------------------------------------------------------------------------------------------------------</span><br><br>var data = &#123;<br><span class="hljs-code">    name:&#x27;lhl&#x27;</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br>Object.keys(data).forEach(function(key)&#123;<br><span class="hljs-code">    Object.defineProperty(data,key,&#123;</span><br><span class="hljs-code">        enumerable:true,</span><br><span class="hljs-code">        configurable:true,</span><br><span class="hljs-code">        get:function()&#123;</span><br><span class="hljs-code">            console.log(&#x27;get&#x27;);</span><br><span class="hljs-code">        &#125;,</span><br><span class="hljs-code">        set:function()&#123;</span><br><span class="hljs-code">            console.log(&#x27;监听到数据发生了变化&#x27;);</span><br><span class="hljs-code">        &#125;</span><br><span class="hljs-code">    &#125;)</span><br><span class="hljs-code">&#125;)</span><br><span class="hljs-code"></span><br>data.name //控制台会打印出 “get”<br>data.name = &#x27;hxx&#x27; //控制台会打印出 &quot;监听到数据发生了变化&quot;<br><br><br>从上可以发现，当我们访问(get)或设置(set)对象的属性的时候，都会触发相对应的函数，然后在这个函数里返回或设置属性的值。既然如此，我们当然可以在触发函数的时候动一些手脚做点我们自己想做的事情，这也就是“劫持”操作。<br><br><span class="hljs-section">### 总结</span><br><br>Vue通过Object.defineProperty来劫持对象属性的setter和getter操作，每次访问(get)或设置(set)对象的属性的时候，可以做一些具体的实现自己目的的操作。vue进行数据劫持主要是实现数据双向绑定，所以在劫持到setter和getter的时候，可以“种下”一个监听器，当数据发生变化的时候发出通知。这样就可以实现。<br><br></code></pre></td></tr></table></figure><h2 id="数据双向绑定原理"><a href="#数据双向绑定原理" class="headerlink" title="数据双向绑定原理"></a>数据双向绑定原理</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### 总结</span><br>数据双向绑定的原理离不开数据劫持，Vue通过Object.defineProperty来劫持对象属性的setter和getter操作，每次访问(get)或设置(set)对象的属性的时候，可以做一些具体的实现自己目的的操作。要实现数据双向绑定，就要在劫持到setter和getter的时候，“种下”一个监听器，当数据发生变化的时候发出通知。这样就可以实现。<br><br>-----------------------------------------------------------------------------------------------------------<br><span class="hljs-section">object.defineProperty实现数据劫持的可行性</span><br><span class="hljs-section">--------------------------------------------------------------------------------------------------------</span><br><br><br>var data = &#123; name: &#x27;yck&#x27; &#125;<br>observe(data)<br>let name = data.name // -&gt; get value<br>data.name = &#x27;yyy&#x27; // -&gt; change value<br><br>function observe(obj) &#123;<br>  // 判断类型<br>  if (!obj || typeof obj !== &#x27;object&#x27;) &#123;<br><span class="hljs-code">    return</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">  Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="hljs-code">    defineReactive(obj, key, obj[key])</span><br><span class="hljs-code">  &#125;)</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br>function defineReactive(obj, key, val) &#123;<br>  // 递归子属性<br>  observe(val)<br>  Object.defineProperty(obj, key, &#123;<br><span class="hljs-code">    enumerable: true,</span><br><span class="hljs-code">    configurable: true,</span><br><span class="hljs-code">    get: function reactiveGetter() &#123;</span><br><span class="hljs-code">      console.log(&#x27;get value&#x27;)</span><br><span class="hljs-code">      return val</span><br><span class="hljs-code">    &#125;,</span><br><span class="hljs-code">    set: function reactiveSetter(newVal) &#123;</span><br><span class="hljs-code">      console.log(&#x27;change value&#x27;)</span><br><span class="hljs-code">      val = newVal</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">  &#125;)</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code">注*：observe方法观测对象和数组，给其添加一个observel实例</span><br><span class="hljs-code"></span><br><span class="hljs-section">### 添加发布订阅</span><br>上面代码只是展示了数据劫持的可行性，并没有真正实行，要实现数据双向绑定，还得做一些初始化工作，给model的属性添加发布订阅<br><br><br>// 通过 Dep 解耦<br>class Dep &#123;<br>  constructor() &#123;<br><span class="hljs-code">    this.subs = []</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">  // 订阅，标记要更新的数据</span><br><span class="hljs-code">  addSub(sub) &#123;</span><br><span class="hljs-code">    // sub 是 Watcher 实例</span><br><span class="hljs-code">    this.subs.push(sub)</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">  // 通知（发布），更新数据</span><br><span class="hljs-code">  notify() &#123;</span><br><span class="hljs-code">    this.subs.forEach(sub =&gt; &#123;</span><br><span class="hljs-code">      sub.update()</span><br><span class="hljs-code">    &#125;)</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code">// 全局属性，通过该属性配置 Watcher</span><br><span class="hljs-code">Dep.target = null</span><br><span class="hljs-code"></span><br>function update(value) &#123;<br>  document.querySelector(&#x27;div&#x27;).innerText = value<br>&#125;<br><br>class Watcher &#123;<br>  constructor(obj, key, cb) &#123;<br><span class="hljs-code">    // 将 Dep.target 指向自己</span><br><span class="hljs-code">    // 然后触发属性的 getter 添加监听</span><br><span class="hljs-code">    // 最后将 Dep.target 置空</span><br><span class="hljs-code">    Dep.target = this</span><br><span class="hljs-code">    this.cb = cb</span><br><span class="hljs-code">    this.obj = obj</span><br><span class="hljs-code">    this.key = key</span><br><span class="hljs-code">    this.value = obj[key]</span><br><span class="hljs-code">    Dep.target = null</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">  update() &#123;</span><br><span class="hljs-code">    // 获得新值</span><br><span class="hljs-code">    this.value = this.obj[this.key]</span><br><span class="hljs-code">    // 调用 update 方法更新 Dom</span><br><span class="hljs-code">    this.cb(this.value)</span><br><span class="hljs-code">  &#125;</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br><span class="hljs-section">### 真正实现数据劫持</span><br>function defineReactive(obj, key, val) &#123;<br>  // 递归子属性<br>  observe(val)<br>  let dp = new Dep()<br>  Object.defineProperty(obj, key, &#123;<br><span class="hljs-code">    enumerable: true,</span><br><span class="hljs-code">    configurable: true,</span><br><span class="hljs-code">    get: function reactiveGetter() &#123;</span><br><span class="hljs-code">      console.log(&#x27;get value&#x27;)</span><br><span class="hljs-code">      // 将 Watcher 添加到订阅</span><br><span class="hljs-code">      if (Dep.target) &#123;</span><br><span class="hljs-code">        dp.addSub(Dep.target)</span><br><span class="hljs-code">      &#125;</span><br><span class="hljs-code">      return val</span><br><span class="hljs-code">    &#125;,</span><br><span class="hljs-code">    set: function reactiveSetter(newVal) &#123;</span><br><span class="hljs-code">      console.log(&#x27;change value&#x27;)</span><br><span class="hljs-code">      val = newVal</span><br><span class="hljs-code">      // 执行 watcher 的 update 方法</span><br><span class="hljs-code">      dp.notify()</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">  &#125;)</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h2 id="数据双向绑定问题"><a href="#数据双向绑定问题" class="headerlink" title="数据双向绑定问题"></a>数据双向绑定问题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### Proxy 相比于 defineProperty 的优势</span><br><br>1 Object.defineProperty 缺陷<br><br>◆ 只能对属性进行数据劫持，所以需要深度遍历整个对象<br>◆ 对于数组不能监听到数据的变化<br><br>const arrayProto = Array.prototype<br>export const arrayMethods = Object.create(arrayProto)<br>// hack 以下几个函数<br>const methodsToPatch = [<br>  &#x27;push&#x27;,<br>  &#x27;pop&#x27;,<br>  &#x27;shift&#x27;,<br>  &#x27;unshift&#x27;,<br>  &#x27;splice&#x27;,<br>  &#x27;sort&#x27;,<br>  &#x27;reverse&#x27;<br>]<br>methodsToPatch.forEach(function (method) &#123;<br>  // 获得原生函数<br>  const original = arrayProto[method]<br>  def(arrayMethods, method, function mutator (...args) &#123;<br><span class="hljs-code">    // 调用原生函数</span><br><span class="hljs-code">    const result = original.apply(this, args)</span><br><span class="hljs-code">    const ob = this.__ob__</span><br><span class="hljs-code">    let inserted</span><br><span class="hljs-code">    switch (method) &#123;</span><br><span class="hljs-code">      case &#x27;push&#x27;:</span><br><span class="hljs-code">      case &#x27;unshift&#x27;:</span><br><span class="hljs-code">        inserted = args</span><br><span class="hljs-code">        break</span><br><span class="hljs-code">      case &#x27;splice&#x27;:</span><br><span class="hljs-code">        inserted = args.slice(2)</span><br><span class="hljs-code">        break</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">    if (inserted) ob.observeArray(inserted)</span><br><span class="hljs-code">    // 触发更新</span><br><span class="hljs-code">    ob.dep.notify()</span><br><span class="hljs-code">    return result</span><br><span class="hljs-code">  &#125;)</span><br><span class="hljs-code">&#125;)</span><br><span class="hljs-code"></span><br><br>2 Proxy<br>◆ 原生支持监听数组变化，<br>◆ 并且可以直接对整个对象进行拦截（不只是属性）<br><br>let onWatch = (obj, setBind, getLogger) =&gt; &#123;<br>  let handler = &#123;<br><span class="hljs-code">    get(target, property, receiver) &#123;</span><br><span class="hljs-code">      getLogger(target, property)</span><br><span class="hljs-code">      return Reflect.get(target, property, receiver);</span><br><span class="hljs-code">    &#125;,</span><br><span class="hljs-code">    set(target, property, value, receiver) &#123;</span><br><span class="hljs-code">      setBind(value);</span><br><span class="hljs-code">      return Reflect.set(target, property, value);</span><br><span class="hljs-code">    &#125;</span><br><span class="hljs-code">  &#125;;</span><br><span class="hljs-code">  return new Proxy(obj, handler);</span><br><span class="hljs-code">&#125;;</span><br><span class="hljs-code"></span><br>let obj = &#123; a: 1 &#125;<br>let value<br>let p = onWatch(obj, (v) =&gt; &#123;<br>  value = v<br>&#125;, (target, property) =&gt; &#123;<br>  console.log(<span class="hljs-code">`Get &#x27;$&#123;property&#125;&#x27; = $&#123;target[property]&#125;`</span>);<br>&#125;)<br>p.a = 2 // bind <span class="hljs-code">`value`</span> to <span class="hljs-code">`2`</span><br>p.a // -&gt; Get &#x27;a&#x27; = 2<br><br><br><span class="hljs-section">### v-model原理</span><br>v:model 在模板编译的时候转换代码<br>v-model 本质是 :value 和 v-on，但是略微有点区别。在输入控件下，有两个事件监听，输入中文时只有当输出中文才触发数据赋值<br>v-model 和:bind 同时使用，前者优先级更高，如果 :value 会出现冲突<br>v-model 因为语法糖的原因，还可以用于父子通信<br><br><br></code></pre></td></tr></table></figure><h2 id="vue源码"><a href="#vue源码" class="headerlink" title="vue源码"></a>vue源码</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### diff算法</span><br><br>请说下VUE diff算法<br>1 虚拟节点vnode<br>vnode是描述了节点的对象，vnode提供一种简单对象去代替复杂的 dom 对象，从而优化 dom ,不用不断操作DOM，因为这样很耗性能。<br><br>2 diff算法<br>diff算法去比较新旧vnode的差异，将变化的地方更新到真实的dom上。<br><br>3 总结<br>框架会将所有的结点先转化为虚拟节点Vnode，在发生更改后将VNode和原本页面的OldNode进行对比，然后以VNode为基准，在oldNode上进行准确的修改。（修改准则：原本没有新版有，则增加；原本有新版没有，则删除；都有则进行比较，都为文本结点则替换值；都为静态资源不处理；都为正常结点则替换）<br><br><span class="hljs-section">### 介绍下虚拟 DOM，对虚拟 DOM 的理解</span><br><br>1 Virtual DOM<br><br>Virtual DOM(虚拟DOM)，是由普通的JS对象来描述DOM对象。真实DOM成员，先打印出所有的DOM成员<br><br>--------------------------------------------------------------------------------------------------------<br>let element = document.querySelector(&#x27;#app&#x27;)<br>let s = &#x27;&#x27;<br>for(let key in element)&#123;<br><span class="hljs-code">s += key + &#x27;,&#x27;</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code">console.log(s)</span><br><span class="hljs-code"></span><br>一个DOM的成员是非常多的，创建一个真实DOM成本非常高<br><br>--------------------------------------------------------------------------------------------------------<br>虚拟DOM<br><br>&#123;<br>  sel:&#x27;div&#x27;,<br>  data:&#123;&#125;,<br>  children:undefined,<br>  text:&#x27;hello world&#x27;,<br>  elm:undefined,<br>  key:undefined<br>&#125;<br><br><br>创建成本比真实DOM低很多<br><br><br><br><br><br><span class="hljs-section">### 组件</span><br><br>在 Vue 中，子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的<br><br><span class="hljs-section">### 响应式</span><br>Vue 响应式原理<br><br><span class="hljs-section">### 原理</span><br>vue 中 computed 的原理是什么<br><br>vue-loader 的实现原理是什么<br><br><span class="hljs-section">### key</span><br>react 与 vue 数组中 key 的作用是什么<br>在 react/vue 中数组是否可以以在数组中的次序为 key<br>在虚拟 DOM 中进行 diff 算法时，介绍当根据 key 对数组进行重用时的算法<br><br><br></code></pre></td></tr></table></figure><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs markdown">组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯<br><br><span class="hljs-section">### 父子组件间 </span><br>1 props 和$emit<br>这种方式通常用于父子组件之间的传值，父组件通过属性的方式将值传递给子组件，子组件通过props进行接收。子组件通过自定义事件的方式向父组件传递数据。<br><br>2 $parent获取父组件值<br>这种方式可以让子组件非常方便的获取父组件的值，不仅仅包括数据，还可以是方法。<br><br>3 $children和$refs获取子组件值<br>这两种方式和$parent非常的类似，它们可以直接获取子组件的相关属性或方法，不仅限于数据。<br><br><span class="hljs-section">### 兄弟组件</span><br>1 全局事件总线 <br>this.$bus.$emit<br>this.$bus.$on<br>事件中心的思想也比较简单：中间中心主要就两个作用：触发事件和监听事件。假如两个组件之间需要传递数据，组件A可以触发事件中心的事件，组件B监听事件中心的事件，从而让两个组件之间产生关联，实现数据传递。<br><br>2 Vuex<br><br>Vuex是状态管理器，它存储的数据不是持久化存储，一旦刷新页面或者关闭项目数据便不见了。<br>Vuex存储的数据是响应式的。<br><br>3 localstorage<br><br>loacalStorage是HTML5中的一种数据存储方式，持久化存储，存储的数据不是响应式的。<br><br><span class="hljs-section">### 总结</span><br>Vue中组件通讯的方式有很多种，每一种应用的场景可能都有一些不一样，我们需要在合适的场景下选择合适的通讯方式。<br><br>父子组件间通讯：props和emit、emit、emit、parent、refs和refs和refs和children、v-model<br>兄弟组件间通讯：事件总线、Vuex、localStorage<br>隔代组件间通讯：provide和inject<br>无相关组件间通讯：事件总线、Vuex、localStorage<br><br><br></code></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### Vue的路由实现：hash模式 和 history模式</span><br>1 hash模式: 在浏览器的url中有符号“#”<br><br>2 history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。<br><br><br><span class="hljs-section">### vue-router 有哪几种导航守卫?</span><br>1 全局守卫<br>router.beforeEach 全局前置守卫 进入路由之前<br>router.beforeResolve 全局解析守卫<br>router.afterEach 全局后置钩子 进入路由之后<br><br> // main.js 入口文件<br><span class="hljs-code">    import router from &#x27;./router&#x27;; // 引入路由</span><br><span class="hljs-code">    router.beforeEach((to, from, next) =&gt; &#123; </span><br><span class="hljs-code">      next();</span><br><span class="hljs-code">    &#125;);</span><br><span class="hljs-code">    router.beforeResolve((to, from, next) =&gt; &#123;</span><br><span class="hljs-code">      next();</span><br><span class="hljs-code">    &#125;);</span><br><span class="hljs-code">    router.afterEach((to, from) =&gt; &#123;</span><br><span class="hljs-code">      console.log(&#x27;afterEach 全局后置钩子&#x27;);</span><br><span class="hljs-code">    &#125;);</span><br><span class="hljs-code"></span><br>2 路由独享守卫<br><br>const router = new VueRouter(&#123;<br><span class="hljs-code">      routes: [</span><br><span class="hljs-code">        &#123;</span><br><span class="hljs-code">          path: &#x27;/foo&#x27;,</span><br><span class="hljs-code">          component: Foo,</span><br><span class="hljs-code">          beforeEnter: (to, from, next) =&gt; &#123; </span><br><span class="hljs-code">            // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖</span><br><span class="hljs-code">            // ...</span><br><span class="hljs-code">          &#125;</span><br><span class="hljs-code">        &#125;</span><br><span class="hljs-code">      ]</span><br><span class="hljs-code">    &#125;)</span><br><span class="hljs-code"></span><br>3 路由组件内的守卫（用得较少）<br><br>beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建<br>beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this<br>beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this<br><br><br><span class="hljs-section">### 路由鉴权</span><br>登录页和其他页面分开，登录以后实例化 Vue 并且初始化需要的路由<br>动态路由，通过 addRoute 实现<br>简述路由原理<br><br><span class="hljs-section">### React/Vue 中的 router 实现原理如何</span><br><br><br><span class="hljs-section">### vue-router 实现懒加载的方法？</span><br>1 vue-router 实现懒加载的作用：性能优化，不用到该路由，不加载该组件<br>2 ES6的impot方式: component: () =&gt; import(/<span class="hljs-emphasis">* webpackChunkName: &quot;about&quot; *</span>/ &#x27;../views/About.vue&#x27;)<br>  VUE中的异步组件进行懒加载方式: component: resolve=&gt;(require([&#x27;../views/About&#x27;],resolve))<br></code></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### 请详细说下你对vue生命周期的理解</span><br>1 beforeCreate <br>data和methods中的数据或方法还未初始化，无法调用，只能使用一些默认事件。<br><br>2 created<br>data和methods已经初始化完成了，但是模板还没有编译，也就是我们还不能获取到DOM<br><br>3 beforeMount<br>模板进行编译，会调用render函数生成vDom，也就是虚拟DOM，此时我们同样无法获取DOM节点。无法获取DOM节点的，因为此时只存在VDOM，还在JS级别<br><br>4 mounted<br>模板编译好了，而且挂载到真实DOM树上面去了，也就是我们的页面可以显示了。<br><br>5 beforeUpdate<br>页面或者组件发生变化时，便会执行对应的更新阶段的钩子函数。<br><br>6 updated<br>页面也渲染更新完成了，显示的就是最新的数据<br><br>7 beforeDestory<br>此时组件实际上还没有被销毁，还可以正常使用。我们通常会在这个钩子函数里面解除一些全局或者自定义事件<br><br>8 destoryed<br>此时所有的组件包括子组件都被销毁了。<br><br>9 补充<br>通常情况下我们切换路由等一些操作时，组件都会被销毁，切换回来的时候组件又重新渲染。但是有时候我们为了提高性能，我们可以在切换路由的时候不必销毁组件，这个时候我们就需要用到Vue的一个内置组件keep-alive。<br>activated<br>页面渲染的时候执行<br><br>deactivated<br>页面被隐藏或者页面即将被替换成新的页面时被执行<br><br><span class="hljs-section">### Vue 的父组件和子组件生命周期钩子执行顺序是什么</span><br><br>父组件和子组件钩子执行顺序<br>加载渲染过程：父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted<br>父组件挂载完毕肯定是等里面的子组件都挂载完毕后才算父组件挂载完毕了，所以父组件的mounted在最后。<br>子组件更新过程(子组件更新影响到父组件的情况)：父beforeUpdate -&gt; 子beforeUpdate-&gt;子updated -&gt; 父updted<br>子组件更新过程(子组件更新不影响父组件的情况)：子beforeUpdate -&gt; 子updated<br>父组件更新过程(父组件影响子组件的情况)：父beforeUpdate -&gt; 子beforeUpdate-&gt;子updated -&gt; 父updted<br>父组件更新过程(父组件不影响子组件的情况)：父beforeUpdate -&gt; 父updated<br>销毁过程：父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed<br><br><br></code></pre></td></tr></table></figure><img src="/myblog.github.io/images/vue_lifeCycle.png" alt="Vue 实例生命周期" style="zoom: 50%;" /><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### vue 渲染大量数据时应该怎么优化</span><br>数据量大的时候，可以做分页处理。翻页一次请求10-20条数据<br>按需加载局部数据, 虚拟列表，无限下拉刷新<br>js运行异步处理:<br>分割任务，实现时间切片处理, 类似react fiber, 每次执行记录时间, 超过一定执行时间则settimeout或requestAnimation推迟到下一个时间片,一般一个时间片为16ms<br>大量纯展示的数据,不需要追踪变化的 用object.freeze冻结<br><br><br><span class="hljs-section">### vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？</span><br>1 回答1<br>首页白屏的原因：<br>单页面应用的 html 是靠 js 生成，因为首屏需要加载很大的js文件(app.js vendor.js)，所以当网速差的时候会产生一定程度的白屏<br><br><span class="hljs-strong">**解决办法**</span><br>优化 webpack 减少模块打包体积，code-split 按需加载<br>服务端渲染，在服务端事先拼装好首页所需的 html<br>首页加 loading 或 骨架屏 （仅仅是优化体验）<br><br>2 回答2<br>VUE首页加载过慢，其原因是因为它是一个单页应用，需要将所有需要的资源都下载到浏览器端并解析。<br><br><span class="hljs-strong">**考虑解决办法**</span><br>1.使用首屏SSR + 跳转SPA方式来优化<br>2.改单页应用为多页应用，需要修改webpack的entry<br>3.改成多页以后使用应该使用prefetch的就使用<br>4.处理加载的时间片，合理安排加载顺序，尽量不要有大面积空隙<br>5.CDN资源还是很重要的，最好分开，也能减少一些不必要的资源损耗<br>6.使用Quicklink，在网速好的时候 可以帮助你预加载页面资源<br>7.骨架屏这种的用户体验的东西一定要上，最好借助stream先将这部分输出给浏览器解析<br>8.合理使用web worker优化一些计算<br>9.缓存一定要使用，但是请注意合理使用<br>10.大概就这么多，最后可以借助一些工具进行性能评测，重点调优，例如使用performance自己实现下等<br></code></pre></td></tr></table></figure><h2 id="手写源码"><a href="#手写源码" class="headerlink" title="手写源码"></a>手写源码</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### 如何使用 vue 实现一个 message API</span><br><br><span class="hljs-section">### 写一个发布订阅 EventEmitter方法简单</span><br><br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？</span><br>1 事件代理<br>需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数<br><br>2 作用<br>将事件处理程序代理到父节点，减少内存占用率<br>动态生成子节点时能自动绑定事件处理程序到父节点<br><br><span class="hljs-section">### watch 和 computed 的区别和运用的场景</span><br>1 computed<br>计算属性，值有缓存，只有当计算值变化才变化触发渲染;<br>computer 就是简单计算一下，适用于渲染页面<br><br>2 watch<br>后者监听到值得变化就会执行回调;<br>watch 适合做一些复杂业务逻辑<br><br><br><br><span class="hljs-section">### Vue 中 $nextTick 作用与原理？</span><br>下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。<br>也支持 Promise 的使用，会判断是否实现了 Promise<br>Promise<br>MutationObserver<br>setImmediate<br>setTimeout<br><br><br><span class="hljs-section">### vue 中 v-if 和 v-show 的区别是什么</span><br>v-show 总是会进行编译和渲染的工作 - 它只是简单的在元素上添加了 display: none; 的样式。<br>v-show 具有较高的初始化性能成本上的消耗，但是使得转换状态变得很容易。 <br><br>v-if 才是真正「有条件」的：它的加载是惰性的，因此，若它的初始条件是 false，它就不会做任何事情。这对于初始加载时间来说是有益的，当条件为 true 时，v-if 才会编译并渲染其内容。<br>切换 v-if 下的块儿内容实际上时销毁了其内部的所有元素，比如说处于 v-if 下的组件实际上在切换状态时会被销毁并重新生成，因此，切换一个较大 v-if 块儿时会比 v-show 消耗的性能多。<br><br><br><br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vuejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于EJS+Node.js+MongoDB的全栈电商平台（全英文）</title>
    <link href="/myblog.github.io/2022/05/04/%E5%9F%BA%E4%BA%8EEJS+Node.js+MongoDB%E7%9A%84%E5%85%A8%E6%A0%88%E7%94%B5%E5%95%86%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%85%A8%E8%8B%B1%E6%96%87%EF%BC%89/"/>
    <url>/myblog.github.io/2022/05/04/%E5%9F%BA%E4%BA%8EEJS+Node.js+MongoDB%E7%9A%84%E5%85%A8%E6%A0%88%E7%94%B5%E5%95%86%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%85%A8%E8%8B%B1%E6%96%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="基于EJS-Node-js-MongoDB的全栈电商平台（全英文）"><a href="#基于EJS-Node-js-MongoDB的全栈电商平台（全英文）" class="headerlink" title="基于EJS+Node.js+MongoDB的全栈电商平台（全英文）"></a>基于EJS+Node.js+MongoDB的全栈电商平台（全英文）</h1><p>Full stack ecommerce online store application</p><table><thead><tr><th><em>后台管理账号</em></th></tr></thead><tbody><tr><td>用户名：admin</td></tr><tr><td>密码：123456</td></tr><tr><td></td></tr><tr><td></td></tr></tbody></table><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>本项目为基于EJS+Node.js+MongoDB技术实现的全栈电商平台，用户可以在平台上浏览，搜索所需商品，商家可以在后台上传商品信息并实时发布到平台，供用户进行购买，数据库会实时向用户展示平台上的各种商品。</p><p>本项目是前后端分离开发，前后端功能需求完全独立，数据上相互依靠。前端包括以下几点的核心功能模块：1）商品列表展示模块；2）商品详情模块；3）商品分类展示模块；4）登录模块；5）注册模块；6）购物车模块；7）网站主页菜单栏编辑、添加、删除模块；8）商品类别编辑、添加、删除模块；9）商品信息编辑、添加、删除模块。</p><p>后端主要实现的功能为：1）按类名查询商品列表功能；2）用户登录和注册功能；3）对购物车相应数据的增加、删除、更新和清空功能；4）订单支付功能；5）对商品类别的数据增加、编辑、删除功能；6）对商品的数据增加、编辑、删除功能；7）对网站主页菜单栏的数据增加、编辑、删除功能</p><p>本项目采用的技术是：</p><p>前端：bootstrap, ejs</p><p>后端：node.js,  express, express-router, stripe, mongodb, mongoose,  express-validator, dropzone, passport</p><h2 id="项目功能界面"><a href="#项目功能界面" class="headerlink" title="项目功能界面"></a>项目功能界面</h2><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/node_online_store.png?raw=true"></p><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="1-功能模块分析"><a href="#1-功能模块分析" class="headerlink" title="1 功能模块分析"></a>1 功能模块分析</h3><p>前端采用bootstrap框架来实现页面的快速响应式布局记忆快速搭建。同时使用了EJS这类高效的嵌入式 JavaScript 模板引擎，用来实现动态的数据渲染。后端基于Nodejs 的Express 服务架构，使用非关系型数据库MongoDB 数据支持。整个系统使用流行的MVC 框架结构，实现了表现层、逻辑层和数据层的分离。<br>系统完成之后，可以为买家用户提供商品浏览购买等服务，为卖家提供商品以及商品类别的增添、删除和编辑等功能。</p><p>（1）商品列表展示模块：实现商品列表的整体布局和组件拆分，根据服务器响应的数据，以及EJS模板引擎实现动态地渲染页面。</p><p>（2）商品分类展示模块：使用mongoose的数据库查找功能，按照商品类别（category），查找对应的商品，并把数据给页面进行展示。</p><p>（3）登录模块：主要实现网站的登录，和用户校验功能，当用户未进行登录时不可以对购买商品进行加入购物车操作，只能进行商品的查看，在后台中添加请求拦截可以实现此功能。用户登录后可以实现加入购物车以及购买商品等一系列操作。</p><p>（4）注册模块：主要实现网站账号的注册，注册过程中有些文本框需要满足一定的要求，比如用户名，名字等不能为空，利用express-validator来实现校验。</p><p>（5）购物车模块：把商品加入购物车后回显示商品的数目，购物车结算页面中可以进行商品的增加、减少，清除功能。最后还包括对整个购物车的一键清除，以及支付功能。其中支付功能采用了stripe的接口，可以利用stripe的卡号来进行实际的支付功能。</p><p><del>88888888—除了上述列出的一系列重要模块之外，本系统还利用—88888888888</del></p><h3 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2 数据库设计"></a>2 数据库设计</h3><p>采用MongoDB数据库，这种非关系型数据库拥有以json格式进行数据传输与存储，没有烦琐的业务关系的处理，并且与node.js兼容性非常的良好。采用MongoDB 数据库中自带的Mongoose 类库作为中间件解决数据集合中数据操作问题，并且使用MongoDBCompass图形化管理数据。</p><p>本系统准备了四张表，名字分别为category（存储商品类名信息），page（存储主页导航栏信息），product（存储商品信息），user（存储用户信息）。</p><h3 id="3-前端路由"><a href="#3-前端路由" class="headerlink" title="3 前端路由"></a>3 前端路由</h3><p><img src="C:\Users\superjanice\AppData\Roaming\Typora\typora-user-images\image-20220503160012828.png" alt="image-20220503160012828"></p><h2 id="项目开发详解"><a href="#项目开发详解" class="headerlink" title="项目开发详解"></a>项目开发详解</h2><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p> 1 npm init</p><p>2 新建server.js文件</p><p>3 安装express包 npm i –save express。在server.js文件中编写下述代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>  res.send(<span class="hljs-string">&#x27;Hello World&#x27;</span>)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p>4 在控制台中输入命令 node server.js .一个nodejs服务器就启动了</p><p>访问: <a href="http://localhost:3000/">http://localhost:3000</a></p><h3 id="项目源码目录设计"><a href="#项目源码目录设计" class="headerlink" title="项目源码目录设计"></a>项目源码目录设计</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs md">config 文件夹 配置mongodb服务器、用户登录的passport等<br>models 文件夹 mongoose的数据模型<br>public 文件夹 放一些静态的css,js以及图片等，产品图片也会通过建立文件夹的形式存储在本文件夹中<br>routes 文件夹 存放路由<br>views 文件夹 视图层，用来渲染数据<br>.env 文件 环境变量配置，用来存放一些重要、敏感的信息，比如密钥等<br><br></code></pre></td></tr></table></figure><h3 id="项目用到的库和插件"><a href="#项目用到的库和插件" class="headerlink" title="项目用到的库和插件"></a>项目用到的库和插件</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs markdown">express node.js Web应用框架, 提供各种特性和丰富的 HTTP 工具实现各种 Web 应用的创建。可以快速地搭建一个完整功能的网站。<br><br>ejs JS模板引擎，模板文件后缀.ejs，&lt;% 内容 %&gt;。语法简单，上手容易<br><br>body-parser 一般用到express框架都需要用这个中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。通俗地讲，用了body-parser中间件之后，我们的请求对象中就多了一个body属性，可以通过req.body显示出传入参数。(可以参考这篇博客 https://segmentfault.com/a/1190000041169686)<br><br>express-session 服务器储存。在本项目中用来存储用户购物车一类的数据<br><br>express-validator 表单验证器<br><br>express-messages 提供Flash 通知渲染<br><br>express-fileupload 接受从客户端传来的图片，并将图片作为文件存储在服务端<br><br>fs-extra 文件操作，fs的一个扩展，提供了非常多的便利API，并且继承了fs所有方法和为fs方法添加了promise的支持<br><br>mkdirp 不仅可以创建文件夹，还可以创建多层的文件夹<br><br>connect-flash flash通知<br><br>Mongoose 在 nodeJs 异步环境下对 mongodb 进行便捷操作的对象模型工具。<br><br>bcryptjs 密码加密以及解密匹配<br>passport 登录验证（身份认证的一种），功能单一，只能做登录验证，但非常强大，支持本地账号验证和第三方账号登录验证（OAuth和OpenID等），支持大多数Web网站和服务<br>passport-local passport的依赖包，本地认证，本地身份验证<br><br>resize-img 调整图片大小，比如说奥村图片的时候，重新调大小<br><br>sortablejs JavaScript 拖拽库。可用于列表拖拽排序、以及低代码拖拽配置等场景<br><br>stripe 支付接口<br><br>bootstrap 基于HTML、CSS、JavaScript的前端框架,响应式前端布局<br><br>dropzone 文件拖拽上传功能<br><br>fileupload 实现图片上传<br><br>viewerjs  大图预览（https://github.com/fengyuanchen/viewerjs）<br></code></pre></td></tr></table></figure><h4 id="Express-Messages的基本使用"><a href="#Express-Messages的基本使用" class="headerlink" title="Express Messages的基本使用"></a>Express Messages的基本使用</h4><p>作用：提供flash通知的渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">app.use(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;connect-flash&#x27;</span>)());<br>app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>&#123;<br>  res.locals.messages = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-messages&#x27;</span>)(req, res);<br>  next();<br>&#125;);<br>req.flash(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;Email queued&quot;</span>);<br>req.flash(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;Email sent&quot;</span>);<br>req.flash(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;Email delivery failed&quot;</span>);<br></code></pre></td></tr></table></figure><p>渲染messages, 根据所使用的的模板引擎执行messages函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ejs">EJS:<br>&lt;%- messages() %&gt;<br></code></pre></td></tr></table></figure><h4 id="Connect-Flash的基本使用"><a href="#Connect-Flash的基本使用" class="headerlink" title="Connect Flash的基本使用"></a>Connect Flash的基本使用</h4><p>flash是配合session使用的，所以在使用flash之前，要引入express-session模块，它往往用在登录和注册，消息只会通知一次就消失了，其中redirect和flash是不能分开使用的。</p><p>With the <code>flash</code> middleware in place, all requests will have a <code>req.flash()</code> function that can be used for flash messages.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/flash&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>  <span class="hljs-comment">// Set a flash message by passing the key, followed by the value, to req.flash().</span><br>  req.flash(<span class="hljs-string">&#x27;info&#x27;</span>, <span class="hljs-string">&#x27;Flash is back!&#x27;</span>)<br>  res.redirect(<span class="hljs-string">&#x27;/&#x27;</span>);<br>&#125;);<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>  <span class="hljs-comment">// Get an array of flash messages by passing the key to req.flash()</span><br>  res.render(<span class="hljs-string">&#x27;index&#x27;</span>, &#123; <span class="hljs-attr">messages</span>: req.flash(<span class="hljs-string">&#x27;info&#x27;</span>) &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="Mongoose基本使用"><a href="#Mongoose基本使用" class="headerlink" title="Mongoose基本使用"></a>Mongoose基本使用</h4><p><em>本部分内容主要参考了这篇博客，因为这篇文章写得很详细，想看更多细节，可以点击<a href="https://juejin.cn/post/6918945758968283144">链接</a></em></p><h5 id="1-引入-mongoose-并连接数据库"><a href="#1-引入-mongoose-并连接数据库" class="headerlink" title="1 引入 mongoose 并连接数据库"></a>1 引入 mongoose 并连接数据库</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br>mongoose.connect(<span class="hljs-string">&#x27;mongodb://localhost/test&#x27;</span>); <br>如果有账户密码需要采用下面的连接方式： <br>mongoose.connect(<span class="hljs-string">&#x27;mongodb://eggadmin:123456@localhost:27017/eggcms&#x27;</span>); <br>复制代码<br></code></pre></td></tr></table></figure><h5 id="2-定义-Schema"><a href="#2-定义-Schema" class="headerlink" title="2 定义 Schema"></a>2 定义 Schema</h5><p>数据库中的 Schema，为数据库对象的集合。schema 是 mongoose 里会用到的一种数据模式， 可以理解为表结构的定义；每个 schema 会映射到 mongodb 中的一个 collection，它不具备 操作数据库的能力</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> PageSchema = <span class="hljs-keyword">new</span> mongoose.Schema(&#123;<br>    <span class="hljs-attr">title</span>:&#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>,<br>        <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-attr">slug</span>:&#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>,<br>    &#125;,<br>    <span class="hljs-attr">content</span>:&#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-built_in">String</span>,<br>        <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-attr">sorting</span>:&#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-built_in">Number</span>,<br>    &#125;,<br>  &#125;);<br></code></pre></td></tr></table></figure><h5 id="3-创建数据模型"><a href="#3-创建数据模型" class="headerlink" title="3 创建数据模型"></a>3 创建数据模型</h5><p>定义好了 Schema，接下就是生成 Model。model 是由 schema 生成的模型，可以对数据库的 操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Page = mongoose.model(<span class="hljs-string">&#x27;page&#x27;</span>, PageSchema);<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>mongoose.model</code> 里面可以传入两个参数也可以传入三个参数</li><li><code>mongoose.model</code>（参数 1:模型名称，参数 2:Schema）</li><li><code>mongoose.model</code>（参数 1:模型名称，参数 2:Schema，参数 3:数据库集合名称）</li><li>如果传入 2 个参数的话，这个模型会和模型名称相同的复数的数据库建立连接：如通过下面 方法创建模型，那么这个模型将会操作 users 这个集合。</li></ul><h5 id="4-查找数据"><a href="#4-查找数据" class="headerlink" title="4 查找数据"></a>4 查找数据</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">UserModel.find(&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, docs</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(docs);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h5 id="5-增加数据"><a href="#5-增加数据" class="headerlink" title="5 增加数据"></a>5 增加数据</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//实例化模型 传入增加的数据</span><br><span class="hljs-keyword">var</span> u = <span class="hljs-keyword">new</span> UserModel(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lisi2222&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>  <span class="hljs-attr">status</span>: <span class="hljs-literal">true</span><br>&#125;);<br>u.save();<br>复制代码<br></code></pre></td></tr></table></figure><h5 id="6-修改数据"><a href="#6-修改数据" class="headerlink" title="6 修改数据"></a>6 修改数据</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">UserModel.updateOne(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lisi2222&quot;</span> &#125;, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;哈哈哈&quot;</span> &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;成功&quot;</span>);<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure><h5 id="7-删除数据"><a href="#7-删除数据" class="headerlink" title="7 删除数据"></a>7 删除数据</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">UserModel.deleteOne(&#123; <span class="hljs-attr">_id</span>: <span class="hljs-string">&quot;5b72ada84e284f0acc8d318a&quot;</span> &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err);<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <br>  <span class="hljs-comment">//只会删除一条</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;成功&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="bcryptjs基本使用"><a href="#bcryptjs基本使用" class="headerlink" title="bcryptjs基本使用"></a>bcryptjs基本使用</h4><p><code>bcryptjs</code> 是nodejs中比较好的一款加盐(<code>salt</code>)加密的包, 我们处理密码加密、校验要使用到的两个方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加密处理 - 同步方法</span><br><span class="hljs-comment"> * bcryptjs.hashSync(data, salt)</span><br><span class="hljs-comment"> *    - data  要加密的数据</span><br><span class="hljs-comment"> *    - slat  用于哈希密码的盐。如果指定为数字，则将使用指定的轮数生成盐并将其使用。推荐 10</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> hashPassword = bcryptjs.hashSync(password, <span class="hljs-number">10</span>)<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 校验 - 使用同步方法</span><br><span class="hljs-comment"> * bcryptjs.compareSync(data, encrypted)</span><br><span class="hljs-comment"> *    - data        要比较的数据, 使用登录时传递过来的密码</span><br><span class="hljs-comment"> *    - encrypted   要比较的数据, 使用从数据库中查询出来的加密过的密码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> isOk = bcryptjs.compareSync(password, encryptPassword)<br></code></pre></td></tr></table></figure><h4 id="路由介绍"><a href="#路由介绍" class="headerlink" title="路由介绍"></a>路由介绍</h4><p>路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。</p><p>每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行</p><h4 id="express-session"><a href="#express-session" class="headerlink" title="express-session"></a>express-session</h4><p><a href="http://blog.inode.club/cookie-session-token305/">http://blog.inode.club/cookie-session-token305/</a></p><h4 id="express-validator"><a href="#express-validator" class="headerlink" title="express-validator"></a>express-validator</h4><p><a href="https://juejin.cn/post/6844903854195081223">https://juejin.cn/post/6844903854195081223</a></p><h2 id="项目中遇到的问题"><a href="#项目中遇到的问题" class="headerlink" title="项目中遇到的问题"></a>项目中遇到的问题</h2><h3 id="1-a标签的点击事件以及href跳转的问题"><a href="#1-a标签的点击事件以及href跳转的问题" class="headerlink" title="1 a标签的点击事件以及href跳转的问题"></a>1 a标签的点击事件以及href跳转的问题</h3><p>在项目中，我需要设计一个<strong>删除</strong>按钮（是一个a标签），点击后会弹出确认窗口，如果取消删除，则不发生任何操作。如果点击确定（删除），那么就会进行href的一个路由跳转。</p><p>a标签的click 事件是在页面开始跳转之前执行的。正常情况下，如果给a标签添加一个click点击事件，比如说执行一些打印操作，控制台会很快刷新一下的。因为a标签有默认的一个href跳转动作（默认事件），在执行完打印操作后，页面会很快跳转，这是控制台就已经被刷新了。</p><p>如果要阻止这个默认事件，可以使用e.preventDefalt()。</p><p>参考链接</p><ul><li><p><a href="https://stackoverflow.com/questions/14867558/html-tag-a-want-to-add-both-href-and-onclick-working">HTML tag  want to add both href and onclick working</a></p></li><li><p><a href="http://www.xinxiaoyang.com/programming/2017-03-06-a-tag-with-onclick-event/">a 标签的 href 属性和 onclick 事件</a></p></li></ul><h3 id="2-mkdirp-slower-than-fileupload"><a href="#2-mkdirp-slower-than-fileupload" class="headerlink" title="2 mkdirp slower than fileupload"></a>2 mkdirp slower than fileupload</h3><p>项目中使用mkdirp插件实现多层文件夹的操作，建完文件夹后，需要把图片保存在对应的文件夹中，但这时候我遇到了问题：<strong>No such file or directory</strong>，经观察，我发现创造文件更慢，以至于后面上传文件的时候，没有文件夹。这就是程序报错的原因：。</p><p>更重要的原因是mkdirp这个函数是异步的。因此，可以在异步执行完后返回的promise中使用then方法，继续下面的程序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">mkdirp(<span class="hljs-string">&#x27;public/product_images/&#x27;</span>+ product._id).then(<span class="hljs-function"><span class="hljs-params">made</span> =&gt;</span><br>                                                   &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`made directories, starting with <span class="hljs-subst">$&#123;made&#125;</span>`</span>)<br>    <span class="hljs-keyword">if</span>(imageFile !== <span class="hljs-string">&quot;&quot;</span>)&#123;<br>        <span class="hljs-keyword">let</span> productImage = req.files.image;<br>        <span class="hljs-comment">// console.log(productImage)</span><br>        <span class="hljs-keyword">const</span> filepath = <span class="hljs-string">&#x27;public/product_images/&#x27;</span>+ product._id+<span class="hljs-string">&#x27;/&#x27;</span> + imageFile;<br>        <span class="hljs-comment">// 文件上传</span><br>        productImage.mv(filepath,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(err)<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-request-files获取不到文件的解决方案"><a href="#3-request-files获取不到文件的解决方案" class="headerlink" title="3 request.files获取不到文件的解决方案"></a>3 request.files获取不到文件的解决方案</h3><p>在form表单中发送post请求的时候，需要给服务器一些图片，但是我在req.files上找不到。后来发现是我在form标签了，没有加上 enctype=”multipart/form-data” 的属性。</p><p>要确保能在req.files上获取文件，要确保一些几点：</p><ol><li><p>保证页面中的上传文件标记里都包含name属性。</p></li><li><p>必须在form上添加 enctype=”multipart/form-data” 的属性。</p></li></ol><p>这样后台就可以正常获取input type=”file”提交过来的文件里。</p><h3 id="4-管理台新添page-或者顺序改变，如果不重启服务器，用户主页不会更新"><a href="#4-管理台新添page-或者顺序改变，如果不重启服务器，用户主页不会更新" class="headerlink" title="4 管理台新添page,或者顺序改变，如果不重启服务器，用户主页不会更新"></a>4 管理台新添page,或者顺序改变，如果不重启服务器，用户主页不会更新</h3><p>解决办法是在管理台的adminPages.js文件上，及时更改全局的pages变量，也就是<em>req</em>.app.locals.pages</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">Page.find(&#123;&#125;).sort(&#123;<span class="hljs-attr">sorting</span>:<span class="hljs-number">1</span>&#125;).exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err,pages</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-built_in">console</span>.log(err)<br>    <span class="hljs-comment">// set global pages variable</span><br>    req.app.locals.pages = pages;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5-相对路径和绝对路径的问题"><a href="#5-相对路径和绝对路径的问题" class="headerlink" title="5 相对路径和绝对路径的问题"></a>5 相对路径和绝对路径的问题</h3><p>/product_images和product_images路径的区别，前者绝对路径（localhost:3000/product_images)，后者是相对路径(localhost:3000/当前路径/product_images) app.use(‘/当前路径’)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">os.mkdir(<span class="hljs-string">&#x27;dir_name&#x27;</span>) // 相对路径<br>os.mkdir(<span class="hljs-string">&#x27;/dir_name&#x27;</span>) //绝对路径<br></code></pre></td></tr></table></figure><h3 id="6-using-findOne-inside-a-foreach"><a href="#6-using-findOne-inside-a-foreach" class="headerlink" title="6 using findOne inside a foreach()"></a>6 <a href="https://stackoverflow.com/questions/65538826/using-findone-inside-a-foreach">using findOne inside a foreach()</a></h3><p>由于mongoose数据查询是异步操作，所以如果我在for循环下查找数据库的话会出现问题。</p><p>这个问题出现的场景是，我想在用stripe结账的时候，从服务器上计算total总价格，因此我采用前端传过来的购买商品名字和数量这两个信息，去服务器里匹配对应的商品价格，然后计算total。但是我每次stripe接口结账的时候total为0，而stripe接口必须支付打印1cent以上的金额。所以就出现了程序报错。</p><p>查找了很多资料，有说下面的程序可以解决，但是我试了不可行。但这里我这个方法我还是想做个标记，因为我对异步不是理解得很透彻。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">async</span> () =&gt; &#123;<br>    for (<span class="hljs-name">const</span> question of questionList) &#123;<br>    await questionAction(<span class="hljs-name">question</span>)<span class="hljs-comment">;</span><br>    &#125;<br>&#125;)()<br></code></pre></td></tr></table></figure><p>最后我找到了解决问题的思路，就是数据库接口的设计问题，一个数据库不止可以实现findOne查找，还有findAll查找。为什么要每次在for循环下findOne呢？这很明显不符合数据库接口的设计思路，多次访问数据库也会给服务器带来很多负担。</p><p>所以应该优化这个查询思路，就是一次性找出所有的数据，找出来后再进行计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">Product.find(&#123;<span class="hljs-attr">slug</span>:titles&#125;,<span class="hljs-function">(<span class="hljs-params">err,products</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-built_in">console</span>.log(err);<br>    <span class="hljs-comment">// console.log(item,product)</span><br>    <span class="hljs-keyword">if</span>(products)&#123;<br>        <span class="hljs-comment">// prices.push(product.price)</span><br>        products.forEach(<span class="hljs-function">(<span class="hljs-params">product,i</span>)=&gt;</span>&#123;<br>            <span class="hljs-comment">// console.log(product.title,req.body.items[i])</span><br>            total += product.price * req.body.items[i].quantity<br>        &#125;)<br>        <span class="hljs-built_in">console</span>.log(total)<br>        <span class="hljs-comment">// stripe的total是用美分计算的，，所以要*100</span><br>        stripe.charges.create(&#123;<br>            <span class="hljs-comment">// total金额要在1美元以上</span><br>            <span class="hljs-attr">amount</span>: <span class="hljs-built_in">parseFloat</span>(total).toFixed(<span class="hljs-number">2</span>)*<span class="hljs-number">100</span>,<br>            <span class="hljs-attr">source</span>: req.body.stripeTokenId,<br>            <span class="hljs-attr">currency</span>: <span class="hljs-string">&#x27;usd&#x27;</span><br>        &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 清空购物车</span><br>            <span class="hljs-keyword">delete</span> req.session.cart<br>            <span class="hljs-comment">// You&#x27;re using a res in the then callback, and that one shadows the res from the router.post. </span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Charge Successful&#x27;</span>)<br>            res.json(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Successfully purchased items&#x27;</span> &#125;)<br><br>        &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;           <br>            <span class="hljs-built_in">console</span>.log(e.message,<span class="hljs-string">&#x27;Charge Fail&#x27;</span>)<br>            res.status(<span class="hljs-number">500</span>).end()<br>        &#125;)<br>    &#125;<br></code></pre></td></tr></table></figure><p>解决问题过程中查找的资料：</p><ul><li><p><a href="https://blog.csdn.net/blueblueskyhua/article/details/53783092">解决mongoose数据查询的异步操作</a></p></li><li><p>How to call a mongoose findOne inside the forEach before the answer?<a href="https://helperbyte.com/questions/438636/how-to-call-a-mongoose-findone-inside-the-foreach-before-the-answer"></a></p></li></ul><p><a href="http://www.hpnews.online/topic/57822a8aee5f048d54f9081b&auther=weapon-xx">如何优雅的解决循环里的异步查询</a>？（主要是这个博客点醒了我！！！！）</p><h3 id="7-res-redirect-is-not-a-function-in-promise-then"><a href="#7-res-redirect-is-not-a-function-in-promise-then" class="headerlink" title="7 res.redirect is not a function in promise then"></a>7 <a href="https://stackoverflow.com/questions/50427032/res-redirect-is-not-a-function-in-promise-then">res.redirect is not a function in promise then</a></h3><p>res.redirect cant work in then promise</p><h2 id="项目未来的一些优化想法"><a href="#项目未来的一些优化想法" class="headerlink" title="项目未来的一些优化想法"></a>项目未来的一些优化想法</h2><p>1 采用懒加载的加载模式，大大提高了页面的加载速度，提高用户体验，降低了后台API请求数据的压力。</p><p>2 权限跳转 <a href="https://juejin.cn/post/6844904033660977159">https://juejin.cn/post/6844904033660977159</a></p><p>3 jwt 方式，标识用户身份</p><p>服务器验证成功后应该签发一个身份标识的东西给客户端，这样以后客户端就拿着这个标识来证明自己的身份。而标识用户身份的方式有多种，这里我们采用<code>jwt</code>方式</p><p><a href="https://juejin.cn/post/7044708915438682148">https://juejin.cn/post/7044708915438682148</a></p><p>4 后台管理中，pages 编辑的内容。可以用一些插件修改文字的样式，比如 CKeditor</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个项目大概做了8天。写博客也花了好几个小时。甚至中途都有点想为啥我要花这么久时间写博客，太费时间了。后来我想通了，我目前的学习不是很沉淀，我需要做笔记来加深我对前端知识的理解。所以我应该坚持。</p><p>最近比较忙碌的一段时间，本来想找实习的，但是来不及了，感觉没有准备好。还有这个月中旬由有教资面试（虽然我不打算当老师），但是我就是想拿到这个证，所以我就下定决心要花时间拿到。这个月还想开始联系博导，虽然我的最终目标是硕士毕业工作，做前端开发，但是我本科就有一些文章和成果，所以还是想看看这些东西能不能找个985博士读读。</p><p>最近几个月我还想复习我的光学专业知识，感觉专业上用的中文教材都不是很好，没讲清楚很多东西，所以我找一下国外教材重新复习一下。一下子这么多事情我感觉很烦躁，随便一项工作都要花时间，有些东西最对我来水可能以后还用不到，但是我一想到这点，我就觉得我不能这样想，我不能因为他有用而去学。相反，任何东西都很有用，我应该抱着热爱、兴趣的态度去学习。如果我要是不喜欢，那我才应该真正的放弃。</p>]]></content>
    
    
    <categories>
      
      <category>全栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ejs模板引擎使用</title>
    <link href="/myblog.github.io/2022/04/15/ejs%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/myblog.github.io/2022/04/15/ejs%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ejs是什么"><a href="#1-ejs是什么" class="headerlink" title="1 ejs是什么"></a>1 ejs是什么</h2><p>一套简单的模板语言，可利用普通的 JavaScript 代码生成 HTML 页面</p><h4 id="📖📖📖-ejs-js文档"><a href="#📖📖📖-ejs-js文档" class="headerlink" title="📖📖📖  ejs.js文档"></a>📖📖📖  ejs.js文档</h4><p>官方文档：<a href="https://ejs.bootcss.com/#install">https://ejs.bootcss.com/#install</a></p><h2 id="2-入门"><a href="#2-入门" class="headerlink" title="2 入门"></a>2 入门</h2><h3 id="1-在浏览器-JS-环境中如何使用"><a href="#1-在浏览器-JS-环境中如何使用" class="headerlink" title="1 在浏览器 JS 环境中如何使用"></a>1 在<strong>浏览器 JS 环境</strong>中如何使用</h3><p>1.1 <a href="https://github.com/mde/ejs/releases/latest">下载到ejs的js文件</a></p><p>2.2 新建html文件，html内容如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> =<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;ejs.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">let</span> people = [<span class="hljs-string">&#x27;geddy&#x27;</span>, <span class="hljs-string">&#x27;neil&#x27;</span>, <span class="hljs-string">&#x27;alex&#x27;</span>],</span><br><span class="javascript">    html = ejs.render(<span class="hljs-string">&#x27;&lt;%= people.join(&quot;, &quot;); %&gt;&#x27;</span>, &#123;<span class="hljs-attr">people</span>: people&#125;);</span><br><span class="javascript"><span class="hljs-comment">/* 将写好的ejs进行渲染 */</span></span><br><span class="javascript">  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>).innerHTML = html;</span><br><span class="javascript"></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>说明：需要引入<code>ejs</code>的js文件， <code>ejs.render</code>会返回一个字符串，将字符串挂载到页面中即可显示出来。</p><p><code>ejs.render</code>的语法是<code>ejs.render(str, data, options);</code>str是一个模板字符串，data是模板字符串里面需要用到的数据。</p><p>首先需要用<code>npm</code>安装<code>ejs</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install ejs<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node小项目——购物车</title>
    <link href="/myblog.github.io/2022/04/14/node%E5%B0%8F%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E8%B4%AD%E7%89%A9%E8%BD%A6/"/>
    <url>/myblog.github.io/2022/04/14/node%E5%B0%8F%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E8%B4%AD%E7%89%A9%E8%BD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>项目提供了初始的前端代码（放在public文件夹中），现在需要利用node.js来实现项目的后端部分。</p><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><h3 id="1-npm初始化"><a href="#1-npm初始化" class="headerlink" title="1 npm初始化"></a>1 npm初始化</h3><p>会生成一个<code>package.json</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm init<br></code></pre></td></tr></table></figure><p>npm是包管理工具，下载node的时候回顺带下载到npm。更多想了解的可以参考文档：<a href="https://www.runoob.com/nodejs/nodejs-npm.html">菜鸟教程</a></p><h3 id="2-项目所需库"><a href="#2-项目所需库" class="headerlink" title="2 项目所需库"></a>2 项目所需库</h3><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><p>这个项目需要用到<code>express</code>,<code>ejs</code>,<code>stripe</code>以及<code>dotenv</code>四个库。先大致说一下这几个库的用途。</p><ul><li><p><code>express</code>是用来创建服务器，以及接收请求和响应请求等；</p><p>📖📖📖 官方文档：<a href="https://www.expressjs.com.cn/guide/routing.html">https://www.expressjs.com.cn/guide/routing.html</a></p></li><li><p><code>ejs</code>是用一套模板引擎（或者叫模板语言），因为本项目需要陈列一些商品信息，这些信息我们用一个json文件管理，然后需要动态渲染出来，这时候就用到了<code>ejs</code>语言。</p><p>📖📖📖 官方文档：<a href="https://ejs.bootcss.com/">https://ejs.bootcss.com/</a></p></li><li><p><code>stripe</code>是stripe(一个支付服务平台，有点像国内的阿里)的一个线上支付工具包，另外stripe还提供了一些线上支付的接口，需要注册使用，才能获取到私密钥和公共密钥。</p><p>📖📖📖 官方文档：<a href="https://stripe.com/docs/payments?payments=popular">https://stripe.com/docs/payments?payments=popular</a></p></li><li><p><code>dotenv</code>用来管理环境变量的，stripe提供的接口中申请的私人密钥和公共密钥，其中私人密钥不能出现在生产环境中，只用来测试的时候用，所以需要管理我们的环境变量，让有些模块不会出现的生产环境中。</p></li></ul><h4 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install express ejs stripe dotenv --save<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：加上save会将该依赖存入到package.json 里的dependcies里，不加则不会。</p><p>下载 dotenv (只在开发的时候下载来用，生产环境下是不需要的)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install dotenv -save-dev<br></code></pre></td></tr></table></figure><p>有些模块只是在本地开发的时候用到，这些模块会在<code>devDependencies</code>，在生产环境这些模块不会被打入包内。</p><p>在下载包的时候加上 <code>--also=dev</code>可配置。</p><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><p>本项目的大致思路是：</p><ol><li><p>新建server.js文件，利用express搭建 web 服务器</p></li><li><p>利用git clone<a href="https://github.com/WebDevSimplified/Node.js-Stripe-Shopping-Cart">下载初始文件</a>，将初始文件里的public/fonts文件夹移动那当前项目文件夹中，然后删除多余初始文件，将fonts文件夹重命名为public</p></li><li><p>提供的初始文件是一个静态网页+少量的js交互。利用<code>app.use(express.static(&#39;public&#39;))</code>可查看</p><p>当你点击导航栏的<code>STORE</code>，可以浏览商品页面，点击商品加入购物车，然后点击购买，会alert出“成功购买”的信息。这些是初始文件在js中设计好的，我们项目的就是搭建服务器，将商品信息动态地渲染到页面中。选择商品加入购物车后，在点击购买的时候，调用stripe的接口完成线上支付。</p></li><li><p>新建<code>items.json</code>文件，根据页面的商品信息，做一个简单的商品数据库，以便后期加入其他商品</p></li><li><p>新建<code>views</code>文件夹，把初始文件<code>store.html</code>移动到该文件夹中，然后把该文件后缀名改为<code>.ejs</code></p></li><li><p>利用ejs的语法在.ejs文件中修改对应的商品内容</p></li><li><p>在<code>server.js</code>文件中编写代码，将ejs文件渲染出来</p></li><li><p>注册stripe 官网的账号，在开发者测试中拿到密钥</p></li><li><p>新建.env文件，文件名为.env，开始配置环境变量，一个是公钥，一个是密钥（密钥是敏感信息，决不能外露，不然会被随意消费）</p></li><li><p>新建.gitignore文件，把环境配置文件.env写入里面，这样代码打包的时候就不会把环境配置这个文件打包</p></li><li><p>在server.js引入.env中的公钥和密钥</p></li><li><p>把公钥通过ejs文件传给store.js文件，下面我们开始修改store.js文件上的点击支付按钮的交互</p></li><li><p>在ejs文件中引入stripe的js文件（浏览器版本）</p></li><li><p>在store.js设置stripe的处理器</p></li><li><p>在server.js中设计app.post，发出支付请求</p></li></ol><h3 id="expressJS-网络服务器框架"><a href="#expressJS-网络服务器框架" class="headerlink" title="expressJS 网络服务器框架"></a>expressJS 网络服务器框架</h3><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1 基本使用"></a>1 基本使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br><span class="hljs-comment">// respond with &quot;hello world&quot; when a GET request is made to the homepage</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>  res.send(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br>&#125;)<br>app.listen(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><p>编写完这段代码，然后在浏览器上输入localhost:3000，就可以看到页面上显示<code>hello world</code>字样。这说明我们成功搭建了一个node.js服务器。</p><p>.env</p><p><a href="https://juejin.cn/post/6844904153890684935">https://juejin.cn/post/6844904153890684935</a></p><p>.gitignore</p><p><a href="https://blog.csdn.net/beiniao520/article/details/79500647">https://blog.csdn.net/beiniao520/article/details/79500647</a></p><h4 id="过程页面的跳转恰好用的是res-render的方式，搭配上ejs模板引擎实现了页面的渲染"><a href="#过程页面的跳转恰好用的是res-render的方式，搭配上ejs模板引擎实现了页面的渲染" class="headerlink" title="过程页面的跳转恰好用的是res.render的方式，搭配上ejs模板引擎实现了页面的渲染"></a>过程页面的跳转恰好用的是res.<a href="https://so.csdn.net/so/search?q=render&spm=1001.2101.3001.7020">render</a>的方式，搭配上ejs模板引擎实现了页面的渲染</h4><h1 id="Node-Express框架中EJS模板引擎的使用"><a href="#Node-Express框架中EJS模板引擎的使用" class="headerlink" title="Node Express框架中EJS模板引擎的使用"></a>Node Express框架中EJS模板引擎的使用</h1><p><a href="https://blog.csdn.net/weixin_41162427/article/details/107864130">https://blog.csdn.net/weixin_41162427/article/details/107864130</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个node.js web服务器</title>
    <link href="/myblog.github.io/2022/04/14/%E4%B8%80%E4%B8%AAnode-js-web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/myblog.github.io/2022/04/14/%E4%B8%80%E4%B8%AAnode-js-web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-📖📖📖-Node-js文档"><a href="#1-📖📖📖-Node-js文档" class="headerlink" title="1 📖📖📖  Node.js文档"></a>1 📖📖📖  Node.js文档</h2><p>官方文档：<a href="https://nodejs.org/dist/latest-v14.x/docs/api/synopsis.html">https://nodejs.org/dist/latest-v14.x/docs/api/synopsis.html</a></p><p>官方文档对于初学者不太友好，有点难度，所以我又在网上其他文档看，比如下面这个</p><p>👇👇👇</p><p><a href="https://rualc.com/frontend/nodejs-basic/#yi-ge-jian-dan-de-li-zi">Node.js 入门指南</a></p><p><a href="https://www.runoob.com/nodejs/nodejs-http-server.html">菜鸟教程</a></p><h2 id="2-第一个node-js代码：app-js"><a href="#2-第一个node-js代码：app-js" class="headerlink" title="2 第一个node.js代码：app.js"></a>2 第一个node.js代码：app.js</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>&#123;<br>    res.write(<span class="hljs-string">&#x27;Hello Node&#x27;</span>)<br>    res.end()<br>&#125;)<br>server.listen(port,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(error)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Something went wrong&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server is listening on port&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这个代码是基本结构。写好之后，在终端输入 <code>node app.js</code>，然后在浏览器里输入<code>localhost:3000</code>即可打开。</p><ol><li><strong>引入 required 模块：</strong>我们可以使用 <strong>require</strong> 指令来载入 Node.js 模块。</li><li><strong>创建服务器：</strong>服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</li><li><strong>接收请求与响应请求</strong> 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</li></ol><h2 id="3-在node-js里引入html文件"><a href="#3-在node-js里引入html文件" class="headerlink" title="3 在node.js里引入html文件"></a>3 在node.js里引入html文件</h2><p>如果提前编写好了一个html文件，想要在web服务器打开，可以写一个app.js，然后用node.js编译。</p><p>在app.js中需要引入fs内置模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><br><span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>)</span>&#123;<br>     <span class="hljs-comment">// 发送 HTTP 头部 </span><br>    <span class="hljs-comment">// HTTP 状态值: 200 : OK</span><br>    <span class="hljs-comment">// 内容类型: text/plain</span><br>    res.writeHead(<span class="hljs-number">200</span>,&#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>:<span class="hljs-string">&#x27;text/html&#x27;</span>&#125;)<br>    fs.readFile(<span class="hljs-string">&#x27;index.html&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error,data</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(error)&#123;<br>            res.writeHead(<span class="hljs-number">404</span>)<br>            res.write(<span class="hljs-string">&#x27;Error: File not found&#x27;</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res.write(data)<br>        &#125;<br>        res.end()<br>    &#125;)<br>&#125;)<br>server.listen(port,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(error)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Something went wrong&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server is listening on port&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="3-新式的写法——使用express框架"><a href="#3-新式的写法——使用express框架" class="headerlink" title="3 新式的写法——使用express框架"></a>3 新式的写法——使用express框架</h2><p>先用npm下载express的包</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">npm install <span class="hljs-built_in">express</span> --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure><p>然后编写下面的代码就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> app = express();<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>&#125;);<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;示例应用正在监听 3000 端口!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>好了，到这你就学会了使用Node.js实现一个web服务器！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础：apply,call,bind区别</title>
    <link href="/myblog.github.io/2022/04/13/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%9Aapply,call,bind%E5%8C%BA%E5%88%AB/"/>
    <url>/myblog.github.io/2022/04/13/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%9Aapply,call,bind%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="三者的用法"><a href="#三者的用法" class="headerlink" title="三者的用法"></a>三者的用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">obj = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Joey&#x27;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">12</span>,<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printObj</span>(<span class="hljs-params">name1,name2,name3</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name,name1,name2,name3)<br>&#125;<br>printObj.call(obj,<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;Ben&#x27;</span>,<span class="hljs-string">&#x27;Jack&#x27;</span>)<br>printObj.apply(obj,[<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;Ben&#x27;</span>,<span class="hljs-string">&#x27;Jack&#x27;</span>])<br>printObj.bind(obj)(<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;Ben&#x27;</span>,<span class="hljs-string">&#x27;Jack&#x27;</span>)<br></code></pre></td></tr></table></figure><p>call, apply, bind都是函数的原型函数，任何函数都有这三个方法。</p><p>在上述代码中，call、apply和bind方法都将this指向了obj对象。</p><h2 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">fun.call(thisArg,arg1,age2,...)<br>fun.apply(thisArg,[argsArray])<br></code></pre></td></tr></table></figure><p><strong>参数</strong><br><strong>thisArg</strong> ：在fun函数运行时指定的this值。</p><p>**arg1,age2,…**： 指定的参数列表。</p><p><strong>argsArray</strong>：可选。一个数组或者类数组对象，其中的数组元素将作为单独的的参数传给fun函数。</p><p>所以call和apply的唯一区别在于第二个参数，前者是参数列表，后者是一个数组或者类数组</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>bind方法返回的是一个函数。和call相似，传入的第二个参数是一个参数列表。</p><h2 id="apply、call、bind总结"><a href="#apply、call、bind总结" class="headerlink" title="apply、call、bind总结"></a>apply、call、bind总结</h2><p>apply、call、bind 三者都是用来改变函数this对象的指向。<br> apply、call、bind 三者第一个参数都是this要指向的对象，也就是指定的上下文。<br> apply、call、bind 三者都可以利用后续参数传参。</p><p>bind是返回对应的函数，便于稍后调用。<br> apply、call 则是立即调用。</p><h2 id="面试题：-js-中如何实现-bind"><a href="#面试题：-js-中如何实现-bind" class="headerlink" title="面试题： js 中如何实现 bind"></a>面试题： js 中如何实现 bind</h2><p>问题描述：编写一个fakeBind函数，实现功能和bind一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a, b);<br>&#125;<br><br><span class="hljs-comment">//=&gt; 3, 4</span><br>f.fakeBind(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span> &#125;)(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>解决：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Function</span>.</span></span>prototype.fake<span class="hljs-constructor">Bind(<span class="hljs-params">obj</span>,<span class="hljs-operator">...</span><span class="hljs-params">args</span>)</span>&#123;<br> return<span class="hljs-function"> (...<span class="hljs-params">rest</span>)=&gt;</span>&#123;<br>  this.call(obj,...args,...rest)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="📖📖📖-参考博客"><a href="#📖📖📖-参考博客" class="headerlink" title="📖📖📖 参考博客"></a>📖📖📖 参考博客</h2><p>在网上查找资料的时候，觉得这篇<a href="">博客</a>不错，特地小抄了一下。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础：闭包浅理解</title>
    <link href="/myblog.github.io/2022/04/12/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%97%AD%E5%8C%85%E6%B5%85%E7%90%86%E8%A7%A3/"/>
    <url>/myblog.github.io/2022/04/12/JavaScript%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%97%AD%E5%8C%85%E6%B5%85%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是闭包closure"><a href="#什么是闭包closure" class="headerlink" title="什么是闭包closure"></a>什么是闭包closure</h2><p>先看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Joey&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(name)<br>&#125;<br>printName(); <span class="hljs-comment">// Joey</span><br></code></pre></td></tr></table></figure><p>这段代码最终会打印出<code>Joey</code>这个名字，这是JS语言的独特之处，就是函数内部可以读取到外部的变量。</p><p>在这段代码中，具有两个作用域<code>scope</code>，一个是整段代码处于一个作用域，另一个是function函数里面有一个作用域。函数内部可以访问到外部的变量<code>name</code>。</p><p>其实这个<code>printName</code>函数就是一个闭包。闭包就是能够访问其他函数内部变量的函数。但是这个闭包并不是我们经常说的闭包。在理解现在的闭包的概念之前，我们再看一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Joey&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">12</span>;<br>    <span class="hljs-built_in">console</span>.log(name)<br>&#125;<br><span class="hljs-built_in">console</span>.log(age) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>这段代码会报错，原因是因为在函数外部自然无法读取函数内的变量。</p><h2 id="那如何在函数外部访问到函数内部的变量呢？"><a href="#那如何在函数外部访问到函数内部的变量呢？" class="headerlink" title="那如何在函数外部访问到函数内部的变量呢？"></a>那如何在函数外部访问到函数内部的变量呢？</h2><p>在函数内部在定义一个函数，然后返回该函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Joey&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">12</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printAge</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(age)<br>    &#125;<br>    <span class="hljs-keyword">return</span> printAge;<br>&#125;<br><span class="hljs-keyword">let</span> age = printName();<br>age(); <span class="hljs-comment">// 12</span><br><br></code></pre></td></tr></table></figure><p>在这段代码中，因为函数内部可以访问到外部的变量，所以<code>printAge</code>函数可以访问到外部的<code>age</code>变量。因此，只要<code>return printAge</code>就可以在外部最外部的作用域中访问到<code>age</code>这个变量。</p><p>这段代码中<code>printAge</code>函数就是一个闭包，这也是我们现在认为的闭包。</p><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><p>闭包就是能够读取其他函数内部变量的函数，简答来讲就是，闭包就是函数内部的函数。</p><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ol><li>读取函数内部的变量</li><li>让函数内部的变量保存在内存中。函数内部的变量为局部变量，闭包的作用，就是把函数的内部的局部变量变成了全局变量。</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前端面试基础-CSS】Styled component 04</title>
    <link href="/myblog.github.io/2022/04/04/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-CSS%E3%80%91Styled-component-04/"/>
    <url>/myblog.github.io/2022/04/04/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-CSS%E3%80%91Styled-component-04/</url>
    
    <content type="html"><![CDATA[<h1 id="styled-components"><a href="#styled-components" class="headerlink" title="styled-components"></a>styled-components</h1><p>📖📖📖 <a href="https://styled-components.com/docs/basics#getting-started">官方文档</a></p><p>📖📖📖 <a href="https://curlywater.github.io/blog/f2e/css/styled-component/#%E4%BB%8B%E7%BB%8D">其他文档</a></p><p>模板字符串和CSS语法，生成的样式化组件，用来给React的组件定义样式的。</p><p>最为流行的 CSS-in-JS 方案</p>]]></content>
    
    
    <categories>
      
      <category>前端面试基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前端面试基础-CSS】CSS变量 03</title>
    <link href="/myblog.github.io/2022/03/26/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-CSS%E3%80%91CSS%E5%8F%98%E9%87%8F-03/"/>
    <url>/myblog.github.io/2022/03/26/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-CSS%E3%80%91CSS%E5%8F%98%E9%87%8F-03/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS-variable，它解决了哪些问题"><a href="#CSS-variable，它解决了哪些问题" class="headerlink" title="CSS variable，它解决了哪些问题"></a>CSS variable，它解决了哪些问题</h1><h3 id="1-减少样式重复定义"><a href="#1-减少样式重复定义" class="headerlink" title="1 减少样式重复定义"></a>1 减少样式重复定义</h3><p>比如同一个颜色值要在多个地方重复使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">:root&#123;<br>  --bgcolor: blue;<br>  --color: red;<br>&#125;<br>p &#123;<br>  color: var(--color);<br>&#125;<br>div &#123;<br>  backgroung-color: var(--bgcolor);<br>  color: var(--color)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-媒体查询"><a href="#2-媒体查询" class="headerlink" title="2 媒体查询"></a>2 媒体查询</h3><p>在媒体查询中使用，精简代码，减少冗余</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">.box &#123;<br>  --base-size: 10;<br>  width: calc(var(--base-size)* 10px);<br>  height: clac(var(--base-size)* 5px);<br>  padding:calc(var(--base-size) * 1px);<br>&#125;<br>@media screen and (min-width: 1480px) &#123;<br>  .box&#123;<br>    --base-size: 8;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-方便在-JS-中使用"><a href="#3-方便在-JS-中使用" class="headerlink" title="3 方便在 JS 中使用"></a>3 方便在 JS 中使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">// 设置变量<br>document.getElementById(&quot;box&quot;).style.setPropertyValue(&#x27;--color&#x27;, &#x27;pink&#x27;)<br>// 读取变量<br>doucment.getElementById(&#x27;box&#x27;).style.getPropertyValue(&#x27;--color&#x27;).trim()    //pink<br>// 删除变量<br>document.getElementById(&#x27;box&#x27;).style.removeProperty(&#x27;--color&#x27;)<br></code></pre></td></tr></table></figure><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4 其他"></a>4 其他</h3><ul><li>可以减少 JavaScript 对 DOM 的介入，制作性能更高的动画</li><li>配合 content 等通过 CSS 给 JS 传参，得到一些通过 JavaScript 难以获取的参数</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前端面试基础-CSS】左侧固定右侧自适应 02</title>
    <link href="/myblog.github.io/2022/03/26/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-CSS%E3%80%91%E5%B7%A6%E4%BE%A7%E5%9B%BA%E5%AE%9A%E5%8F%B3%E4%BE%A7%E8%87%AA%E9%80%82%E5%BA%94-02/"/>
    <url>/myblog.github.io/2022/03/26/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-CSS%E3%80%91%E5%B7%A6%E4%BE%A7%E5%9B%BA%E5%AE%9A%E5%8F%B3%E4%BE%A7%E8%87%AA%E9%80%82%E5%BA%94-02/</url>
    
    <content type="html"><![CDATA[<h1 id="css-如何实现左侧固定宽度-300px，右侧自适应的布局"><a href="#css-如何实现左侧固定宽度-300px，右侧自适应的布局" class="headerlink" title="css 如何实现左侧固定宽度 300px，右侧自适应的布局"></a>css 如何实现左侧固定宽度 300px，右侧自适应的布局</h1><p>初始元素如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-flex布局"><a href="#1-flex布局" class="headerlink" title="1 flex布局"></a>1 flex布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123; <br>    <span class="hljs-attribute">display</span>:flex; <br>&#125; <br><span class="hljs-selector-class">.left</span>&#123; <br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;<br>&#125; <br><span class="hljs-selector-class">.main</span>&#123; <br>    <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">300px</span>;<br>&#125;<br><span class="hljs-selector-class">.main</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.main</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Grid-布局"><a href="#2-Grid-布局" class="headerlink" title="2 Grid 布局"></a>2 Grid 布局</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">300px</span> <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-calc-方法"><a href="#3-calc-方法" class="headerlink" title="3 calc 方法"></a>3 calc 方法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">300px</span>;<br>&#125;<br><span class="hljs-selector-class">.main</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">300px</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端面试基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前端面试基础--HTML】行内元素 05</title>
    <link href="/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-05/"/>
    <url>/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-05/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaineisalsoyan </a><br>嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！哦，对了，本系列的学习来源是 <a href="https://q.shanyue.tech/fe/">山月大佬的博客</a>，他非常用心得整理了一份大厂面试题的项目，推荐大家去看看！</p><p>Have fun with the website! ♪(^∇^*)</p></blockquote><h1 id="HTML-常见的行内元素标签"><a href="#HTML-常见的行内元素标签" class="headerlink" title="HTML 常见的行内元素标签"></a>HTML 常见的行内元素标签</h1><ul><li>a</li><li>img</li><li>picture：包含零或多个 <code>source</code> 元素和一个 <code>img</code> 元素来为不同的显示/设备场景提供图像版本</li><li>span</li><li>input</li><li>textarea</li><li>select</li><li>label</li></ul><h1 id="HTML-中有哪些语义化标签"><a href="#HTML-中有哪些语义化标签" class="headerlink" title="HTML 中有哪些语义化标签"></a>HTML 中有哪些语义化标签</h1><ul><li>header</li><li>footer</li><li>main</li><li>aside</li><li>article</li><li>section</li><li>address</li><li>summary/details</li><li>menu</li><li>h1/h2/h3/h4/h5/h6</li><li>img</li><li>p</li><li>strong/italic</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前端面试基础--HTML】 实体编码 04</title>
    <link href="/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91-%E5%AE%9E%E4%BD%93%E7%BC%96%E7%A0%81-04/"/>
    <url>/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91-%E5%AE%9E%E4%BD%93%E7%BC%96%E7%A0%81-04/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaineisalsoyan </a><br>嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！哦，对了，本系列的学习来源是 <a href="https://q.shanyue.tech/fe/">山月大佬的博客</a>，他非常用心得整理了一份大厂面试题的项目，推荐大家去看看！</p><p>Have fun with the website! ♪(^∇^*)</p></blockquote><h1 id="什么是-HTML-的实体编码-HTML-Entity-Encode"><a href="#什么是-HTML-的实体编码-HTML-Entity-Encode" class="headerlink" title="什么是 HTML 的实体编码 (HTML Entity Encode)"></a>什么是 HTML 的实体编码 (HTML Entity Encode)</h1><p>一段以连字号（&amp;）开头、以分号（;）结尾的字符串。用以显示不可见字符及保留字符 (如 HTML 标签)。</p><p>例如：</p><ul><li>不可分的空格:＆nbsp;</li><li><code>&lt;</code>(小于符号):＆lt;</li><li><code>&gt;</code>(大于符号):＆gt;</li><li>＆(与符号):＆amp;</li><li>″(双引号):＆quot;</li><li>‘(单引号):’＆apos;</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前端面试基础--HTML】Data Url 03</title>
    <link href="/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91Data-Url-03/"/>
    <url>/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91Data-Url-03/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaineisalsoyan </a><br>嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！哦，对了，本系列的学习来源是 <a href="https://q.shanyue.tech/fe/">山月大佬的博客</a>，他非常用心得整理了一份大厂面试题的项目，推荐大家去看看！</p><p>Have fun with the website! ♪(^∇^*)</p></blockquote><h2 id="什么是Data-URL"><a href="#什么是Data-URL" class="headerlink" title="什么是Data URL?"></a>什么是Data URL?</h2><p>Data URL 是将图片转换为 base64 直接嵌入到了网页中，使用<code>&lt;img src=&quot;data:[MIME type];base64&quot;/&gt;</code>这种方式引用图片，不需要再发请求获取图片</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>base64 编码后的图片会比原来的体积大三分之一左右。</li><li>Data URL 形式的图片不会缓存下来，每次访问页面都要被下载一次。可以将 Data URL 写入到 CSS 文件中随着 CSS 被缓存下来。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端面试基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前端面试基础--HTML】一键复制功能 02</title>
    <link href="/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91%E4%B8%80%E9%94%AE%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD-02/"/>
    <url>/myblog.github.io/2022/03/25/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-HTML%E3%80%91%E4%B8%80%E9%94%AE%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD-02/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaineisalsoyan </a><br>嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！哦，对了，本系列的学习来源是 <a href="https://q.shanyue.tech/fe/">山月大佬的博客</a>，他非常用心得整理了一份大厂面试题的项目，推荐大家去看看！</p><p>Have fun with the website! ♪(^∇^*)</p></blockquote><h2 id="一键复制功能描述"><a href="#一键复制功能描述" class="headerlink" title="一键复制功能描述"></a>一键复制功能描述</h2><p>在一些博客网站中，可以看到代码区域的右上角会有一个复制的按钮，点击之后，可以迅速将代码框中的代码复制到剪切板上。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1Clipboard-API"><a href="#1Clipboard-API" class="headerlink" title="1Clipboard API"></a>1<code>Clipboard</code> API</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">navigator.clipboard.writeText(text);<br></code></pre></td></tr></table></figure><h3 id="2-选中-复制"><a href="#2-选中-复制" class="headerlink" title="2 选中+复制"></a>2 选中+复制</h3><p>对于不支持 <code>Clipboard API</code> 的浏览器，使用选中+复制的API进行复制。</p><ul><li><h4 id="选中-Selection-API-Range-API"><a href="#选中-Selection-API-Range-API" class="headerlink" title="选中 Selection API+Range API"></a>选中 Selection API+Range API</h4></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> selection = <span class="hljs-built_in">window</span>.getSelection();<br><span class="hljs-keyword">const</span> range = <span class="hljs-built_in">document</span>.createRange();<br><br><span class="hljs-comment">// RangeAPI: 制造区域</span><br>range.selectNodeContents(element);<br><br><span class="hljs-comment">// Selection: 选中区域</span><br>selection.addRange(range);<br><br>selectedText = selection.toString();<br></code></pre></td></tr></table></figure><ul><li><h4 id="复制-execCommand"><a href="#复制-execCommand" class="headerlink" title="复制: execCommand"></a>复制: <code>execCommand</code></h4></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.execCommand(<span class="hljs-string">&quot;copy&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端面试基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【前端面试基础——HTML】图片懒加载 01</title>
    <link href="/myblog.github.io/2022/03/24/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94HTML%E3%80%91%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD-01/"/>
    <url>/myblog.github.io/2022/03/24/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94HTML%E3%80%91%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD-01/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaineisalsoyan </a><br>嘿，我又开始新的系列学习了！😊😊😊（上一系列的学习是30 天原生js编程挑战）。这次我开始准备面试题库了，和我一起进步吧！</p><p>Have fun with the website! ♪(^∇^*)</p></blockquote><h2 id="什么是图片懒加载"><a href="#什么是图片懒加载" class="headerlink" title="什么是图片懒加载"></a>什么是图片懒加载</h2><p>浏览网页的时候，滑动页面到能看到图片的时候再加载图片。</p><p>该功能实际可以拆分成两点：</p><ol><li>判断图片出现在了当前视口（因为这个时候需要显示图片）</li><li>控制图片的加载</li></ol><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>🤔 类似功能在JS30的项目里做过。参考<a href="https://janice143.github.io/myblog.github.io/2022/01/30/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Slide-in-on-scroll-13/">【原生javascript项目】Slide in on scroll 13</a></p><p>我们现在回忆一下该项目的技术点。当时做该项目的时候，主要通过Scroll事件+位置计算实现了，另外加了函数防抖功能。其中位置计算主要包括屏幕高度（视口高度）、屏幕滚定位置、图片顶部距页面距离、图片半高、图片底部位置。</p><p>当屏幕滚动位置+屏幕高度之和 &gt; 图片顶部距页面距离+半高之和，移入图片；当屏幕滚动位置&lt;图片底部距离，移出图片。</p><ul><li>window的scroll事件<ul><li><code>window.addEventListener(&#39;scroll&#39;)</code></li></ul></li><li>一些位置（像素值）<ul><li><code>window.scrollY</code>  文档当前垂直滚动的像素数</li><li><code>window.innerHeight</code> viewport部分的高度</li><li><code>sliderImage.offsetTop</code> 当前元素顶部相对于其 offsetParent 元素的顶部的距离</li></ul></li><li><code>debounce</code> 的作用（函数防抖）<ul><li> 降低事件监听的频率，使用了 Lodash 中的 debounce 方法</li></ul></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>🔖🔖🔖  速看在这里！！！</p><table><thead><tr><th>判断图片出现在当前视口</th></tr></thead><tbody><tr><td><code>scrollY</code>, <code>offsetTop</code>,<code>innerHeight</code>+ Scroll事件</td></tr><tr><td>getBoundingClientRect API + Scroll事件</td></tr><tr><td><strong>控制图片的加载</strong></td></tr><tr><td><code>DataSet</code> API</td></tr><tr><td><strong>一步到位的方法</strong></td></tr><tr><td><code>IntersectionObserver</code> API</td></tr></tbody></table><h3 id="1-判断图片出现在当前视口"><a href="#1-判断图片出现在当前视口" class="headerlink" title="1 判断图片出现在当前视口"></a>1 判断图片出现在当前视口</h3><ul><li>位置计算 + Scroll事件</li></ul><blockquote><p>这里出现的意思可以特指能看到图片一半的高度。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> slideInAt = (<span class="hljs-built_in">window</span>.scrollY + <span class="hljs-built_in">window</span>.innerHeight);<br><span class="hljs-keyword">const</span> imageBottom = sliderImage.offsetTop + sliderImage.height;<br><span class="hljs-keyword">const</span> isHalfShown = slideInAt &gt; (sliderImage.offsetTop + sliderImage.height / <span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> isNotScrolledPast = <span class="hljs-built_in">window</span>.scrollY &lt; imageBottom;<br></code></pre></td></tr></table></figure><p>知识点：<code>scrollY</code>, <code>offsetTop</code>,<code>innerHeight</code></p><ul><li>getBoundingClientRect API + Scroll事件</li></ul><p><strong>该方法返回元素的大小及其相对于视口的位置。</strong>有<code>top</code>,<code>left</code>,<code>bottom</code>,<code>right</code>等属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">img.getBoundingClientRect().top &lt; <span class="hljs-built_in">document</span>.documentElement.clientHeight; <span class="hljs-comment">// 视口高度</span><br></code></pre></td></tr></table></figure><blockquote><p>the <code>document.documentElement</code> property gives you the <code>html</code> element, while the <code>document.body</code> property gives you the <code>body</code> element.</p></blockquote><h3 id="2-控制图片的加载"><a href="#2-控制图片的加载" class="headerlink" title="2 控制图片的加载"></a>2 控制图片的加载</h3><ul><li><code>DataSet</code> API</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;shanyue.jpg&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>首先设置一个临时 Data 属性 <code>data-src</code>，控制加载时使用 <code>src</code> 代替 <code>data-src</code>，可利用 DataSet API 实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">img.src = img.datset.src<br></code></pre></td></tr></table></figure><h3 id="3-一步到位的方法"><a href="#3-一步到位的方法" class="headerlink" title="3 一步到位的方法"></a>3 一步到位的方法</h3><ul><li><code>IntersectionObserver</code> API</li></ul><p>异步监听元素是否到了当前视口或者其他元素</p><p>一个能够监听元素是否到了当前视口的事件，一步到位</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function">(<span class="hljs-params">changes</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// changes: 目标元素集合</span><br>  changes.forEach(<span class="hljs-function">(<span class="hljs-params">change</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// intersectionRatio</span><br>    <span class="hljs-keyword">if</span> (change.isIntersecting) &#123;<br>      <span class="hljs-keyword">const</span> img = change.target;<br>      img.src = img.dataset.src;<br>      observer.unobserve(img);<br>    &#125;<br>  &#125;);<br>&#125;);<br><br>observer.observe(img);<br></code></pre></td></tr></table></figure><ul><li><code>LazyLoading</code> 属性</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;shanyue.jpg&quot;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>不过目前浏览器兼容性不太好。</p><h3 id="4-其他优化"><a href="#4-其他优化" class="headerlink" title="4 其他优化"></a>4 其他优化</h3><ul><li><code>window.scroll</code> 事件可以加<strong>防抖节流</strong>。一般使用 <code>lodash.throttle</code> 。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">_.throttle(func, [(wait = <span class="hljs-number">0</span>)], [(options = &#123;&#125;)]);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端面试基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>N 皇后问题</title>
    <link href="/myblog.github.io/2022/03/18/N-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <url>/myblog.github.io/2022/03/18/N-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>N 皇后问题是指在 n * n 的棋盘上要摆 n 个皇后。</p><p>要求：任何两个皇后不同行，不同列也不在同一条斜线上，求给一个整数 n ，返回 n 皇后的摆法数。</p><h4 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：8<br>返回值：92<br><br>输入：4<br>返回值：2<br></code></pre></td></tr></table></figure><h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><p>看懂此题解之前，需要会做 <a href="https://www.nowcoder.com/practice/4bcf3081067a4d028f95acee3ddcd2b1?tpId=295&tqId=701&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj">【BM55 没有重复项数字的全排列】</a>。</p><p>如果 BM55 已经会做了，下面开始看本题解。</p><h4 id="👇👇👇"><a href="#👇👇👇" class="headerlink" title="👇👇👇"></a>👇👇👇</h4><h4 id="大概思路"><a href="#大概思路" class="headerlink" title="大概思路"></a>大概思路</h4><ol><li><p>n 个皇后分别在 1，2,3…n 行的不同列处，列的下标用数组<code>arr</code>表示</p></li><li><p>要确定皇后的位置，其实就是确定列的位置，因为行已经固定了</p></li><li><p>进一步讲，也就是如何摆放 数组<code>arr</code>[0,1,2,3,…,n-1]</p></li><li><p>如果没有【不在同一条斜线上】要求，这题其实只是单纯的全排列问题，代码很容易些出来</p></li><li><p>但是对于【不在同一条斜线上】要求，全排列得到的<code>res</code>结果有些并不能用，比如说皇后的列位置不能这样排列：[0,1,2,3…,n-1]</p></li><li><p>所以现在问题变成了，在全排列的基础上，根据 N 皇后的问题，去除一些结果</p></li><li><p>下面开始声明一些变量</p><ul><li><p><code>arr</code> n 个皇后的列位置</p></li><li><p><code>res</code> n 皇后排列结果</p></li><li><p><code>ruler</code> 记录对应的列位置是否已经占用（也是是否有皇后），如果有，那么设为 1，没有设为 0</p></li><li><p><code>setPos</code> 哈希集合，标记正斜线（从左上到右下）位置，如果在相同正斜线上，坐标(x,y)满足 y-x 都相同</p></li><li><p><code>setCon</code> 哈希集合，标记反正斜线（从 y 右上到左下）位置，如果在相同反斜线上，坐标(x,y)满足 x+y 都相同</p><ol start="8"><li>大致的代码思路如下所示</li></ol></li></ul></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">arr = [0,1,2,3,...,n-1]<br>res = []<br>ruler = [n]<br>setPos = new Set()<br>setPos = new Set()<br><br>backtrack(路径, arr):<br>if 满足结束条件:<br>result.add(路径)<br>return<br>for 选择 in 选择列表(arr):<br>做选择<br>backtrack(路径, arr)<br>撤销选择<br>return res.length<br></code></pre></td></tr></table></figure><h4 id="一些解释"><a href="#一些解释" class="headerlink" title="一些解释"></a>一些解释</h4><p>首先，N 个皇后肯定得在不同行，不同列处（由题意 “任何两个皇后不同行，不同列” 可知）。</p><p>要实现这个方案，其实思路和 <code>BM55 全排列</code>一样。把 N 个皇后的列坐标定义成数组<code>arr = [0,1,2,...,n-1]</code>。然后全排列该数组即可，得到的排列方式<code>res</code>的长度，就是排列方案的总数。</p><p>但是 N 皇后问题，还需要满足 N 皇后不在同一条斜线上。这就更复杂了一点，需要对斜线位置进行判断。</p><p>怎么判断呢？</p><p>如果<code>setPos</code>里不包含正斜线位置，<code>setCon</code>里不包含反斜线位置，那么就是我们要的【满足结束条件】。</p><p>在回溯函数里，我们先确定第 0 排皇后的列位置，然后回溯递归，确定第 1 排的皇后的列位置。</p><p>所以每次回溯，坐标<code>(x,y)</code>其实是<code>(row,i)</code></p><h4 id="最终的代码"><a href="#最终的代码" class="headerlink" title="最终的代码"></a>最终的代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from(&#123; <span class="hljs-attr">length</span>: n &#125;, <span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> index); <span class="hljs-comment">// 列的位置</span><br><span class="hljs-keyword">let</span> res = [];<br><span class="hljs-keyword">let</span> ruler = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>); <span class="hljs-comment">//用来记录num的皇后下落后，对角线位置，如果在对角线位置，那么为1，否则0</span><br><span class="hljs-keyword">let</span> setPos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(); <span class="hljs-comment">//标记正对角线</span><br><span class="hljs-keyword">let</span> setCon = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(); <span class="hljs-comment">// 标记反对角线</span><br><br><span class="hljs-keyword">const</span> backTrace = <span class="hljs-function">(<span class="hljs-params">row, path</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (path.length === n) &#123;<br>    res.push(path.slice());<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-comment">// i表示列</span><br>    <span class="hljs-keyword">if</span> (ruler[i] == <span class="hljs-number">0</span> &amp;&amp; !setPos.has(i - row) &amp;&amp; !setCon.has(i + row)) &#123;<br>      path.push(arr[i]);<br>      ruler[i] = <span class="hljs-number">1</span>;<br>      setPos.add(i - row);<br>      setCon.add(i + row);<br>      backTrace(row + <span class="hljs-number">1</span>, path);<br>      path.pop();<br>      ruler[i] = <span class="hljs-number">0</span>;<br>      setPos.delete(i - row);<br>      setCon.delete(i + row);<br>    &#125;<br>  &#125;<br>&#125;;<br>backTrace(<span class="hljs-number">0</span>, []);<br><span class="hljs-keyword">return</span> res.length;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】JS30-总结</title>
    <link href="/myblog.github.io/2022/03/12/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91JS30-%E6%80%BB%E7%BB%93/"/>
    <url>/myblog.github.io/2022/03/12/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91JS30-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">iaineisalsoyan</a><br>简介：Atypical frond-end developer. 非典型前端开发者。</p><p>完整指南在 <a href="https://github.com/janice143/JavaScript30Program">GitHub</a>，喜欢请 Star 哦♪(^∇^*)</p><p>Have fun with the website! ♪(^∇^*)</p></blockquote><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p><a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生JS编程挑战。</p><p>项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。目的是在不借助框架、库、编译器和引用的情况下，帮助初学者理解纯JavaScript语言。</p><h2 id="项目内容"><a href="#项目内容" class="headerlink" title="项目内容"></a>项目内容</h2><ol><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/01%20pianoHit">Drum kit（架子鼓模拟器）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/02%20realTimeClock">JS and CSS Clock （网页时钟）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/03%20imageProcessionwithJS">CSS Variables （CSS变量）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/04%20arrayOperation">Array Cardio Day1 （数组操作1）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/05%20flexPanel">Flex Panel Gallery （Flex画廊面板）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/06%20AjaxTypeAhead">Type Ahead （异步输出）</a></li><li>Array Cardio Day2 （数组操作2）</li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/08%20canvas">Fun with HTML5 Canvas（有趣的HTML5画布）</a></li><li>Dev Tools Domination （）</li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/10%20goList">Hold Shift and Check Checkboxes （计划清单）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/11%20videoPlayer">Custom Video Player （自定义视频播放器）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/12%20secretCode">Key Sequence Detection （字符串序列彩蛋检测）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/13%20slideinonScroll">Slide in on Scroll （滚动鼠标滚轮滑动显示）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/14%20JSreferenceVScopy">JavaScript References VS Copying （引用与拷贝）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/15%20localStorage">Local Storage （本地存储）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/16%20mouseMoveShadow">Mouse Move Shadow （随鼠标移动的文字阴影）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/17%20sortWithoutArticles">Sort with Articles （去掉冠词排列）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/18%20timeWithReduce">Adding up Times with Reduce （用Reduce实现时间累加器）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/19%20webCamFun">Webcam Fun （有趣的网络摄像头）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/20%20speechDetection">Speech Detection （语音识别）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/21%20geoLocation">Geolocation （地理位置信息获取）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/22%20linkHighlighter">Follow along Link Highlighter （链接高亮显示）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/23%20speechSynthesis">Speech Synthesis （语音合成）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/24%20stickyNav">Sticky Nav （固定的导航栏）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/25%20eventCapture">Event Capture, Propagation, Bubbling and Once（事件捕捉，传播，冒泡与Once方法）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/26%20stripAlongNav">Stripe Follow along Nav （导航栏跟随移动显示特效）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/27%20clickAndDrag">Click and Drag （点击并拖拽）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/28%20VideoSpeedController">Video Speed Controller （视频速度控制器）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/29%20CountdownTimer">Countdown Timer （倒计时计时器）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/30%20WhackAMole">Whack A Mole（打地鼠小游戏）</a></li></ol><h2 id="用VUE实现的JS30"><a href="#用VUE实现的JS30" class="headerlink" title="用VUE实现的JS30"></a>用VUE实现的JS30</h2><p><em><strong>查看index-VUE.html文件</strong></em></p><ol><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/01%20pianoHit">Drum kit（架子鼓模拟器）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/02%20realTimeClock">JS and CSS Clock （网页时钟）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/03%20imageProcessionwithJS">CSS Variables （CSS变量）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/05%20flexPanel">Flex Panel Gallery （Flex画廊面板）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/06%20AjaxTypeAhead">Type Ahead （异步输出）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/08%20canvas">Fun with HTML5 Canvas（有趣的HTML5画布）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/10%20goList">Hold Shift and Check Checkboxes （计划清单）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/11%20videoPlayer">Custom Video Player （自定义视频播放器）</a></li><li><a href="https://github.com/janice143/JavaScript30Program/tree/master/30%20WhackAMole">Whack A Mole（打地鼠小游戏）</a></li></ol><h2 id="社区内容-JavaScript30"><a href="#社区内容-JavaScript30" class="headerlink" title="社区内容#JavaScript30"></a>社区内容#JavaScript30</h2><p>Feel free to submit a PR adding a link to your own recaps, guides or reviews!</p><ul><li><a href="http://thesagittariusme.blogspot.com/search/label/JS30">Arjun Khode’s blog</a> about summaries for each day, including fixed glitches, bugs and extra features</li><li><a href="https://github.com/nitishdayal/JavaScript30">Nitish Dayal’s Text Guides</a> are great for those who like reading over watching</li><li><a href="http://meredithunderell.com/tag/javascript30/">Meredith Underell’s</a> Quick Lessons Learned</li><li><a href="http://rowanweismiller.com/blog/javascript-30/">Rowan Weismiller’s</a> Recaps + Lessons Learned</li><li><a href="https://tfrommen.de/tag/javascript-30/">Thorsten Frommen</a> shares how he solved the exercises before viewing the answers</li><li><a href="https://github.com/soyaine/JavaScript30">Soyaine 写的中文指南</a>包含了过程记录和难点解释</li><li><a href="https://freshman.tech/archive/#javascript30">Ayo Isaiah’s</a> Recaps and Lessons Learned</li><li><a href="https://stpcollabr8nlstn.github.io/JavaScript30/">Adriana Rios</a> shares her alternative solutions</li><li><a href="http://30daysofjs.michaeleinsohn.com/">Michael Einsohn</a> publishes each challenge after watching the video once</li><li><a href="https://medium.com/@mike_ekkel/javascript-30-a-30-day-vanilla-js-challenge-6a733fc9f62c#.9frjtaje9">Mike Ekkel</a></li><li><a href="https://github.com/yhabib/JavaScript30">Yusef Habib</a> lessons and tricks learned, and a <a href="https://yhabib.github.io/JavaScript30/">gh-page</a> to see working all the mini-projects.</li><li><a href="https://github.com/amelieyeh/JS30">Amelie Yeh</a> 30 lessons notes with things I’ve learned, and those important recaps. and directly view my demos <a href="https://amelieyeh.github.io/JS30/">here</a> 🇹🇼😄</li><li><a href="https://github.com/winar-jin/JavaScript30-Challenge">Winar</a>的JavaScript30天挑战，记录练习过程，重难点和其他的解决方案。🎨</li><li><a href="https://rayhatron.github.io/blog/">Rayhatron</a> - walkthroughs, recaps and lessons learned.</li><li><a href="https://github.com/andreidbr/JS30">Andrei Dobra</a> Full repo with lessons learned and a <a href="https://andreidbr.github.io/JS30/">gh-page</a> with all the exercises.</li><li><a href="https://github.com/liyuechun/JavaScript30-liyuechun">从零到壹全栈部落</a>,春哥发起的从零到壹全栈部落，旨在带领大家一起学习，一起输出，文档化，代码化，中文视频化，全栈部落口号：输出是最好的学习方式。</li><li><a href="https://github.com/usyyy/javascript/blob/master/JavaScript30/analysis.md">Usmaan Ali’s</a> summary of the technical skills learned from each project. He’s also posting them as separate blog posts <a href="https://medium.com/@usyyy">here</a></li><li><a href="https://github.com/afuh/js30">Axel</a>‘s lessons learned and a <a href="https://afuh.github.io/js30/">showcase</a> with the projects.</li><li><a href="https://github.com/dwatow/JavaScript30">Chris</a> 中文實戰，目標描述、過程紀錄。</li><li><a href="https://miayam.github.io/">Muhammad D. Ramadhan’s</a> blog. He shamlesly mixed his personal life with 30 day JavaScript challenge so as to increase his learning retention. He also summarised the challenge on <a href="https://miayam.github.io/js30">one single page</a>. Do not read his blog!</li><li><a href="https://blog.keitel.xyz/categories/javascript30/">Lee Keitel’s Blog</a> includes summaries of each lesson, what I learned from each one, and my thoughts about the topic taught and using them in the future.</li><li><a href="https://github.com/dustinhsiao21/Javascript30-dustin">Dustin Hsiao</a> 包含了各篇介紹、 效果Demo、各篇詳解及記錄過程，附上部分延伸閱讀及<a href="https://dustinhsiao21.github.io/Javascript30-dustin/">gh-page</a>。</li><li><a href="https://github.com/guahsu/JavaScript30">GuaHsu</a> - 紀錄各篇練習過程與心得，並嘗試擴充部分練習，也做了一個包含全部練習的<a href="http://guahsu.io/JavaScript30/">介紹站</a>🇹🇼</li><li><a href="https://github.com/misslild">Daniela</a>‘s completed challenges on <a href="https://misslild.github.io/WesBos-30day-Coding-challenge/">GitHub Pages</a> and <a href="https://codepen.io/collection/DapZeP/">Codepen</a> :raised_hands: :muscle: :+1:</li><li><a href="https://github.com/guar47">Dmitrii Pashutskii’s</a> code of all challenges on <a href="https://github.com/guar47/javascript30Summary">GitHub with Pages</a> and review <a href="https://blog.dpashutskii.com/tag/javascript30/">blog posts</a></li><li><a href="https://github.com/sabidhasan/javascript-30">Abid Hasan’s</a> completion of all challenges. This was awesome!! Learned so much! :+1:</li><li><a href="https://sky172839465.github.io/course/js30">Yusong Notes</a> Records Yusong JS 30 days note and demo :star2:</li><li><a href="https://github.com/Ding-Fan/javascript30">Ding’s Implementation</a> code and online demo</li><li><a href="https://github.com/herminiotorres/JavaScript30">Herminio Torres</a> lessons and tricks learned, and a <a href="https://herminiotorres.github.io/JavaScript30/">gh-page</a> to see working all the mini-projects.</li><li><a href="https://github.com/dimabory">Dmytro Borysovskyi</a> says many thanks to for the course to Wes 🤝 It was incredible challenge 👌 The full repository with code available <a href="https://github.com/dimabory/dimabory.github.io/tree/gh-pages/src/components/JavaScript30Days">here</a> and demos can be reached by the link to <a href="https://dimabory.github.io/#/js30days">gh-pages</a> 👍👍👍 </li><li><a href="https://github.com/akhilome/">Kizito</a>‘s follow along <a href="https://github.com/akhilome/js30">repo</a> with <a href="https://akhilome.github.io/js30">completed challenges</a> and <a href="https://akhilome.github.io/js30/notes">notes</a>.</li><li><a href="https://github.com/vanntile">VannTile</a>‘s <a href="https://github.com/vanntile/JavaScript30">repository</a> and <a href="https://vanntile.github.io/JavaScript30/">GitHub Pages showcase</a>. Thank you for a great ⌨️ experience.</li><li><a href="https://github.com/Alex-K1m/js30-challenge">Alex Kim</a> completed all the challenges. You can check them out at <a href="https://alex-k1m.github.io/js30-challenge/">github pages</a>.</li><li><a href="https://github.com/seckela">Mikhail Thomas</a> created <a href="https://github.com/seckela/js30plusplus">JS30++</a> to add another level of challenge ontop of this already great course.</li><li><a href="https://github.com/reymon359/JavaScript30">Ramon Morcillo</a> finished this awesome challenge!. You can see the showcase of his implementations on <a href="https://reymon359.github.io/JavaScript30/">this link</a>.</li><li><a href="https://github.com/sescobar99">Santiago Escobar</a>‘s <a href="https://github.com/sescobar99/javascript30-challenge">repository</a> and <a href="https://sescobar99.github.io/javascript30-challenge/">GitHub Pages showcase</a>.</li><li><a href="https://github.com/a90100/JavaScript30">Harry Xie</a> 紀錄 30 天的練習筆記在 <a href="https://github.com/a90100/JavaScript30">此連結</a>.</li><li><a href="https://vanribeiro-30daysofjavascript.netlify.app/"> Van Ribeiro’s </a> about demos and recaps. On <a href="https://github.com/vanribeiro/30days-Of-JavaScript">GitHub Repo</a> there’s a summary about what was learned and researched.</li><li><a href="https://github.com/Mugilan-Codes">Mugilan</a> is currently doing this challenge. Check out his <a href="https://github.com/Mugilan-Codes/javascript-30">Repo</a> and the <a href="https://mugilan-codes.github.io/javascript-30/">Live Demo</a>.</li><li><a href="https://github.com/eshanvohra">Eshan Vohra</a> is currently doing this challenge. Check out my repo <a href="https://github.com/eshanvohra/JavaScript30">here</a>.</li><li><a href="https://github.com/RegusAl">RegusAl</a> is currently doing this challenge. Check out my repo <a href="https://github.com/RegusAl/JavaScript30">here</a>.</li><li><a href="https://javascript30.ayushgupta.tech/">Ayush Gupta’s</a> implementation of JavaScript30 challenge with some add-ons &amp; updated design.</li><li><a href="https://github.com/filipkowal/JS30-05-Flex-Panels-Deactivate">filipkowal</a> Fix to flex panels (5th  day) so the panels deactivate when clicked on another one.</li><li><a href="https://github.com/MoSaif00">Mo. Saif’s</a>note on lessons learned and a <a href="https://mosaif00.github.io/30-Days-JavaScript-Challenge/">gh-pages showcase</a> for the projects.</li><li><a href="https://stiaannel.co.za/my-projects/javascript30">Stiaannel’s</a> implementation of the Javascript30 challenge, with small design changes and a couple of extra features.</li></ul><h2 id="其他方法实现的JS30"><a href="#其他方法实现的JS30" class="headerlink" title="其他方法实现的JS30"></a>其他方法实现的JS30</h2><p>Here are some links of people who have done the tutorials, but in a different language or framework:</p><ul><li><a href="https://github.com/tkjone/clojurescript-30">Thomas Mattacchione</a> JavaScript 30 written in ClojureScript</li><li><a href="https://github.com/davefollett">Dave Follett’s</a> blog series, <a href="https://davefollett.io/categories/a-new-vue-on-javascript30/">A New Vue on #JavaScript30</a>, where he explores re-implementing #JavaScript30 projects using <a href="https://vuejs.org/">Vue</a>.</li><li><a href="https://github.com/akinjide/JS30days">Akinjide Bankole</a> used Node.js with <a href="http://jadelang.net/">Jade</a> to solve the exercises</li><li><a href="https://github.com/adrienpoly/javascript30-stimulus">Adrien Poly</a> a modest attempt to convert Drum Kit, Video Player, Local Tapas, TypeHead to <a href="https://stimulusjs.org/">Stimulus JS</a> framework in a Rails App.</li><li><a href="https://github.com/tricinel/TypeScript30">Bogdan Lazar</a> all the JavaScript 30 written in <a href="https://www.typescriptlang.org/">TypeScript</a></li><li><a href="https://github.com/wwags33/JavaScript30">Will Wager</a> another <a href="https://www.typescriptlang.org/">TypeScript</a> implementation!</li><li><a href="https://github.com/marcoSven">marcoSven</a> solution suggestion for <a href="https://github.com/marcoSven/JavaScript30/blob/master/10%20-%20Hold%20Shift%20and%20Check%20Checkboxes/index-FINISHED.html">10 - Hold Shift and Check Checkboxes</a></li><li><a href="https://github.com/almaclaine">ALMaclaine</a> Javascript 30 written in <a href="https://github.com/ALMaclaine/Dart30">Dart 2.0</a>.</li></ul>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS30;30个原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Whack A Mole 30</title>
    <link href="/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Whack-A-Mole-30/"/>
    <url>/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Whack-A-Mole-30/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Countdown Timer 29</title>
    <link href="/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Countdown-Timer-29/"/>
    <url>/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Countdown-Timer-29/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第28天的“倒计时计时器”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/29%20CountdownTimer/index.htm">https://github.com/janice143/JavaScript30Program/tree/master/29%20CountdownTimer/index.htm</a></p><p>**本项目的笔记内容选自 <a href="https://github.com/dashnowords">大史不说话</a>**，他本人是JS30社区里的知名参与者，他的全部笔记在<a href="https://github.com/soyaine/JavaScript30">这里</a>。</p><p>本项目的笔记在<a href="https://github.com/soyaine/JavaScript30/tree/master/29%20-%20Countdown%20Timer">这里</a>。</p><h2 id="挑战任务"><a href="#挑战任务" class="headerlink" title="挑战任务"></a>挑战任务</h2><p>初始文档<code>index-start.html</code>中提供了一个倒计时控制器，从<code>html</code>文档的结构可以看出，顶部的按钮可以用来增加倒计时时间，常用的时间间隔已将参数绑定在<code>data-time</code>属性上;<code>display</code>类用来显示计时的结果。<br>本次编程挑战的任务是通过javascript代码基于当前时间生成一个倒计时，将<code>结束时间</code>和<code>剩余时间</code>分别显示在<code>diaplay__time-left</code>类标签和<code>display__end-time</code>类标签上。</p><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>[<img src="https://github.com/soyaine/JavaScript30/raw/master/29%20-%20Countdown%20Timer/effect.png" alt="结果展示">](<a href="https://github.com/soyaine/JavaScript30/blob/master/29">https://github.com/soyaine/JavaScript30/blob/master/29</a> - Countdown Timer/effect.png)</p><h2 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h2><p>监听按点击事件<code>click</code>来为倒计时增加时间，使用<code>setInterval</code>函数每秒执行判断函数，若倒计时事件到，则清除当前计时器，若时间未到，则计算并刷新页面上应该显示的时间。</p><h2 id="过程指南"><a href="#过程指南" class="headerlink" title="过程指南"></a>过程指南</h2><p>1.定义变量及获取需要操作的DOM元素的引用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> endTime  = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.display__end-time&quot;</span>);<br><span class="hljs-keyword">const</span> leftTime = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&quot;.display__time-left&quot;</span>);<br><span class="hljs-keyword">const</span> buttons = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelectorAll</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><span class="hljs-keyword">const</span> date = <span class="hljs-keyword">new</span> Date();<br><span class="hljs-keyword">var</span> left = <span class="hljs-number">0</span>;<span class="hljs-comment">//剩余时间</span><br><span class="hljs-keyword">var</span> end = <span class="hljs-number">0</span>;<span class="hljs-comment">//结束时间</span><br><span class="hljs-keyword">var</span> timer;<span class="hljs-comment">//interval计时器</span><br>leftTime.innerHTML = left;<span class="hljs-comment">//未操作时，剩余时间显示0</span><br></code></pre></td></tr></table></figure><p>2.为button绑定点击事件，当按钮点击时执行对应的回调函数。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(buttons);<br>arr.<span class="hljs-keyword">map</span>(<span class="hljs-keyword">function</span>(item)&#123;<br>    item.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,clickAction);<br>&#125;);<br></code></pre></td></tr></table></figure><p>3.监听表单的提交事件,注意表单的调用方式。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">document.customForm.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">submit</span>&#x27;,<span class="hljs-params">function</span>(<span class="hljs-params">e</span>)</span>&#123;<br>e.prevent<span class="hljs-constructor">Default()</span>;<br>update<span class="hljs-constructor">Time(<span class="hljs-params">this</span>.<span class="hljs-params">minutes</span>.<span class="hljs-params">value</span><span class="hljs-operator">*</span>60)</span>;<br>update<span class="hljs-constructor">Timer()</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>4.点击后的回调函数中取得点击按钮传递的秒数，调用<code>updateTime()</code>函数更新页面显示结果，并调用<code>updateTimer()</code>来更新计时器相关动作.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> click<span class="hljs-constructor">Action(<span class="hljs-params">e</span>)</span>&#123;<br><span class="hljs-keyword">let</span> deltaTime;<br>   deltaTime = this.dataset.time;<span class="hljs-comment">//取得data-time属性的值</span><br>   update<span class="hljs-constructor">Time(<span class="hljs-params">deltaTime</span>)</span>;<br><br>        <span class="hljs-comment">//点击后更新计时器</span><br>        update<span class="hljs-constructor">Timer()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.<code>updateTime()</code>函数用来更新和页面相关的显示信息。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-keyword">function</span> update<span class="hljs-constructor">Time(<span class="hljs-params">delta</span>)</span>&#123;<br>    left = left + parse<span class="hljs-constructor">Int(<span class="hljs-params">delta</span>,0)</span>;<br>        <span class="hljs-keyword">end</span> = date.get<span class="hljs-constructor">Time()</span> + left*<span class="hljs-number">1000</span>;<br>        leftTime.innerHTML = left;<br>        endTime.innerHTML =<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date(<span class="hljs-params">end</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleTimeString()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>6.<code>updateTimer()</code>函数用来执行和设定每秒检查计时器是否需要继续工作的逻辑判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTimer</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-comment">//清除以前的timer,如果不清除，新生成的定时器会和以前的定时器叠加在一起，均会生效。</span><br><span class="hljs-keyword">if</span>(timer)&#123;<br><span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;<br><br>    <span class="hljs-comment">// 设置新的Timer</span><br>    timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span>)&#123;<br>endTime.innerHTML = <span class="hljs-string">&#x27;End&#x27;</span>;<br>        <span class="hljs-built_in">clearInterval</span>(timer);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>left -= <span class="hljs-number">1</span>;<br>leftTime.innerHTML = left;<br>&#125;<br>&#125;,<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="延伸思考"><a href="#延伸思考" class="headerlink" title="延伸思考"></a>延伸思考</h2><p>本次代码中前后会定义定时器和清除定时器，另一种做法是定时器一直工作不清除，对应的按钮和表单只修改时间，不用调整定时器，当值发生变化后，下一秒定时器检测时就会开始倒计时，这样代码逻辑上会有所简化，感兴趣的朋友可以自行练习。</p><blockquote><p>JS30的第29个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#56;&#48;&#51;&#x31;&#48;&#53;&#53;&#x33;&#x38;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#x31;&#56;&#48;&#51;&#x31;&#48;&#53;&#53;&#x33;&#x38;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Video Speed Controller 28</title>
    <link href="/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Video-Speed-Controller-28/"/>
    <url>/myblog.github.io/2022/03/11/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Video-Speed-Controller-28/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第27天的“视频播放速度控制器”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/28%20VideoSpeedController/index.htm">https://github.com/janice143/JavaScript30Program/tree/master/28%20VideoSpeedController/index.htm</a></p><p>**本项目的笔记内容选自 <a href="https://github.com/dashnowords">大史不说话</a>**，他本人是JS30社区里的知名参与者，他的全部笔记在<a href="https://github.com/soyaine/JavaScript30">这里</a>。</p><p>本项目的笔记在<a href="https://github.com/soyaine/JavaScript30/tree/master/28%20-%20Video%20Speed%20Controller">这里</a>。</p><h2 id="挑战任务"><a href="#挑战任务" class="headerlink" title="挑战任务"></a>挑战任务</h2><p>初始文档<code>index-start.html</code>中提供了一个视频播放区域（使用的是H5原生的控制器）以及一个表示播放速度的滑块区域，本次的编程任务需要实现的效果是当鼠标拖动滑块时，实时改变视频播放的速度。</p><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>[<img src="https://github.com/soyaine/JavaScript30/raw/master/28%20-%20Video%20Speed%20Controller/effect.png" alt="结果展示">](<a href="https://github.com/soyaine/JavaScript30/blob/master/28">https://github.com/soyaine/JavaScript30/blob/master/28</a> - Video Speed Controller/effect.png)</p><h2 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h2><p>本次的编程任务难度系数较低，在右侧速度条上监听鼠标点击事件，调整滑块的高度来表示不同的填充百分比，即不同的播放速度，将速度赋值给video对象的<code>playbackRate</code>属性即可实时改变播放速度。难点在于高度的百分比转换。</p><h2 id="过程指南"><a href="#过程指南" class="headerlink" title="过程指南"></a>过程指南</h2><p>本篇实现较为简单，不再分步骤讲解，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> speed = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.speed&quot;</span>);<br><span class="hljs-keyword">const</span> speedBar = speed.querySelector(<span class="hljs-string">&quot;.speed-bar&quot;</span>);<br><span class="hljs-keyword">const</span> video = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.flex&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeSpeed</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> height = e.offsetY;<span class="hljs-comment">//获取滑块的高度</span><br>  <span class="hljs-keyword">const</span> percentage = e.offsetY / speed.offsetHeight;<br>  <span class="hljs-keyword">const</span> min = <span class="hljs-number">0.5</span>;<br>  <span class="hljs-keyword">const</span> max = <span class="hljs-number">5</span>;<br>  <span class="hljs-comment">//依据自定义播放速度范围和滑块高度百分比确定播放速率</span><br>  <span class="hljs-keyword">const</span> playbackRate = percentage * (max - min) + min; <br>  speedBar.style.height = <span class="hljs-built_in">Math</span>.round(percentage*<span class="hljs-number">100</span>) + <span class="hljs-string">&#x27;%&#x27;</span>;<br>  speedBar.textContent = playbackRate.toFixed(<span class="hljs-number">2</span>) + <span class="hljs-string">&#x27;×&#x27;</span>;<br>  video.playbackRate = playbackRate;<br>&#125;<br><br>speed.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,changeSpeed);<br></code></pre></td></tr></table></figure><blockquote><p>JS30的第28个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#49;&#56;&#48;&#x33;&#x31;&#48;&#53;&#x35;&#51;&#56;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#49;&#56;&#48;&#x33;&#x31;&#48;&#53;&#x35;&#51;&#56;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Click and drag 27</title>
    <link href="/myblog.github.io/2022/03/05/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Click-and-drag-27/"/>
    <url>/myblog.github.io/2022/03/05/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Click-and-drag-27/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第26天的“内容悬浮显示”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/27%20clickAndDrag/index.html">https://github.com/janice143/JavaScript30Program/tree/master/27%20clickAndDrag/index.html</a></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目为一个横向条幅，实现的特效是鼠标点击实现横向拖拽。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><code>e.pageX </code></li><li><code>.scrollLeft</code></li><li><code>.offsetLeft</code></li><li> <code>e.preventDefault()</code></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><p>编程思路为</p><ol><li>监听最外层items元素的<code>mousedown</code>事件，触发后添加<code>active</code>类名，此类名具有一定的CSS特效。记录此时的起点<code>startX</code> 以及 左边滚动的位置<code>scrollLeft</code>。</li><li>监听鼠标移动<code>mousemove</code>事件，给<code>scrollLeft</code>赋值，即可调整元素在水平方向滚动的位置。</li><li>鼠标离开<code>mouseleave</code>和不点击<code>mouseup</code>事件触发时，去掉<code>active</code>类名。</li></ol><ul><li><p><code>mousedown</code>事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">slider.addEventListener(<span class="hljs-string">&#x27;mousedown&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>isDown = <span class="hljs-literal">true</span>;<br>slider.classList.add(<span class="hljs-string">&#x27;active&#x27;</span>);<br>startX = e.pageX - slider.offsetLeft;<br>scrollLeft = slider.scrollLeft;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><code>mousemove</code>事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>slider.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (!isDown) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// stop the fn from running</span><br>e.preventDefault();<br><span class="hljs-keyword">const</span> x = e.pageX - slider.offsetLeft;<br><span class="hljs-keyword">const</span> walk = (x - startX) * <span class="hljs-number">3</span>;<br>slider.scrollLeft = scrollLeft - walk;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><code>mouseleave</code>和不点击<code>mouseup</code>事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">slider.addEventListener(<span class="hljs-string">&#x27;mouseleave&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>isDown = <span class="hljs-literal">false</span>;<br>slider.classList.remove(<span class="hljs-string">&#x27;active&#x27;</span>);<br>&#125;);<br><br>slider.addEventListener(<span class="hljs-string">&#x27;mouseup&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>isDown = <span class="hljs-literal">false</span>;<br>slider.classList.remove(<span class="hljs-string">&#x27;active&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="一些CSS样式"><a href="#一些CSS样式" class="headerlink" title="一些CSS样式"></a>一些CSS样式</h4><ol><li><p><code>overflow</code>属性：控制元素溢出时的特性，主要有一下几个值</p><ul><li><code>visible</code> 默认值，溢出也是可见的，没有被裁剪</li><li><code>hidden</code> 溢出的内容被裁剪，并且看不到</li><li><code>scroll </code>溢出的内容被裁剪，但是可以添加滑块scrollbar看到溢出内容</li><li><code>auto</code> 有点像<code>scroll</code></li></ul></li><li><p><code>white-space</code>空格处理</p><ul><li><code>normal</code>表示合并空格，多个相邻空格合并成一个空格</li><li><code>nowrap</code>不换行，经常和<code>overflow</code>,<code>text-overflow</code>一起使用</li><li><code>pre</code>保留空格不换行，有几个空格算几个空格显示</li><li><code>pre-wrap</code>的作用是保留空格</li></ul></li><li><p>user-select：禁止用户用鼠标在页面上选中文字、图片等，也就是，让页面内容不可选</p></li></ol><blockquote><p>JS30的第27个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#49;&#x38;&#48;&#x33;&#x31;&#x30;&#53;&#x35;&#x33;&#x38;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#49;&#x38;&#48;&#x33;&#x31;&#x30;&#53;&#x35;&#x33;&#x38;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Strip follow along nav 26</title>
    <link href="/myblog.github.io/2022/02/27/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Strip-follow-along-nav-26/"/>
    <url>/myblog.github.io/2022/02/27/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Strip-follow-along-nav-26/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第26天的“内容悬浮显示”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/26%20stripAlongNav/index.html">https://github.com/janice143/JavaScript30Program/tree/master/26%20stripAlongNav/index.html</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_stripAlongNav.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目的网页主题是一个菜单栏，通过鼠标<code>mouseenter</code>进入每个菜单项目时，会显示出相应的隐藏扩展内容，当从一个菜单进入另一个菜单时，扩展内容的显示会有一个从上一个菜单平移到当前菜单的动态效果。</p><p>本项目的难点在于适应大小的动态显示和平移效果。由于扩展内容包含的类型各不相同，而且显示要有一个从上一个菜单平移到当前菜单的动态效果，要做到用通用化的操作，根据扩展内容的具体大小动态显示出，是一件值得思考的事情。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><code>getBoundingClientRect()</code></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><ul><li><p>第一个菜单及其扩展内容</p><p>包含<code>a</code>标签标记的标题；类名为<code>dropdown,dropdown1</code>的下拉菜单（一张图片和描述文本）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>About Me<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown dropdown1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bio&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://logo.clearbit.com/wesbos.com&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Wes Bos sure does love web development. He teaches things like JavaScript, CSS and BBQ. Wait. BBQ isn&#x27;t part of web development. It should be though!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>第二个菜单及其扩展内容</p><p>包含<code>a</code>标签标记的标题；类名为<code>dropdown,dropdown2</code>的下拉菜单（类型相同的列表）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Courses<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown courses&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>RFB<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://ReactForBeginners.com&quot;</span>&gt;</span>React For Beginners<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>ES6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://ES6.io&quot;</span>&gt;</span>ES6 For Everyone<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>NODE<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://LearnNode.com&quot;</span>&gt;</span>Learn Node<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>STPU<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://SublimeTextBook.com&quot;</span>&gt;</span>Sublime Text Power User<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>WTF<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://Flexbox.io&quot;</span>&gt;</span>What The Flexbox?!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>GRID<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://CSSGrid.io&quot;</span>&gt;</span>CSS Grid<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>LRX<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://LearnRedux.com&quot;</span>&gt;</span>Learn Redux<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>CLPU<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://CommandLinePowerUser.com&quot;</span>&gt;</span>Command Line Power User<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>MMD<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://MasteringMarkdown.com&quot;</span>&gt;</span>Mastering Markdown<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>第三个菜单及其扩展内容</p><p>包含<code>a</code>标签标记的标题；类名为<code>dropdown,dropdown3</code>的下拉菜单（类型相同的列表）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>Other Links<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdown dropdown3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://twitter.com/wesbos&quot;</span>&gt;</span>Twitter<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://facebook.com/wesbos.developer&quot;</span>&gt;</span>Facebook<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://wesbos.com&quot;</span>&gt;</span>Blog<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://wesbos.com/courses&quot;</span>&gt;</span>Course Catalog<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>白背景</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dropdownBackground&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;arrow&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h4><ul><li><p><code>trigger-enter</code>类名。效果是显示下拉菜单，但是此时下拉菜单的不透明度还是为0，所以还是看不到下拉菜单</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.trigger-enter</span> <span class="hljs-selector-class">.dropdown</span> &#123;<br>    <span class="hljs-attribute">display</span>: block;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>trigger-enter-active</code>类名。效果是将下拉菜单的不透明度设置为1</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.trigger-enter-active</span> <span class="hljs-selector-class">.dropdown</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>dropBackgorund</code>类名。设置背景图片的样式，<u>也是本项目难点的实现机制，通过移动背景白版，来实现一个动态平移的过程。</u></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.dropdownBackground</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">50px</span> <span class="hljs-number">100px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">93</span>,.<span class="hljs-number">1</span>), <span class="hljs-number">0</span> <span class="hljs-number">15px</span> <span class="hljs-number">35px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">93</span>,.<span class="hljs-number">15</span>), <span class="hljs-number">0</span> <span class="hljs-number">5px</span> <span class="hljs-number">15px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,.<span class="hljs-number">1</span>);<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span>, opacity <span class="hljs-number">0.1s</span>, transform <span class="hljs-number">0.2s</span>;<br>    <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">50%</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>open</code>类名。将背景图片的不透明度设置为1</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.dropdownBackground</span><span class="hljs-selector-class">.open</span> &#123;<br><span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><ul><li><p>鼠标进入导航栏项目时。</p><ul><li>给对应的项目添加类名<code>trigger-enter</code>，随后150ms，添加类名<code>trigger-enter-active</code>。</li><li>白背景也要同时显示，所以添加类名<code>open</code></li><li>利用<code>getBoundingClientRect()</code>属性获取元素的宽高和位置信息。<u>这是本项目的难点的实现机制，根据下拉菜单大小动态显示。</u></li><li>白背景的显示位置是相对于已定位的<code>nav</code>元素，所以其<code>top</code>位置是下拉菜单的<code>top</code>位置减去<code>nav</code>的<code>top</code>位置。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> triggers = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.cool &gt; li&#x27;</span>);<br><span class="hljs-keyword">const</span> background  = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.dropdownBackground&#x27;</span>);<br><span class="hljs-keyword">const</span> nav  = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.top&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEnter</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.classList.add(<span class="hljs-string">&#x27;trigger-enter&#x27;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.classList.contains(<span class="hljs-string">&#x27;trigger-enter&#x27;</span>) &amp;&amp; <span class="hljs-built_in">this</span>.classList.add(<span class="hljs-string">&#x27;trigger-enter-active&#x27;</span>), <span class="hljs-number">150</span>);<br>    background.classList.add(<span class="hljs-string">&#x27;open&#x27;</span>);<br><br>    <span class="hljs-keyword">const</span> dropdown = <span class="hljs-built_in">this</span>.querySelector(<span class="hljs-string">&#x27;.dropdown&#x27;</span>);<br>    <span class="hljs-keyword">const</span> dropdownCoords = dropdown.getBoundingClientRect();<br>    <span class="hljs-keyword">const</span> navCoords = nav.getBoundingClientRect();<br><br>    <span class="hljs-keyword">const</span> coords = &#123;<br>        <span class="hljs-attr">height</span>: dropdownCoords.height,<br>        <span class="hljs-attr">width</span>: dropdownCoords.width,<br>        <span class="hljs-attr">top</span>: dropdownCoords.top - navCoords.top,<br>        <span class="hljs-attr">left</span>: dropdownCoords.left - navCoords.left<br>    &#125;;<br><br>    background.style.setProperty(<span class="hljs-string">&#x27;width&#x27;</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;coords.width&#125;</span>px`</span>);<br>    background.style.setProperty(<span class="hljs-string">&#x27;height&#x27;</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;coords.height&#125;</span>px`</span>);<br>    background.style.setProperty(<span class="hljs-string">&#x27;transform&#x27;</span>, <span class="hljs-string">`translate(<span class="hljs-subst">$&#123;coords.left&#125;</span>px, <span class="hljs-subst">$&#123;coords.top&#125;</span>px)`</span>);<br>&#125;<br>triggers.forEach(<span class="hljs-function"><span class="hljs-params">trigger</span> =&gt;</span> trigger.addEventListener(<span class="hljs-string">&#x27;mouseenter&#x27;</span>, handleEnter));<br></code></pre></td></tr></table></figure></li><li><p>鼠标移除导航栏菜单时。删除类名<code>trigger-enter</code>，<code>trigger-enter-active</code>，<code>open</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleLeave</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.classList.remove(<span class="hljs-string">&#x27;trigger-enter&#x27;</span>, <span class="hljs-string">&#x27;trigger-enter-active&#x27;</span>);<br>    background.classList.remove(<span class="hljs-string">&#x27;open&#x27;</span>);<br>&#125;<br>triggers.forEach(<span class="hljs-function"><span class="hljs-params">trigger</span> =&gt;</span> trigger.addEventListener(<span class="hljs-string">&#x27;mouseleave&#x27;</span>, handleLeave));<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect()"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect">getBoundingClientRect()</a></h4><p>返回DOMRect对象，包含元素的大小和相对视口的位置信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">domRect = element.getBoundingClientRect();<br></code></pre></td></tr></table></figure><h4 id="will-change-opacity"><a href="#will-change-opacity" class="headerlink" title="will-change: opacity"></a>will-change: opacity</h4><p>提醒浏览器该元素的opacity特性将会改变</p><h4 id="A-gt-B"><a href="#A-gt-B" class="headerlink" title="A &gt; B"></a>A &gt; B</h4><p>匹配A的所有直接后代B</p><blockquote><p>JS30的第26个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#56;&#48;&#x33;&#x31;&#x30;&#53;&#53;&#x33;&#x38;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d;">&#x31;&#56;&#48;&#x33;&#x31;&#x30;&#53;&#53;&#x33;&#x38;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Event Capture 25</title>
    <link href="/myblog.github.io/2022/02/27/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Event-Capture-25/"/>
    <url>/myblog.github.io/2022/02/27/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Event-Capture-25/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第25天的“语音合成”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/25%20eventCapture/index.html">https://github.com/janice143/JavaScript30Program/tree/master/25%20eventCapture/index.html</a></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目主要目的是理解事件的捕获、传播、冒泡、单次触发等机制。首先提供3个尺寸颜色不一的<code>&lt;div&gt;</code>元素，通过点击事件来理解上述内容。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><code>capture</code></li><li><code>once</code></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><ul><li><p><strong>冒泡</strong></p><p>当点击某个<code>div</code>时，自该<code>div</code>起以及其外层的<code>div</code>也将监听到点击事件。</p><p>例如，点击第3个div（最内层的），控制台显示的结果是three,two,one。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> divs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">textLog</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.classList.value);<br>&#125;<br>divs.forEach(<span class="hljs-function"><span class="hljs-params">div</span>=&gt;</span>div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,textLog));<br></code></pre></td></tr></table></figure></li><li><p><strong>捕获</strong></p><p>点击某个<code>div</code>时，从不具体的<code>div</code>元素到最具体的元素（被点击的元素）从上到下监听到点击事件。</p><p>例如，点击第3个<code>div</code>（最内层的），控制台显示的结果是one,two,three。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">divs.forEach(<span class="hljs-function"><span class="hljs-params">div</span>=&gt;</span>div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,textLog,&#123;<br>  <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span><br> &#125;));<br></code></pre></td></tr></table></figure></li><li><p>停止事件继续传递</p><p>在冒泡的基础上，加上<code>e.stopPropagation();</code>来设置不再继续传播</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">textLog</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.classList.value);<br>    e.stopPropagation();<br>&#125;<br>divs.forEach(<span class="hljs-function"><span class="hljs-params">div</span>=&gt;</span>div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,textLog,&#123;<br>    <span class="hljs-attr">capture</span>: <span class="hljs-literal">false</span><br>&#125;));<br></code></pre></td></tr></table></figure></li><li><p>Once：允许事件触发一次，之后相当于<code>removeEventListener</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">textLog</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.classList.value);<br>&#125;<br>divs.forEach(<span class="hljs-function"><span class="hljs-params">div</span>=&gt;</span>div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,textLog,&#123;<br>    <span class="hljs-attr">capture</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">once</span>:<span class="hljs-literal">true</span><br>&#125;));<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>事件开始由最精确的元素触发，逐级向上传播到其他节点</p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>事件由不太具体的节点传播到最具体的节点</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ol><li><a href="https://tsejx.github.io/javascript-guidebook/document-object-model/events/event-flow">事件流</a></li></ol><p>JS30的第25个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#x38;&#x30;&#51;&#49;&#48;&#53;&#x35;&#51;&#56;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;">&#x31;&#x38;&#x30;&#51;&#49;&#48;&#53;&#x35;&#51;&#56;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;</a>.</p>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Sticky Nav 24</title>
    <link href="/myblog.github.io/2022/02/26/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Sticky-Nav-24/"/>
    <url>/myblog.github.io/2022/02/26/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Sticky-Nav-24/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第246天的“粘贴导航栏”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/24%20stickyNav/index.html">https://github.com/janice143/JavaScript30Program/tree/master/24%20stickyNav/index.html</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_Nav.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目主要亮点在于实现导航栏的位置粘贴固定，此外，当鼠标滚动导航栏（本来）消失时，除了要固定导航栏，还要加一点其他样式。</p><p>技术要点是通过<code>scroll</code>事件中，判断窗口位置和当前导航栏的位置，如果前者大于或等于后者，则通过添加一个类名<code>&#39;fixed-nav&#39;</code>（其样式事先在CSS中完善），来实现上述两亮点。</p><p>当前者小于后者，则移除<code>&#39;fixed-nav&#39;</code>类名。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><code>scroll</code>事件</li><li><code>window.scrollY </code>&gt;= <code>topOfNav</code></li><li> <code>nav.offsetTop</code></li><li><code>document.body.classList.add()</code></li><li><code>document.body.classList.remove()</code></li><li><code>position: fixed</code></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><ul><li><code>header</code>标题</li><li><code>nav</code>导航栏菜单</li><li><code>.site-wrap</code>正文</li></ul><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><p>JS的大致思路是：</p><ol><li>监听页面滚动事件</li><li>判断页面当前滚动位置，如果大于等于导航栏距离窗口顶部位置时，则通过添加类名</li><li>否则移除类名</li><li>该类名的样式在CSS中设置好，原理在于position设置为fix</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> nav = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#main&#x27;</span>);<br><span class="hljs-keyword">let</span> topOfNav = nav.offsetTop;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fixNav</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.scrollY &gt;= topOfNav) &#123;<br>        <span class="hljs-comment">// document.body.style.paddingTop = nav.offsetHeight + &#x27;px&#x27;;</span><br>        <span class="hljs-built_in">document</span>.body.classList.add(<span class="hljs-string">&#x27;fixed-nav&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">document</span>.body.classList.remove(<span class="hljs-string">&#x27;fixed-nav&#x27;</span>);<br>        <span class="hljs-built_in">document</span>.body.style.paddingTop = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, fixNav);<br></code></pre></td></tr></table></figure><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="text-align-justify"><a href="#text-align-justify" class="headerlink" title="text-align: justify"></a>text-align: justify</h4><p>均匀分布，有点像word软件的“两端对齐”。</p><blockquote><p>JS30的第24个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#49;&#x38;&#x30;&#51;&#49;&#48;&#53;&#x35;&#51;&#x38;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;">&#49;&#x38;&#x30;&#51;&#49;&#48;&#53;&#x35;&#51;&#x38;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Speech Synthesis 23</title>
    <link href="/myblog.github.io/2022/02/25/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Speech-Synthesis-23/"/>
    <url>/myblog.github.io/2022/02/25/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Speech-Synthesis-23/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第23天的“语音合成”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/23%20speechSynthesis/index.html">https://github.com/janice143/JavaScript30Program/tree/master/23%20speechSynthesis/index.html</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_speechSynthesis.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>利用<code>SpeechSynthesisUtterance</code>接口等实现的语音合成项目，其中设有<code>rate</code>和<code>pitch</code>滑块可改变朗读速度和音高，<code>stop</code>和<code>speech</code>按钮用来控制朗读的开始和暂停。朗读的文本内容可以在文本框中自行输入。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><code>SpeechSynthesisUtterance</code>接口<ul><li><code>speechSynthesisUtterance.lang</code></li><li><code>SpeechSynthesisUtterance.pitch</code></li><li><code>SpeechSynthesisUtterance.rate</code></li><li><code>SpeechSynthesisUtterance.text</code></li><li>``SpeechSynthesisUtterance.name`</li></ul></li><li><code>SpeechSynthesis</code>接口<ul><li><code>voiceschanged</code>事件</li><li><code>SpeechSynthesis.getVoices()</code></li><li><code>speechSynthesis.cancel()</code></li><li><code>SpeechSynthesis.speak()</code></li></ul></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><ul><li><p><code>h1</code>标签</p></li><li><p><code>select</code>多选菜单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;voice&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;voices&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Select A Voice<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>两个范围<code>input</code>控件，用来调控<code>rate</code>和<code>speed</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;rate&quot;</span>&gt;</span>Rate:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rate&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">min</span> = <span class="hljs-string">0</span> <span class="hljs-attr">max</span> = <span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;0.1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;pitch&quot;</span>&gt;</span>Rate:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pitch&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;0.1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>输入文本框，朗读内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>Hey, my name is Iaine, nice to meet you<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>两个按钮，用来暂停朗读和开始朗读</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stop&quot;</span>&gt;</span>Stop<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;speak&quot;</span>&gt;</span>Speak<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><p>JS的大致思路是：</p><ol><li><p>使用相应WebAPI接口获得浏览器支持的语言种类列表，填充至下拉菜单中；</p></li><li><p>在文本域中输入对应语言的文字，点击<code>speak</code>按钮后浏览器会阅读输入的文字；</p></li><li><p>在浏览器阅读时，点击<code>stop</code>按钮，浏览器会停止阅读；</p></li><li><p>拖动<code>rate</code>和<code>pitch</code>滑块可改变阅读速度和音高。</p></li></ol><ul><li><p>取得<code>speechSynthesis</code>对象，获取浏览器支持朗读语言，将所有选项动态添加至下拉列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> speechSynthesis = <span class="hljs-built_in">window</span>.speechSynthesis;<br><span class="hljs-keyword">let</span> voices=[];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">populateVoices</span>(<span class="hljs-params"></span>)</span>&#123;<br>    voices = <span class="hljs-built_in">this</span>.getVoices();<br>    voicesDropdown.innerHTML = voices<br>        .map(<span class="hljs-function"><span class="hljs-params">voice</span> =&gt;</span> <span class="hljs-string">`&lt;option value=&quot;<span class="hljs-subst">$&#123;voice.name&#125;</span>&quot;&gt;<span class="hljs-subst">$&#123;voice.name&#125;</span> (<span class="hljs-subst">$&#123;voice.lang&#125;</span>)&lt;/option&gt;`</span>)<br>        .join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(voices)<br>&#125;<br><br> speechSynthesis.addEventListener(<span class="hljs-string">&#x27;voiceschanged&#x27;</span>, populateVoices);<br></code></pre></td></tr></table></figure></li><li><p>设置下拉列表当前显示的语言，选择好语言后触发朗读</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> voicesDropdown = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[name = &quot;voice&quot;]&#x27;</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setVoice</span>(<span class="hljs-params"></span>)</span>&#123;<br>    msg.voice = voices.find(<span class="hljs-function"><span class="hljs-params">voice</span> =&gt;</span> voice.name === <span class="hljs-built_in">this</span>.value);<br>    toggle();<br>&#125;<br><span class="hljs-comment">//   发出语音</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggle</span>(<span class="hljs-params">startOver = <span class="hljs-literal">true</span></span>) </span>&#123;<br>    speechSynthesis.cancel();<br>    <span class="hljs-keyword">if</span> (startOver) &#123;<br>        speechSynthesis.speak(msg);<br>    &#125;<br>&#125;<br>voicesDropdown.addEventListener(<span class="hljs-string">&#x27;change&#x27;</span>, setVoice);<br></code></pre></td></tr></table></figure></li><li><p>点击<code>speech</code>按钮朗读，<code>stop</code>按钮停止</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> speakButton = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#speak&#x27;</span>);<br><span class="hljs-keyword">const</span> stopButton = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#stop&#x27;</span>);<br>speakButton.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, toggle);<br>stopButton.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> toggle(<span class="hljs-literal">false</span>));<br></code></pre></td></tr></table></figure></li><li><p>构建<code>SpeechSynthesisUtterance</code>实例，添加<code>pitch</code>,<code>text</code>, <code>speed</code>,<code>name</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> msg = <span class="hljs-keyword">new</span> SpeechSynthesisUtterance();<br>msg.text = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[name=&quot;text&quot;]&#x27;</span>).value;<br><span class="hljs-keyword">const</span> options = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;[type=&quot;range&quot;],[type = &quot;text&quot;]&#x27;</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setOption</span>(<span class="hljs-params"></span>)</span>&#123;<br>    msg[<span class="hljs-built_in">this</span>.name] = <span class="hljs-built_in">this</span>.value;<br>    toggle();<br>&#125;<br>options.forEach(<span class="hljs-function"><span class="hljs-params">option</span> =&gt;</span> option.addEventListener(<span class="hljs-string">&#x27;change&#x27;</span>, setOption));<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateText</span>(<span class="hljs-params"></span>)</span>&#123;<br>    msg.text = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[name=&quot;text&quot;]&#x27;</span>).value;<br>&#125;<br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;[name=&quot;text&quot;]&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;change&#x27;</span>, updateText);<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="SpeechSynthesisUtterance接口"><a href="#SpeechSynthesisUtterance接口" class="headerlink" title="SpeechSynthesisUtterance接口"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SpeechSynthesisUtterance">SpeechSynthesisUtterance</a>接口</h4><p>属于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API">Web Speech API</a> 的一个接口，可以发出speech请求。</p><h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">SpeechSynthesisUtterance.SpeechSynthesisUtterance()<br></code></pre></td></tr></table></figure><p>返回一个新的 <code>SpeechSynthesisUtterance</code> 实例对象。</p><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul><li><p><code>SpeechSynthesisUtterance.lang</code> (en-US)</p><p>获取或设置朗读的语言</p></li><li><p><code>SpeechSynthesisUtterance.pitch</code> (en-US)</p><p>获取或设置朗读的音调</p></li><li><p><code>SpeechSynthesisUtterance.rate</code> (en-US)</p><p>获取或设置朗读的速率</p></li><li><p><code>SpeechSynthesisUtterance.text</code> (en-US)</p><p>获取或设置朗读的文本内容</p></li><li><p><code>SpeechSynthesisUtterance.voice</code></p><p>获取或设置朗读的voice</p></li><li><p><code>SpeechSynthesisUtterance.volume</code> (en-US)</p><p>获取或设置朗读的音量</p></li></ul><h4 id="SpeechSynthesis-接口"><a href="#SpeechSynthesis-接口" class="headerlink" title="SpeechSynthesis 接口"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis">SpeechSynthesis</a> 接口</h4><p>属于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API">Web Speech API</a> 的一个<strong>控制</strong>speech服务的接口，可以返回设备合成声音的信息，开始或者暂停speech等。</p><h5 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h5><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/paused"><code>SpeechSynthesis.paused</code></a> ：SpeechSynthesis对象是否暂停状态</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/pending"><code>SpeechSynthesis.pending</code></a> ： utterance queue 是都还有没有余留没有读的 utterance。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/speaking"><code>SpeechSynthesis.speaking</code></a>：一个utterance是否在被读的阶段</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/cancel"><code>SpeechSynthesis.cancel()</code></a></p><p>移除utterance queue队列中所有的utterances</p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/getVoices"><code>SpeechSynthesis.getVoices()</code></a></p><p>返回现有设备所有可用的voices的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisVoice"><code>SpeechSynthesisVoice</code></a> 对象</p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/pause"><code>SpeechSynthesis.pause()</code></a></p><p>把 <code>SpeechSynthesis</code> 对象放在暂停状态</p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/resume"><code>SpeechSynthesis.resume()</code></a></p><p>把 <code>SpeechSynthesis</code> 对象放在重新打开状态</p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/speak"><code>SpeechSynthesis.speak()</code></a></p><p>在utterance queue队列中增加一个<a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisUtterance"><code>utterance</code></a> </p></li></ul><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/voiceschanged_event"><code>voiceschanged</code></a></p><p>在<code>SpeechSynthesis.getVoices()</code>方法返回的<a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesisVoice"><code>SpeechSynthesisVoice</code></a> 对象变化的时候触发</p><p><u><strong>注意</strong>：<code>SpeechSynthesisUtterance</code>接口和<code>SpeechSynthesis</code>接口的关系</u></p><ol><li>二者都属于Web Speech API 接口</li><li>前者是设置朗读的配置参数，包括语言，速度，语调，内容等</li><li>后者是控制朗读的行为，包括获取浏览器支持的朗读语言，文本朗读，暂停，停止等</li></ol><h4 id="CSS知识补充"><a href="#CSS知识补充" class="headerlink" title="CSS知识补充"></a>CSS知识补充</h4><ul><li><h5 id="nth-of-type"><a href="#nth-of-type" class="headerlink" title=":nth-of-type()"></a>:nth-of-type()</h5><p>伪类选择器，匹配相同类型（也就是相同标签）的元素</p><p>和<code>:nth-child</code>区别在于后者不是同类。</p></li><li><p><code>calc()</code>方法 允许计算</p></li></ul><blockquote><p>JS30的第23个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#56;&#x30;&#x33;&#x31;&#48;&#x35;&#x35;&#51;&#x38;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;">&#x31;&#56;&#x30;&#x33;&#x31;&#48;&#x35;&#x35;&#51;&#x38;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Link Highlighter 22</title>
    <link href="/myblog.github.io/2022/02/25/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Link-Highlighter-22/"/>
    <url>/myblog.github.io/2022/02/25/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Link-Highlighter-22/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第22天的“链接高亮显示”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/22%20linkHighlighter/index.html">https://github.com/janice143/JavaScript30Program/tree/master/22%20linkHighlighter/index.html</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_HighLighter.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目页面主要有一个导航栏菜单和正文内容组成。页面实现的效果是：当鼠标进入<code>a</code>标签时，背景颜色以白色高亮显示，当鼠标移到下一个<code>a</code>标签时，白色高亮块上一个<code>a</code>标签中移动下来。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><code>Element.getBoundingClientRect()</code></li><li><code>window.scrollY</code></li><li><code>mouseenter</code>事件</li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><ul><li><p><code>nav</code>标签包裹的导航栏菜单</p><ul><li><code>ul</code>标签<ul><li>5个<code>li</code>标签，为菜单内容</li></ul></li></ul></li><li><p>类名为<code>wrapper</code>的<code>div</code>标签包含了正文内容</p></li><li><p>链接用<code>a</code>标签标记，在JS中要实现高亮显示</p></li></ul><h4 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h4><p>使用如下技巧将外边距和内边距重置为零</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">*, *:before, *:after &#123;<br>  box-sizing: inherit;<br>&#125;<br></code></pre></td></tr></table></figure><p>高亮块的CSS样式，基本思路是加上绝对定位（相对于最近定位的父元素定位，在这里父元素是body），通过在JS中改变<code>top</code>和<code>left</code>以及<code>width</code>和<code>height</code>属性，来呈现不同链接选中的状态。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.highlight</span>&#123;<br>    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.2s</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid white;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">background</span>: white;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><p>JS的大致思路是：</p><ol><li><p>获取链接标签，以及创建<code>span</code>标签，用来添加<code>highlight</code>样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> triggers = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">const</span> highlight = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;span&#x27;</span>);<br>highlight.classList.add(<span class="hljs-string">&#x27;highlight&#x27;</span>);<br><span class="hljs-built_in">document</span>.body.appendChild(highlight);<br></code></pre></td></tr></table></figure></li><li><p>获取当前鼠标进入的链接元素的位置信息</p></li><li><p>修改类名为<code>highlight</code>的样式</p></li><li><p>给<code>a</code>标签添加鼠标进入<code>mouseenter</code>事件</p></li></ol><ul><li>获取链接标签，以及创建<code>span</code>标签，用来添加<code>highlight</code>样式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">highlightter</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> link = <span class="hljs-built_in">this</span>.getBoundingClientRect();<br>    <span class="hljs-built_in">console</span>.log(link);<br>    <span class="hljs-keyword">const</span> linkCoordinates =&#123;<br>        <span class="hljs-attr">width</span>:link.width,<br>        <span class="hljs-attr">height</span>:link.height,<br>        <span class="hljs-attr">top</span>:link.top+<span class="hljs-built_in">window</span>.scrollY,<br>        <span class="hljs-attr">left</span>:link.left+<span class="hljs-built_in">window</span>.scrollX<br>    &#125;;<br>    highlight.style.width = <span class="hljs-string">`<span class="hljs-subst">$&#123;linkCoordinates.width&#125;</span>px`</span>;<br>    highlight.style.height = <span class="hljs-string">`<span class="hljs-subst">$&#123;linkCoordinates.height&#125;</span>px`</span>;<br>    highlight.style.transform = <span class="hljs-string">`translate(<span class="hljs-subst">$&#123;linkCoordinates.left&#125;</span>px,<span class="hljs-subst">$&#123;linkCoordinates.top&#125;</span>px)`</span>;<br>&#125;<br>triggers.forEach(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a.addEventListener(<span class="hljs-string">&#x27;mouseenter&#x27;</span>, highlightter));<br></code></pre></td></tr></table></figure><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="Element.getBoundingClientRect()"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect">Element.getBoundingClientRect()</a></h4><p>返回一个DOMRect对象，包含了元素的大小、相对于视口的位置信息。</p><p><strong>DOMRect相关只读属性</strong></p><table><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td>height</td><td>矩形盒子的高度</td></tr><tr><td>width</td><td>矩形盒子的宽度</td></tr><tr><td>top</td><td>Y 轴，相对于视口原点（viewport origin）顶部</td></tr><tr><td>left</td><td>X 轴，相对于视口原点左侧</td></tr><tr><td>bottom</td><td>Y 轴，相对于视口原点底部</td></tr><tr><td>right</td><td>X 轴，相对于视口原点右侧</td></tr><tr><td>x</td><td>盒子左上角位置的X轴横坐标</td></tr><tr><td>y</td><td>盒子左上角位置的Y轴横坐标</td></tr></tbody></table><h4 id="window-scrollY"><a href="#window-scrollY" class="headerlink" title="window.scrollY"></a>window.scrollY</h4><p>鼠标滑动的垂直距离</p><p>window.scrollX 鼠标滑动的水平距离</p><h4 id="mousemove-mouseenter-和mouseover区别"><a href="#mousemove-mouseenter-和mouseover区别" class="headerlink" title="mousemove, mouseenter 和mouseover区别"></a>mousemove, mouseenter 和mouseover区别</h4><p>mousemove：鼠标指针进入<code>div</code>以及其子元素时触发；</p><p> mouseenter：鼠标指针进入<code>div</code>时触发；</p><p>mouseover：鼠标每次滑过<code>div</code>时触发</p><p>点击此链接体验三者的效果 👉 <a href="https://www.w3schools.com/jquery/tryit.asp?filename=tryjquery_event_mouseenter_mouseover#:~:text=mouseenter%20and%20mouseover.-,The%20mouseover%20event%20triggers%20when%20the%20mouse%20pointer%20enters%20the,moved%20over%20the%20div%20element.">体验</a></p><blockquote><p>JS30的第22个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#49;&#56;&#48;&#x33;&#x31;&#48;&#x35;&#53;&#51;&#x38;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;">&#49;&#56;&#48;&#x33;&#x31;&#48;&#x35;&#53;&#51;&#x38;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Geolocation 21</title>
    <link href="/myblog.github.io/2022/02/24/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Geolocation-21/"/>
    <url>/myblog.github.io/2022/02/24/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Geolocation-21/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第21天的“地理位置”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/21%20geoLocation/index.html">https://github.com/janice143/JavaScript30Program/tree/master/21%20geoLocation/index.html</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_geoLocation21.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目是一个可视化的指南，利用网络地址位置<code>Web Geolocation API</code>获取的地理位置和速度。</p><p>本项目的JS代码相对比较简单，但是由于电脑一般没有速度及方向传感器，所以实际的功能并没显示出来，只是提供了一种实现途径。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><code>Geolocation.watchPosition()</code> API<ul><li><code>.coords.speed</code></li><li><code>.coords.heading</code></li></ul></li><li>CSS <code>radial-gradient</code></li><li><code>background-attachment</code>设置背景图是否固定不到</li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><ul><li><code>svg</code>图片元素</li><li><code>h1</code>元素<ul><li>类名为<code>speed-value</code> <code>span</code>标签</li><li>类名为<code>speed-unit</code> <code>span</code>标签</li></ul></li></ul><h4 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h4><ul><li>设置背景图片</li></ul><p><code>radial-gradient</code>由圆心向外的径向的颜色渐变</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">radial-gradient(rgba(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,.<span class="hljs-number">1</span>) <span class="hljs-number">15%</span>, transparent <span class="hljs-number">20%</span>) <span class="hljs-number">0</span> <span class="hljs-number">1px</span><br></code></pre></td></tr></table></figure><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><p>JS的大致思路是：</p><ol><li>请求调用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation">Geolocation接口</a> </li><li>获取当前的地理位置信息data</li><li>显示速度信息 <code>data.coords.speed</code></li><li>改变页面中指南针的朝向 <code>data.coords.heading</code></li></ol><p>具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">navigator.geolocation.watchPosition(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data);<br>    speed.textContent = data.coords.speed;<br>    arrow.style.transform = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;data.coords.heading&#125;</span>deg)`</span>;<br>&#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(err);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="Geolocation接口-：获取设备的地理位置信息"><a href="#Geolocation接口-：获取设备的地理位置信息" class="headerlink" title="Geolocation接口 ：获取设备的地理位置信息"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation">Geolocation接口</a> ：获取设备的地理位置信息</h4><p>方法 1：<code>Geolocation.getCurrentPosition()</code> 获取当前的位置信息</p><p>方法 2：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition"><code>Geolocation.watchPosition()</code></a> 返回位置变化后的最新信息</p><p>方法 3：<code>Geolocation.clearWatch()</code> 删除使用<code>watchPosition()</code>后的句柄</p><blockquote><p>JS30的第21个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#x38;&#48;&#51;&#x31;&#x30;&#53;&#x35;&#51;&#56;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">&#x31;&#x38;&#48;&#51;&#x31;&#x30;&#53;&#x35;&#51;&#56;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Speech Detetion 20</title>
    <link href="/myblog.github.io/2022/02/22/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Speech-Detetion-20/"/>
    <url>/myblog.github.io/2022/02/22/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Speech-Detetion-20/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第20天的“语音检测”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/20%20speechDetection/index.html">https://github.com/janice143/JavaScript30Program/tree/master/20%20speechDetection/index.html</a></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目是一个语音识别系统，网页首先会向用户请求麦克风权限，允许后可识别出用户的speech（语言为每个英语<code>en-US&#39;</code>)，并显示在网页中。</p><p>本项目用到的语音识别系统是<code>Web Speech API</code>，只能在 Chrome浏览器上使用，而且功能也一直在完善中，因此，本项目只是提供一种语音识别系统的解决思路，以便参考。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><p><code>Web Speech API</code></p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition"><code>SpeechRecognition</code></a> 接口<ul><li><code>SpeechRecognition.interimResults</code></li><li><code>SpeechRecognition.lang</code></li><li><code>SpeechRecognition.start()</code></li><li><code>new SpeechRecognition()</code></li></ul></li></ul></li><li><p><code>result</code>事件</p><ul><li><code>e.results</code></li><li><code>result.transcript</code></li><li><code>e.results[0].isFinal</code></li></ul></li><li><p><code>p.textContent </code></p></li><li><p><code>end</code>事件</p></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><p>只有一个<code>div</code>元素，可编辑<code>contenteditable</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;words&quot;</span> <span class="hljs-attr">contenteditable</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><p>JS的大致思路是：</p><ol><li>添加Chrome support</li><li>定义语音识别实例</li><li>开启语音识别功能</li><li>监听<code>result</code>事件，实时获取捕获到的speech，并通过创建元素的方法显示到网页中</li><li>监听<code>end</code>事件，当语音捕获结束后，重新开启语音识别功能</li></ol><ul><li><p>Chrome support</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition"><code>SpeechRecognition</code></a> 接口只能在 Chrome浏览器上使用，，因此需要适配Chrome浏览器的对象以及未来其他浏览器也能使用的一些修正</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.SpeechRecognition = <span class="hljs-built_in">window</span>.SpeechRecognition || <span class="hljs-built_in">window</span>.webkitSpeechRecognition;<br></code></pre></td></tr></table></figure></li><li><p>定义语音识别实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> recognition = <span class="hljs-keyword">new</span> SpeechRecognition();<br></code></pre></td></tr></table></figure></li><li><p>创建一个<code>p</code>元素，后面可以讲识别到的语音放进去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);<br><span class="hljs-keyword">const</span> words = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.words&#x27;</span>);<br>words.appendChild(p);<br></code></pre></td></tr></table></figure></li><li><p>打开语音识别功能，监听<code>result</code>事件，实时获取捕获到的speech，并显示到网页中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">recognition.addEventListener(<span class="hljs-string">&#x27;result&#x27;</span>,<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> transcript = <span class="hljs-built_in">Array</span>.from(e.results)<br>    .map(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result[<span class="hljs-number">0</span>])<br>    .map(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result.transcript)<br>    .join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    p.textContent = transcript;<br>    <span class="hljs-comment">// console.log(e.results[0].transcript)</span><br>    <span class="hljs-keyword">if</span> (e.results[<span class="hljs-number">0</span>].isFinal) &#123;<br>        p = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);<br>        words.appendChild(p);<br>    &#125;<br>&#125;);<br><br>recognition.start(); <span class="hljs-comment">// 打开语音功能</span><br></code></pre></td></tr></table></figure></li><li><p>监听<code>end</code>事件，当语音捕获结束后，重新开启语音识别功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">recognition.addEventListener(<span class="hljs-string">&#x27;end&#x27;</span>, recognition.start);<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="Web-Speech-API-语音识别和语音输出"><a href="#Web-Speech-API-语音识别和语音输出" class="headerlink" title="Web Speech API 语音识别和语音输出"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API/Using_the_Web_Speech_API">Web Speech API</a> 语音识别和语音输出</h4><p>主要的语音识别接口是<a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition"><code>SpeechRecognition</code></a> 接口，只能在 Chrome浏览器上使用</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition"><code>SpeechRecognition</code></a> 接口的一些属性：</p><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition/interimResults"><code>SpeechRecognition.interimResults</code></a>：设置语音识别系统是否返回中间结果，还是最终结果</p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition/lang"><code>SpeechRecognition.lang</code></a>: 设置语音识别系统的语言</p></li></ul><h4 id="innerText、textContent和innerHTML三者的区别"><a href="#innerText、textContent和innerHTML三者的区别" class="headerlink" title="innerText、textContent和innerHTML三者的区别"></a>innerText、textContent和innerHTML三者的区别</h4><p><code>innerText</code>、<code>textContent</code>和<code>innerHTML</code>可以设置标签中的文本内容。</p><p><strong>不同点</strong></p><p><code>innerHTML</code>可以将内容中的标签为标签，而其他两个则不行，只是纯文本</p><p><code>innerText</code>，<code>textContent</code>获取的是该标签和该标签下子标签中的文本内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mylinks&quot;</span>&gt;</span><br>  This is my <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>link collection<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>:<br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;www.borland.com&quot;</span>&gt;</span>Bye bye <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Borland<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;www.microfocus.com&quot;</span>&gt;</span>Welcome to <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Micro Focus<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">const</span> dv = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;mylinks&quot;</span>);</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(dv.textContent);        </span><br><span class="javascript">    <span class="hljs-comment">// This is my link collection:</span></span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">// Bye bye Borland </span></span><br><span class="javascript">    <span class="hljs-comment">// Welcome to Micro Focus</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(dv.innerText);</span><br><span class="javascript">    <span class="hljs-comment">// This is my link collection:</span></span><br><span class="javascript">    <span class="hljs-comment">// Bye bye Borland</span></span><br><span class="javascript">    <span class="hljs-comment">// Welcome to Micro Focus</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(dv.innerHTML);</span><br><span class="javascript">    <span class="hljs-comment">// This is my &lt;b&gt;link collection&lt;/b&gt;:</span></span><br><span class="javascript">    <span class="hljs-comment">// &lt;ul&gt;</span></span><br><span class="javascript">    <span class="hljs-comment">// &lt;li&gt;&lt;a href=&quot;www.borland.com&quot;&gt;Bye bye &lt;b&gt;Borland&lt;/b&gt; &lt;/a&gt;&lt;/li&gt;</span></span><br><span class="javascript">    <span class="hljs-comment">// &lt;li&gt;&lt;a href=&quot;www.microfocus.com&quot;&gt;Welcome to &lt;b&gt;Micro Focus&lt;/b&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="javascript">    <span class="hljs-comment">// &lt;/ul&gt;       </span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="let-var-const区别"><a href="#let-var-const区别" class="headerlink" title="let var const区别"></a>let var const区别</h4><p>var 声明会变量提升</p><p>let 块级作用域，声明不会变量提升</p><p>const 块级作用域声明的变量为常量，值不可修改</p><p><strong>更多内容见参考博客[2-4]</strong></p><h4 id="CSS-position"><a href="#CSS-position" class="headerlink" title="CSS position"></a>CSS position</h4><table><thead><tr><th>值</th><th></th></tr></thead><tbody><tr><td>relative</td><td>相对自己原来（正常文档流）的位置</td></tr><tr><td>absolute</td><td>脱离文档流，相对于最近的已定位父元素</td></tr><tr><td>fixed</td><td>脱离文档流，相对于浏览器窗口是固定位置</td></tr><tr><td>sticky</td><td>基于用户的滚动位置来定位。行为就像 relative，而当页面滚动超出目标区域时，它的表现就像 fixed，固定在目标位置。</td></tr><tr><td>static</td><td>HTML 元素的默认值，即没有定位，遵循正常的文档流对象。</td></tr></tbody></table><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ol><li><a href="https://juejin.cn/post/6844903684317380616">innerText、textContent和innerHTML三者的区别</a></li><li><a href="https://juejin.cn/post/6925641096152399880">一看就懂的var、let、const三者区别</a></li><li><a href="https://www.cnblogs.com/JobsOfferings/p/varLetConst.html">var、let和const的区别详解</a></li><li><a href="https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/compilation/blocks-as-scopes">块作用域</a></li></ol><blockquote><p>JS30的第20个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#49;&#x38;&#x30;&#x33;&#49;&#48;&#53;&#53;&#51;&#56;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;">&#49;&#x38;&#x30;&#x33;&#49;&#48;&#53;&#53;&#51;&#56;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】WebCam Fun 19</title>
    <link href="/myblog.github.io/2022/02/16/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91WebCam-Fun-19/"/>
    <url>/myblog.github.io/2022/02/16/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91WebCam-Fun-19/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第19天的“网络摄像头”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/19%20webCamFun/index.html">https://github.com/janice143/JavaScript30Program/tree/master/19%20webCamFun/index.html</a></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>通过访问网络摄像头，获取了当前摄像头拍摄的信息，作为<code>video</code>元素的内容。<code>video</code>元素中的视频信息被定时器一帧一帧绘制在<code>canvas</code>元素中。</p><p>提供了一个名为<code>take photo</code>的按钮用来抓取当前视频帧的内容，该内容最后通过通过创建<code>a</code>标签显示在网页中。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><code>mediaDevices.getUserMedia</code></li><li><code>video</code>属性和方法<ul><li><code>video.videoWidth</code></li><li><code>video.srcObject </code></li></ul></li><li><code>setInterval</code></li><li><code>canvas.toDataURL</code></li><li><code>HTML DOM setAttribute(属性名，值)</code></li><li><code>canplay</code>事件</li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><ul><li>最外层为类名为<code>photobooth</code>的<code>div</code>元素<ul><li>作为控件的<code>div</code>元素：take photo按钮</li><li><code>canvas</code>元素用来绘制<code>video</code>的视频帧</li><li><code>video</code>元素用来播放从网络摄像头获取的数据流</li></ul></li><li>音频<code>audio</code>标签</li></ul><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><p>JS的大致思路是：</p><ol><li>请求调用网络摄像头</li><li>摄像头中的数据流给video元素</li><li>在canvas上绘制video的内容</li><li>点击take photo按钮获取当前canvas上的画面，显示到网页上</li></ol><ul><li><p>编写<code>getVideo</code>函数：访问网络摄像头的权限,播放视频，放在<code>video</code>标签里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getVideo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    navigator.mediaDevices.getUserMedia(&#123; <span class="hljs-attr">video</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">audio</span>: <span class="hljs-literal">false</span> &#125;)<br>    .then(<span class="hljs-function"><span class="hljs-params">localMediaStream</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(localMediaStream);     <br>      video.srcObject = localMediaStream;<br>      video.play();<br>    &#125;)<br>    .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`OH NO!!!`</span>, err);<br>    &#125;);  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>把视频信息放到<code>canvas</code>中</p><ul><li><p>先获取视频的宽高信息，复制给canvas.width和height，保证canvas上显示视频画面完整（注意这里并不是设置canvas在网页上显示的宽高）</p></li><li><p><code>canvas</code>流畅显示的机制是利用定时器不断获取当前<code>video</code>的内容</p></li><li><p>利用<code>ctx.drawImage</code>实现绘制</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">paintToCanvas</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> width = video.videoWidth;<br>    <span class="hljs-keyword">const</span> height = video.videoHeight;<br>    canvas.width = width;<br>    canvas.height = height;<br><br>    <span class="hljs-comment">// canvas上显示的机制是利用定时器，将视频中当前帧的图像绘制在canvas上    </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        ctx.drawImage(video, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>      &#125;, <span class="hljs-number">16</span>);<br>&#125;<br>video.addEventListener(<span class="hljs-string">&#x27;canplay&#x27;</span>, paintToCanvas);<br></code></pre></td></tr></table></figure></li><li><p>编写take photo的点击函数</p><ul><li>播放音效</li><li>获取当前canvas的data，变成图片</li><li>创建元素，显示到网页中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">takePhoto</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-comment">// 播放音频</span><br>    snap.currentTime = <span class="hljs-number">0</span>;<br>    snap.play();<br><br>    <span class="hljs-comment">// 获取当前canvas的data，变成图片</span><br>    <span class="hljs-keyword">const</span> data = canvas.toDataURL(<span class="hljs-string">&#x27;image/jpeg&#x27;</span>);<br>    <span class="hljs-keyword">const</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);<br>    link.href = data;<br>    link.setAttribute(<span class="hljs-string">&#x27;download&#x27;</span>, <span class="hljs-string">&#x27;handsome&#x27;</span>);<br>    link.innerHTML = <span class="hljs-string">`&lt;img src=&quot;<span class="hljs-subst">$&#123;data&#125;</span>&quot; alt=&quot;Handsome Man&quot; /&gt;`</span>;<br>    strip.insertBefore(link, strip.firstChild);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="HTML-音频-视频-DOM-canplay-事件"><a href="#HTML-音频-视频-DOM-canplay-事件" class="headerlink" title="HTML 音频/视频 DOM canplay 事件"></a>HTML 音频/视频 DOM <code>canplay</code> 事件</h4><p>当浏览器能够开始播放指定的音频/视频时，触发canplay 事件</p><h4 id="常用CSS的长度单位（相对-绝对）"><a href="#常用CSS的长度单位（相对-绝对）" class="headerlink" title="常用CSS的长度单位（相对/绝对）"></a>常用CSS的长度单位（相对/绝对）</h4><table><thead><tr><th>单位</th><th>名称</th></tr></thead><tbody><tr><td><code>em</code></td><td>在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</td></tr><tr><td><code>rem</code></td><td>根元素的字体大小</td></tr><tr><td><code>vw</code></td><td>视窗宽度的1%</td></tr><tr><td><code>vh</code></td><td>视窗高度的1%</td></tr><tr><td><code>px</code></td><td>像素</td></tr></tbody></table><h4 id="navigator-mediaDevices-getUserMedia"><a href="#navigator-mediaDevices-getUserMedia" class="headerlink" title="navigator.mediaDevices.getUserMedia"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia">navigator.mediaDevices.getUserMedia</a></h4><p>提示用户允许一个媒体输入（视频、音频等），媒体输入会产生一个mediaStream包换了媒体信息。该方法返回一个promise</p><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">navigator.mediaDevices.getUserMedia(constraints)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stream</span>) </span>&#123;<br>  <span class="hljs-comment">/* use the stream */</span><br>&#125;)<br>.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>  <span class="hljs-comment">/* handle the error */</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>其中<code>constrains</code>参数可为<code>&#123; audio: true, video: true &#125;</code></p><h4 id="X-after-选择器"><a href="#X-after-选择器" class="headerlink" title="X:after 选择器"></a>X:after 选择器</h4><p>在元素内部的后面插入内容。常用来清楚浮动<code>clear-fix</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span>:after &#123;  <br>    content: <span class="hljs-string">&quot;&quot;</span>;  <br>    <span class="hljs-attribute">display</span>: block;  <br>    <span class="hljs-attribute">clear</span>: both;  <br>    <span class="hljs-attribute">visibility</span>: hidden;  <br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;  <br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;  <br>&#125;   <br><span class="hljs-selector-class">.clearfix</span> &#123;   <br>   *<span class="hljs-attribute">display</span>: inline-block;   <br>   _height: <span class="hljs-number">1%</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>原理是使用<code>:after</code>伪类元素来在元素后增加一个空间，然后清除它。</p><h4 id="overflow-x"><a href="#overflow-x" class="headerlink" title="overflow-x"></a>overflow-x</h4><p>overflow-x 属性规定是否对内容的左/右边缘进行裁剪，如果溢出元素内容区域的话。</p><p>overflow-y 属性对上/下边缘的裁剪。</p><h4 id="a-nth-child-5n-1"><a href="#a-nth-child-5n-1" class="headerlink" title="a:nth-child(5n+1)"></a>a:nth-child(5n+1)</h4><p>选择第1、6、11…个<code>a</code>标签</p><h4 id="利用canvas操纵video"><a href="#利用canvas操纵video" class="headerlink" title="利用canvas操纵video"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Manipulating_video_using_canvas">利用canvas操纵video</a></h4><p>获取到video的每一帧内容后，绘制在canavs上。这是显示的第一步，除此之外，还可以做一些进阶，比如将每一帧画面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> pixels = ctx.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br></code></pre></td></tr></table></figure><h4 id="JavaScript-定时器"><a href="#JavaScript-定时器" class="headerlink" title="JavaScript 定时器"></a>JavaScript 定时器</h4><ul><li><code>setTimeout()</code>：指定多久时间运行回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 2 秒之后运行</span><br>&#125;, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p><code>setTimeout</code> 会返回定时器的 id。 通常不使用它，但是可以保存此 id，并在要删除此安排的函数执行时清除它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 应该在 2 秒之后运行</span><br>&#125;, <span class="hljs-number">2000</span>)<br><span class="hljs-comment">// 改变主意了</span><br><span class="hljs-built_in">clearTimeout</span>(id)<br></code></pre></td></tr></table></figure><ul><li><code>setInterval()</code>：指定多少时间间隔运行一次回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-comment">// 每 2 秒运行一次</span><br>&#125;, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure><p><u><strong>问题</strong>：这里如何清除定时器呢？每次触发<code>video</code>的<code>canplay</code>事件，会执行<code>paintToCanvas</code>函数，而该函数可以返回定时器的<code>id</code>。如果要清除该定时器，怎么清除呢？</u></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><ol><li><a href="https://yanhaijing.com/css/2014/01/04/the-30-css-selectors-you-must-memorize/">30个你必须记住的CSS选择符</a></li><li><a href="http://nodejs.cn/learn/discover-javascript-timers">探索 JavaScript 定时器</a></li><li><a href="https://www.cnblogs.com/chenyoumei/p/12695381.html">JS设置定时器和清除定时器</a></li></ol><blockquote><p>JS30的第19个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#56;&#48;&#51;&#49;&#x30;&#53;&#53;&#x33;&#x38;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">&#x31;&#56;&#48;&#51;&#49;&#x30;&#53;&#53;&#x33;&#x38;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Time with Redece 18</title>
    <link href="/myblog.github.io/2022/02/15/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Time-with-Redece-18/"/>
    <url>/myblog.github.io/2022/02/15/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Time-with-Redece-18/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第18天的“利用reduce进行时间累加”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>源代码：<a href="https://github.com/janice143/JavaScript30Program/tree/master/18%20timeWithReduce/index.html">https://github.com/janice143/JavaScript30Program/tree/master/18%20timeWithReduce/index.html</a></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>项目首先在html中提供了若干个属性名为<code>data-time</code>的列表元素，<code>data-time</code>的值以00:00（分：秒）的格式显示。要求在JS中计算出<code>data-time</code>的总值，并且用？时？分？秒的格式显示结果。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><code>Array.from()</code></li><li><code>timeNode.dataset.time</code></li><li><code>.split(&#39;:&#39;)</code></li><li><code>.map(parseFloat)</code></li><li><code>.reduce()</code></li><li><code>Math.floor()</code></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><ul><li> 若干个<code>li</code>标签，添加了<code>data-time</code>属性</li></ul><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><p>JS的整体思路是先获取所有的<code>data-time</code>的值，然后将所有值转化成秒，并且计算出的总秒数。根据总秒数得到对应的时、分、秒。</p><p>为了显示最后的结果，在本项目中国通过创建一个p元素来实现。</p><ul><li><p>获取所有的<code>data-time</code>元素，转化成数组，并存储在<code>timeNodes</code>变量中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> timeNodes = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;[data-time]&#x27;</span>));<br></code></pre></td></tr></table></figure></li><li><p>从<code>timeNodes</code>中可以得到<code>data-time</code>的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> seconds = timeNodes.map(<br>    <span class="hljs-function"><span class="hljs-params">timeNode</span> =&gt;</span> timeNode.dataset.time<br>)<br></code></pre></td></tr></table></figure></li><li><p>将每个<code>data-time</code>的值转化成秒</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">.map(<br>    <span class="hljs-function"><span class="hljs-params">timeCode</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> [min, sec] = timeCode.split(<span class="hljs-string">&#x27;:&#x27;</span>).map(<span class="hljs-built_in">parseFloat</span>)<br>        <span class="hljs-comment">// console.log(typeof(min),sec)</span><br>        <span class="hljs-keyword">return</span> (min*<span class="hljs-number">60</span>)+sec<br>    &#125;<br>)<br></code></pre></td></tr></table></figure></li><li><p>利用reduce方法累加得到总秒数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">.reduce(<br>    <span class="hljs-function">(<span class="hljs-params">total,vidSecond</span>) =&gt;</span> total + vidSecond<br>)<br></code></pre></td></tr></table></figure></li><li><p>根据总秒数，计算出时、分、秒</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> leftSec = seconds;<br><span class="hljs-keyword">const</span> hour = <span class="hljs-built_in">Math</span>.floor(leftSec/<span class="hljs-number">3600</span>);<br>leftSec = leftSec % <span class="hljs-number">3600</span>;<br><br><span class="hljs-keyword">const</span> min = <span class="hljs-built_in">Math</span>.floor(leftSec/<span class="hljs-number">60</span>);<br>leftSec = leftSec % <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure></li><li><p>新建一个p元素，添加显示内容，最后挂载到网页上，显示结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">display</span>(<span class="hljs-params">hour,min,leftSec</span>)</span>&#123;<br>    <span class="hljs-comment">// 使用createElement创建元素</span><br>    <span class="hljs-keyword">const</span> newTaskItem = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);<br>    newTaskItem.className = <span class="hljs-string">&#x27;total-time&#x27;</span>;<br>    <span class="hljs-keyword">const</span> html =<br>          <span class="hljs-string">`</span><br><span class="hljs-string">          总播放时间为：<span class="hljs-subst">$&#123;hour&#125;</span>小时<span class="hljs-subst">$&#123;min&#125;</span>分<span class="hljs-subst">$&#123;leftSec&#125;</span>秒。</span><br><span class="hljs-string">`</span>;<br>    newTaskItem.innerHTML = html;<br>    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>).before(newTaskItem);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from">Array.from</a>：将一个伪数组对象转化成数组。</p><p><code>.split()</code>：将一个<code>String</code>对象分割成子字符串数组</p><h4 id="parseFloat-string-将字符串解析为浮点数"><a href="#parseFloat-string-将字符串解析为浮点数" class="headerlink" title="parseFloat(string)将字符串解析为浮点数"></a><code>parseFloat(string)</code>将字符串解析为浮点数</h4><ul><li>如果 <code>parseFloat</code> 在解析过程中遇到了正号（<code>+</code>）、负号（<code>-</code> ）、数字（<code>0</code>-<code>9</code>）、小数点（<code>.</code>）、或者科学记数法中的指数（e 或 E）以外的字符，则它会忽略该字符以及之后的所有字符，返回当前已经解析到的浮点数。</li><li>第二个小数点的出现也会使解析停止。</li><li>参数首位和末位的空白符会被忽略。</li><li>如果字符串的第一个字符不能被解析成为数字，则返回 <code>NaN</code>。</li><li><code>parseFloat</code> 也可以解析并返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Infinity"><code>Infinity</code></a>。</li></ul><h4 id="reduce方法"><a href="#reduce方法" class="headerlink" title="reduce方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">reduce方法</a></h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])<br></code></pre></td></tr></table></figure><p><code>initialValue</code>为作为第一次调用 <code>callback</code>函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">accumulator, currentValue</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> accumulator + currentValue;<br>&#125;); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><blockquote><p>JS30的第18个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#49;&#56;&#x30;&#51;&#49;&#48;&#x35;&#53;&#51;&#56;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;">&#49;&#56;&#x30;&#51;&#49;&#48;&#x35;&#53;&#51;&#56;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Sort without Articles 17</title>
    <link href="/myblog.github.io/2022/02/14/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Sort-without-Articles-17/"/>
    <url>/myblog.github.io/2022/02/14/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Sort-without-Articles-17/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第17天的“去除冠词排序”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>网页效果： <a href="https://janice143.github.io/sortWithoutArticles/">https://janice143.github.io/sortWithoutArticles/</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_SortWithoutArticles17.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目首先给定了一个内容为band名字的列表<code>bands</code>，在JS中，对列表进行<strong>特殊的排序</strong>操作，得到新的列表最终以列表的形式显示到网页中。</p><p>其中特殊的排序操作，具体来说，是先去除列表元素中”a, an, the”的前缀，然后按照字母排序。排序的列表还是原列表，无需使列表元素去除特定前缀。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><p>字符串的一些方法</p><ul><li><code>String.prototype.replace()</code></li><li><code>String.prototype.trim()</code></li></ul></li><li><p>数组的一些方法</p><ul><li><code>Array.prototype.sort()</code></li></ul></li><li><p>正则表达式</p><ul><li><code>/^(a |the |an )/i</code></li></ul></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><ul><li> id 属性为<code>bands</code>的ul元素，列表内容在JS中添加</li></ul><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><ul><li><p>首先提供一个已知列表bands</p></li><li><p>将列表<code>bands</code>内容显示到网页中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#bands&#x27;</span>).innerHTML = bands.map(<span class="hljs-function"><span class="hljs-params">band</span> =&gt;</span> <span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;band&#125;</span>&lt;/li&gt;`</span>).join(<span class="hljs-string">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>显示已经实现，下一步我们需要对bands进行一些操作，得到的新列表再按照上述方法显示到网页中。<strong>注意</strong>：无需对原列表bands进行操作，也就是不用改变bands的值</p><ul><li><p>去除前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strip</span>(<span class="hljs-params">bandName</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> bandName.replace(<span class="hljs-regexp">/^(a |the |an )/i</span>,<span class="hljs-string">&#x27;&#x27;</span>).trim();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sortedBands = bands.sort(<br>    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> strip(a) &gt; strip(b) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>程序写到这里就已经ok啦！本项目需要注意的是最后显示的内容还是原bands中的元素，但是排序方式要求去掉前缀后排序。</p><p>如果项目要求最后显示的内容是去除前缀的元素，那么下面的程序提供了一个实现思路：</p><ul><li><p>去除前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 先将bands元素中开头为a|the|an的去掉前缀，返回新的bands</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newBands</span>(<span class="hljs-params">bands</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> bands.map(<span class="hljs-function"><span class="hljs-params">band</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> band.replace(<span class="hljs-regexp">/^(a |the |an )/i</span>,<span class="hljs-string">&#x27;&#x27;</span>).trim();        <br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sortedBands = newBands(bands).sort()<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace">String.prototype.replace()</a></h4><p><strong><code>replace(pattern,replacement)</code></strong> 方法返回一个新字符串，该字符串由<code>replacement</code>替换<strong>部分或所有</strong>的<code>pattern</code>匹配项后的新字符串。</p><p><code>pattern</code>可以是一个字符串或者一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">正则表达式</a>，<code>replacement</code>可以是一个字符串或者一个每次匹配都要调用的回调函数。</p><p>如果<code>pattern</code>是字符串，则仅替换第一个匹配项。</p><p>原字符串不会改变。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">str.<span class="hljs-built_in">replace</span>(regexp|<span class="hljs-type">substr</span>, newSubStr|<span class="hljs-type">function</span>)<br></code></pre></td></tr></table></figure><h4 id="String-prototype-trim"><a href="#String-prototype-trim" class="headerlink" title="String.prototype.trim()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/Trim">String.prototype.trim()</a></h4><p>从一个字符串的两端删除<strong>所有</strong>空白字符。</p><h4 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">Array.prototype.sort()</a></h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">arr<span class="hljs-selector-class">.sort</span>(<span class="hljs-selector-attr">[compareFunction]</span>)<br></code></pre></td></tr></table></figure><p>主要讲讲有<code>compareFunction</code>的情况，该函数具有两个参数a,b。</p><ul><li><p>如果 <code>compareFunction(a, b)</code> 小于 0 ，那么 a 会被排列到 b 之前；</p></li><li><p>如果 <code>compareFunction(a, b)</code> 等于 0 ， a 和 b 的相对位置不变。</p></li><li><p>如果 <code>compareFunction(a, b)</code> 大于 0 ， b 会被排列到 a 之前。</p></li></ul><p>例如比较数字，<code>compareFunction</code>函数可以简单的以 a 减 b，如下的函数将会将数组升序排列</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">compareNumbers</span>(a, b) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">a</span> - b;<br>&#125;<br>// 也可以这样些<br><span class="hljs-keyword">function</span> <span class="hljs-title">compareNumbers</span>(a, b) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">a</span> &gt; b ? <span class="hljs-number">1</span> : -1;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="正则表达式的特殊字符"><a href="#正则表达式的特殊字符" class="headerlink" title="正则表达式的特殊字符 ^"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>的特殊字符 ^</h4><p>匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。</p><p>例如，<code>/^A/</code> 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。</p><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ol><li><a href="https://www.cnblogs.com/louby/p/4882148.html">正则表达式中的特殊字符</a></li></ol><blockquote><p>JS30的第17个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#49;&#x38;&#48;&#x33;&#x31;&#x30;&#x35;&#53;&#51;&#56;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;">&#49;&#x38;&#48;&#x33;&#x31;&#x30;&#x35;&#53;&#51;&#56;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Mouse Move Shadow 16</title>
    <link href="/myblog.github.io/2022/02/10/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Mouse-Move-Shadow-16/"/>
    <url>/myblog.github.io/2022/02/10/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Mouse-Move-Shadow-16/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第16天的“文字阴影随鼠标移动”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>网页效果： <a href="https://janice143.github.io/mouseMoveShadow/">https://janice143.github.io/mouseMoveShadow/</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_MouseMoveShadow16.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目实现的是一个文字阴影随鼠标位置移动的特效。其中文字阴影是通过添加CSS的text-shadow属性实现的，为了让文字阴影随鼠标位置移动，需要获取当前鼠标的位置，通过一些转化变成对应的文字阴影位置。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><p>CSS的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow">text-shadow</a>属性</p><ul><li><code>text-shadow: 10px 10px 0 rgba(0,0,0,1), 10px 20px 0 rgba(200,0,0,1);</code></li></ul></li><li><p>HTMLElement的一些只读属性</p><ul><li><code>offsetWidth</code></li><li><code>offsetHeight</code></li><li><code>offsetLeft</code></li><li><code>offsetTop</code></li></ul></li><li><p>鼠标事件的一些属性</p><ul><li><code>offsetX</code></li><li><code>offsetY</code></li></ul></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><ul><li>类名为hero的div元素<ul><li>h1标签，加了<code>contenteditable</code>属性，表示浏览网页的用户可以编辑</li></ul></li></ul><h4 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h4><ul><li><p>让网页主题内容水平、垂直居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: flex;<br><span class="hljs-attribute">justify-content</span>: center;<br><span class="hljs-attribute">align-items</span>: center;<br></code></pre></td></tr></table></figure></li><li><p>让文字具有阴影（后面再JS中会修改）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">0</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">/* text-shadow: 10px 10px 0 rgba(0,0,0,1), 10px 20px 0 rgba(200,0,0,1); */</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><ul><li><p>首先创建三个变量，一个指向类名为<code>hero</code>的元素，一个指向<code>h1</code>元素，最后一个变量<code>walk</code>用来存储文字阴影距离原文字最大距离的一半。</p></li><li><p>监听<code>hero</code>上的<code>mouseover</code>的事件，回调函数为<code>shadow</code></p></li><li><p>回调函数要实现的是，获取鼠标移动事件的位置<code>offsetX</code>和<code>offsetY</code>，通过一些公式将这两个位置变成新的位置信息，然后修改CSS样式上的text-shadow属性。</p><ul><li><p>首先设置变量<code>width</code>和<code>height</code>存储hero元素的宽高信息</p></li><li><p>设置变量<code>x</code>和<code>y</code>存储鼠标移动事件的位置信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">offsetWidth</span>: width, <span class="hljs-attr">offsetHeight</span>: height &#125; = hero;<br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">offsetX</span>: x, <span class="hljs-attr">offsetY</span>: y &#125; = e;<br></code></pre></td></tr></table></figure><p>这里的写法采用了ES6的**<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值写法</a>**，语句<code>let &#123; offsetX: x, offsetY: y &#125; = e;</code>等同于<code>let x = e.offsetX; let y = e.offsetY;</code></p><p><code>offsetX/offsetY</code>：鼠标位置（相对于最近父元素的坐标）</p><p><code>offsetWidth/offsetHeight</code>：元素的宽高（width+padding+border）</p></li><li><p>转换的公式如下所示，其中x/width是一个比例系数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xWalk = <span class="hljs-built_in">Math</span>.round((x / width * walk) - (walk / <span class="hljs-number">2</span>));<br><span class="hljs-keyword">const</span> yWalk = <span class="hljs-built_in">Math</span>.round((y / height * walk) - (walk / <span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure></li><li><p>利用JS修改CSS中的text-shadow属性，具体来说有四个文字阴影，分布在text的四个角落</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">text.style.textShadow = <span class="hljs-string">`</span><br><span class="hljs-string"><span class="hljs-subst">$&#123;xWalk&#125;</span>px <span class="hljs-subst">$&#123;yWalk&#125;</span>px 0 rgba(255,0,255,0.7),</span><br><span class="hljs-string"><span class="hljs-subst">$&#123;xWalk * -<span class="hljs-number">1</span>&#125;</span>px <span class="hljs-subst">$&#123;yWalk&#125;</span>px 0 rgba(0,255,255,0.7),</span><br><span class="hljs-string"><span class="hljs-subst">$&#123;yWalk&#125;</span>px <span class="hljs-subst">$&#123;xWalk * -<span class="hljs-number">1</span>&#125;</span>px 0 rgba(0,255,0,0.7),</span><br><span class="hljs-string"><span class="hljs-subst">$&#123;yWalk * -<span class="hljs-number">1</span>&#125;</span>px <span class="hljs-subst">$&#123;xWalk&#125;</span>px 0 rgba(0,0,255,0.7)</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>程序写到这里会出现一个bug，当鼠标移动到h1时，文字阴影没有在文字中聚焦，这是因为鼠标移动到h1时，<code>offsetX</code>表示的是相对于h1的位置；当鼠标移动在hero上时，<code>offsetX</code>表示的是相对于hero的位置。</p><p>所以还需要添加在shadow函数中，首先需要做个<strong>条件判断</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> !== e.target) &#123;<br>    x = x + e.target.offsetLeft;<br>    y = y + e.target.offsetTop;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>写到这里程序就大体完成啦！具体代码我放在了<a href="https://github.com/janice143/mouseMoveShadow">github</a>上。</p></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="JavaScript中event-target与this区别"><a href="#JavaScript中event-target与this区别" class="headerlink" title="JavaScript中event.target与this区别"></a><a href="https://segmentfault.com/a/1190000023596603#:~:text=%E6%80%BB%E7%BB%93%EF%BC%9Athis%E4%B8%8Eevent.target,%E8%AF%A5%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%E3%80%82">JavaScript中event.target与this区别</a></h4><p><code>this</code>一直指向函数的调用者，在本程序中，鼠标无论移动到<code>hero</code>上还是<code>h1</code>上，console.log(this)显示的一直是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hero&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">contenteditable</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-shadow: rgba(255, 0, 255, 0.7) 241px 101px 0px, rgba(0, 255, 255, 0.7) -241px 101px 0px, rgba(0, 255, 0, 0.7) 101px -241px 0px, rgba(0, 0, 255, 0.7) -101px 241px 0px;&quot;</span>&gt;</span>🔥WOAH!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而<code>event.target</code>指向的是触发该事件的目标节点，在本程序中，鼠标移动到<code>hero</code>上，显示内容和上述一样，但是移动到<code>h1</code>上时，显示内容为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">contenteditable</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-shadow: rgba(255, 0, 255, 0.7) 241px 101px 0px, rgba(0, 255, 255, 0.7) -241px 101px 0px, rgba(0, 255, 0, 0.7) 101px -241px 0px, rgba(0, 0, 255, 0.7) -101px 241px 0px;&quot;</span>&gt;</span>🔥WOAH!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>因此，<strong>this与event.target的区别为当含有事件冒泡时，this一直指向该函数的调用者，而event.target则指向触发该事件的目标节点</strong></p><h4 id="ES6-解构赋值"><a href="#ES6-解构赋值" class="headerlink" title="ES6 解构赋值"></a>ES6 解构赋值</h4><p><strong>解构赋值</strong>语法是一种 Javascript 表达式。通过<strong>解构赋值,</strong> 可以将属性/值从对象/数组中取出,赋值给其他变量。</p><p>以前，为变量赋值，只能直接指定值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>ES6允许写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>上述为数组赋值。</p><p>对于对象赋值，可以写成在这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;bbb&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><p>如果变量名与属性名不一致，必须写成下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-attr">last</span>: <span class="hljs-string">&#x27;world&#x27;</span> &#125;;<br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">first</span>: f, <span class="hljs-attr">last</span>: l &#125; = obj;<br>f <span class="hljs-comment">// &#x27;hello&#x27;</span><br>l <span class="hljs-comment">// &#x27;world&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ol><li><a href="http://caibaojian.com/es6/destructuring.html">ES6 变量的解构赋值</a></li><li><a href="https://segmentfault.com/a/1190000023596603#:~:text=%E6%80%BB%E7%BB%93%EF%BC%9Athis%E4%B8%8Eevent.target,%E8%AF%A5%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%E3%80%82">JavaScript中event.target与this区别</a></li></ol><blockquote><p>JS30的第16个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#49;&#x38;&#x30;&#51;&#x31;&#48;&#x35;&#x35;&#x33;&#56;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#49;&#x38;&#x30;&#51;&#x31;&#48;&#x35;&#x35;&#x33;&#56;&#x40;&#113;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Local storage 15</title>
    <link href="/myblog.github.io/2022/02/04/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Local-storage-15/"/>
    <url>/myblog.github.io/2022/02/04/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Local-storage-15/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第15天的“JS window属性： localStorage ”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>网页效果： <a href="https://janice143.github.io/localStorage/">https://janice143.github.io/localStorage/</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_LocalStorage15.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目是一个可添加项目的点菜清单，刷新网页时，菜单信息不会清空。实现该功能的主要技术是JavaScript Window 对象的localStorage属性。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage">localStorage</a></p><ul><li><code>localStorage.setItem</code></li><li><code>localStorage.getItem</code></li></ul></li><li><p>JS取消默认行为</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault">event.preventDefault</a></li></ul></li><li><p>reset() 方法</p><ul><li>把表单中的元素重置为默认值</li></ul></li><li><p>JSON 的方法</p><ul><li><code>JSON.stringify</code></li><li><code>JSON.parse</code></li></ul></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h4><ul><li><p>网页logo</p><ul><li><code>&lt;svg&gt;</code>标签</li></ul></li><li><p>菜品清单内容</p><ul><li><p>标题<code>&lt;h2&gt;</code></p></li><li><p>菜单项目<code>&lt;ul&gt;</code></p></li><li><p>添加菜品表单<code>&lt;form&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>LOCAL TAPAS<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;plates&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Loading Tapas...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;add-items&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Item Name&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;+ Add Item&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h4><ul><li><p>菜品项目添加后默认复选框⬜️没有checked</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">input</span> + <span class="hljs-selector-tag">label</span>:before &#123;<br>content: <span class="hljs-string">&quot;⬜️&quot;</span>;<br><span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>菜品项目checked后方框变成其他图标</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.plates</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:checked</span> + <span class="hljs-selector-tag">label</span>:before &#123;<br>content: <span class="hljs-string">&quot;🌮&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><ul><li><p>form表单中若有type 属性是 “submit”的元素，则具有<code>submit</code> 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addItem</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;<br>addItems.addEventListener(<span class="hljs-string">&#x27;submit&#x27;</span>, addItem);<br></code></pre></td></tr></table></figure></li><li><p>当点击form中的提交按钮时，会提交表单并且刷新页面（可在控制台中看出闪现hello），这种默认行为可以通过 e.preventDefault来阻止</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addItem</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    e.preventDefault();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>下面开始正式编写addItem函数，用来获取form中添加的元素，然后放到items变量中存储起来</p><ul><li><code>this.querySelector(&#39;[name=item]&#39;)</code>选择type为text元素的值（输入框输入的内容）</li><li>构造一个对象 item 来存储这个信息</li><li>把item push到提前创建的items（所有菜单）中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> text = (<span class="hljs-built_in">this</span>.querySelector(<span class="hljs-string">&#x27;[name=item]&#x27;</span>)).value;<br><span class="hljs-comment">// 构造一个对象 item 来存储这个信息</span><br>item = &#123;<br>    text, <span class="hljs-comment">// ES6中对 text: text, 的简写</span><br>    <span class="hljs-attr">done</span>:<span class="hljs-literal">false</span> <span class="hljs-comment">// 标记有没有checked</span><br>&#125;<br>items.push(item);<br></code></pre></td></tr></table></figure><ul><li>执行populateList(items, itemsList)函数，把新添加的菜品显示到页面中</li><li>更新localStorage中的items数据</li><li>重置输入框的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">populateList(items, itemsList);<br><span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;items&#x27;</span>, <span class="hljs-built_in">JSON</span>.stringify(items));<br><span class="hljs-built_in">this</span>.reset();<br></code></pre></td></tr></table></figure></li><li><p> 编写populateList函数，实现将items中的信息挂载到DOM树上</p></li><li><p><code>&lt;input&gt;</code>标签实现的复选框</p><ul><li><code>data-index</code>属性标记菜品序号</li></ul></li><li><p><code>&lt;label&gt;</code>标签记录菜单的文字</p></li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">populateList</span>(<span class="hljs-params">plates = [], platesList</span>) </span>&#123;<br>    platesList.innerHTML = plates.map(<span class="hljs-function">(<span class="hljs-params">plate, i</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;li&gt;</span><br><span class="hljs-string">          &lt;input type=&quot;checkbox&quot; data-index=<span class="hljs-subst">$&#123;i&#125;</span> id=&quot;item<span class="hljs-subst">$&#123;i&#125;</span>&quot; <span class="hljs-subst">$&#123;plate.done ? <span class="hljs-string">&#x27;checked&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>&#125;</span> /&gt;</span><br><span class="hljs-string">          &lt;label for=&quot;item<span class="hljs-subst">$&#123;i&#125;</span>&quot;&gt;<span class="hljs-subst">$&#123;plate.text&#125;</span>&lt;/label&gt;</span><br><span class="hljs-string">        &lt;/li&gt;</span><br><span class="hljs-string">      `</span>;<br>    &#125;).join(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>程序写到这里基本完成，但是仔细观察会发现，如果checked每个菜品，刷新页面后，这个状态会被刷新（不被保留），这是因为我们并没有更新items中done的值</p></li><li><p>所以还需编写toggleDone函数，通过菜品click事件触发</p><ul><li><code>e.target.dataset.index</code>可以获取利用<code>data-index</code>属性标记菜品序号</li><li><code>!items[index].done</code>否操作</li><li>更新localStorage和HTML页面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleDone</span>(<span class="hljs-params">e</span>) </span>&#123; <br>    <span class="hljs-keyword">if</span> (!e.target.matches(<span class="hljs-string">&#x27;input&#x27;</span>)) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// skip this unless it&#x27;s an input</span><br>    <span class="hljs-comment">// console.log(e.target)</span><br>    <span class="hljs-keyword">const</span> el = e.target;<br>    <span class="hljs-keyword">const</span> index = el.dataset.index;<br>    items[index].done = !items[index].done;<br>    <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;items&#x27;</span>, <span class="hljs-built_in">JSON</span>.stringify(items));<br>    populateList(items, itemsList);<br>  &#125;<br>itemsList.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, toggleDone);<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="HTML-lt-input-gt-标签的-required-属性"><a href="#HTML-lt-input-gt-标签的-required-属性" class="headerlink" title="HTML &lt;input&gt; 标签的 required 属性"></a>HTML <code>&lt;input&gt; </code>标签的 required 属性</h4><p>required 属性规定必需在提交之前填写输入字段</p><h4 id="JS-preventDefault-取消默认行为"><a href="#JS-preventDefault-取消默认行为" class="headerlink" title="JS-preventDefault() 取消默认行为"></a>JS-preventDefault() 取消默认行为</h4><p>语法：<code>event.preventDefault()</code></p><p>该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。</p><p>常用情景：</p><ul><li>如果 type 属性是 “submit”，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。</li><li><button>标签在form表单中时，click事件默认会提交表单刷新页面，调用可方法，可避免刷新页面</li><li>a 标签点击时，会跳转url，采用如下方式，可防止链接打开 URL：</li></ul><blockquote><p>常用情景的知识点来源于<a href="https://blog.csdn.net/hsany330/article/details/105049740">博客</a></p></blockquote><h4 id="JSON-parse和JSON-stringify"><a href="#JSON-parse和JSON-stringify" class="headerlink" title="JSON.parse和JSON.stringify"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a></h4><p>JSON对象在所有现代浏览器中都适用，他有两个非常有用的方法是parse()和stringify().</p><ul><li><code>JSON.parse()</code> 把一个JSON字符串转变成JS对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> userStr = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;&#125;&#x27;</span>;<br><span class="hljs-keyword">let</span> userObj = <span class="hljs-built_in">JSON</span>.parse(userStr);<br><span class="hljs-built_in">console</span>.log(userObj);<br><span class="hljs-comment">// &#123;name: &#x27;Sammy&#x27;, email: &#x27;sammy@example.com&#x27;, plan: &#x27;Pro&#x27;&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>JSON.parse()</code> 第二个参数可以是一个自定义函数，具有返回值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> userStr = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;&#125;&#x27;</span>;<br><span class="hljs-keyword">let</span> userObj = <span class="hljs-built_in">JSON</span>.parse(userStr, <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> value.toUpperCase();<br>  &#125;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(userObj);<br><span class="hljs-comment">// &#123;name: &#x27;SAMMY&#x27;, email: &#x27;SAMMY@EXAMPLE.COM&#x27;, plan: &#x27;PRO&#x27;&#125;</span><br></code></pre></td></tr></table></figure><ul><li><code>JSON.stringify()</code> 把一个JS对象转变成JSON字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> userObj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sammy&quot;</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;sammy@example.com&quot;</span>,<br>  <span class="hljs-attr">plan</span>: <span class="hljs-string">&quot;Pro&quot;</span><br>&#125;;<br><span class="hljs-keyword">let</span> userStr = <span class="hljs-built_in">JSON</span>.stringify(userObj);<br><span class="hljs-built_in">console</span>.log(userStr);<br><span class="hljs-comment">// &#123;&quot;name&quot;:&quot;Sammy&quot;,&quot;email&quot;:&quot;sammy@example.com&quot;,&quot;plan&quot;:&quot;Pro&quot;&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>JSON.stringify()可以有两个额外参数</p><ul><li>一个replacer参数（是一个自定义函数，函数名为replacer)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> userObj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sammy&quot;</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;sammy@example.com&quot;</span>,<br>  <span class="hljs-attr">plan</span>: <span class="hljs-string">&quot;Pro&quot;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> value);<br>  <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;email&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-keyword">let</span> userStrReplacer = <span class="hljs-built_in">JSON</span>.stringify(userObj, replacer);<br><span class="hljs-built_in">console</span>.log(userStrReplacer);<br><span class="hljs-comment">// &#123;&quot;name&quot;:&quot;Sammy&quot;,&quot;plan&quot;:&quot;Pro&quot;&#125;</span><br></code></pre></td></tr></table></figure><ul><li>一个是space参数（是 <code>String</code> 或者 <code>Number</code> 值），用来控制间距<ul><li>如果是Number，缩进为空格数(1-10)</li><li>如果是String，缩进为该字符串</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">uno</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">dos</span>: <span class="hljs-number">2</span> &#125;, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;\t&#x27;</span>);<br><span class="hljs-comment">// returns the string:</span><br><span class="hljs-comment">// &#x27;&#123;</span><br><span class="hljs-comment">//     &quot;uno&quot;: 1,</span><br><span class="hljs-comment">//     &quot;dos&quot;: 2</span><br><span class="hljs-comment">// &#125;&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="map-和forEach-的区别和理解"><a href="#map-和forEach-的区别和理解" class="headerlink" title="map()和forEach()的区别和理解"></a>map()和forEach()的区别和理解</h4><p>两个方法都可以实现元素遍历，但是map方法可以用返回值，而forEach方法没有返回值</p><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ol><li><a href="https://blog.csdn.net/hsany330/article/details/105049740">JS-preventDefault() 取消默认行为</a></li><li><a href="https://www.digitalocean.com/community/tutorials/js-json-parse-stringify">How To Use JSON.parse() and JSON.stringify()</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#example_of_using_json.stringify_with_localstorage">Example of using JSON.stringify() with localStorage</a></li><li><a href="https://blog.csdn.net/suwu150/article/details/111590409#:~:text=forEach()%E6%96%B9%E6%B3%95%E4%B8%8D%E4%BC%9A,%E6%89%A7%E8%A1%8C%E6%97%B6%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%EF%BC%89%E3%80%82">map()和forEach()的区别和理解</a></li></ol><blockquote><p>JS30的第15个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#56;&#x30;&#51;&#x31;&#48;&#x35;&#53;&#x33;&#56;&#x40;&#113;&#x71;&#46;&#99;&#111;&#x6d;">&#x31;&#56;&#x30;&#51;&#x31;&#48;&#x35;&#53;&#x33;&#56;&#x40;&#113;&#x71;&#46;&#99;&#111;&#x6d;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Reference VS copy 14</title>
    <link href="/myblog.github.io/2022/01/31/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Reference-VS-copy-14/"/>
    <url>/myblog.github.io/2022/01/31/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Reference-VS-copy-14/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第14天的“JS中引用和复制区别”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目主要是在javascript中对比引用和复制变量的区别，效果在console（控制台）中显示。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><p>对于基础类型的值，存储的是值</p><ul><li>number</li><li>string</li><li>boolean</li></ul></li><li><p>对于复杂类型的值，存储的是引用（指针）</p><ul><li>arr</li><li>object</li><li>regx</li></ul></li><li><p>对于复杂类型的值，如果实现复制</p><ul><li>arr<ul><li>Array.prototype.slice()</li><li>Array.prototype.concat()</li><li> ES6 扩展语法</li><li>Array.from()</li></ul></li><li>对象<ul><li>Object.assign()</li><li>JSON 转换</li></ul></li></ul></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><ul><li>首先从 String、Number、Boolean 类型的值开始。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">let</span> age2 = age;<br><span class="hljs-built_in">console</span>.log(age, age2); <span class="hljs-comment">// 100 100</span><br>age = <span class="hljs-number">200</span>;<br><span class="hljs-built_in">console</span>.log(age, age2); <span class="hljs-comment">// 200 100</span><br></code></pre></td></tr></table></figure><p>改动age不会影响age2。</p><ul><li>对于数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> players = [<span class="hljs-string">&#x27;Wes&#x27;</span>, <span class="hljs-string">&#x27;Sarah&#x27;</span>, <span class="hljs-string">&#x27;Ryan&#x27;</span>, <span class="hljs-string">&#x27;Poppy&#x27;</span>];<br><span class="hljs-keyword">const</span> team = players;<br><span class="hljs-built_in">console</span>.log(players, team);<br>team[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;Lux&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(players, team); <br><span class="hljs-comment">// [&quot;Wes&quot;, &quot;Sarah&quot;, &quot;Ryan&quot;, &quot;Lux&quot;] [&quot;Wes&quot;, &quot;Sarah&quot;, &quot;Ryan&quot;, &quot;Lux&quot;]</span><br></code></pre></td></tr></table></figure><p> 对数组进行和Number类型相同的复制操作，发现改动team会改变players。</p><p><strong>结论</strong>：基础类型（number,string,boolean）将内容直接存储在<strong>栈</strong>中（大小固定位置连续的存储空间），记录的是该数据类型的值，即直接访问，基础类型赋值是复制（copy）； </p><p>复杂类型（object即广义的对象类型（arr,object,regx））将内容存储在堆中，堆所对应的栈中记录的是<strong>指针</strong>（堆的地址），外部访问时先引出地址，再通过地址去找到值所存放的位置。复杂类型赋值是地址引用。</p><ul><li><p>数组的复制</p><ul><li>方法一 Array.prototype.slice()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> team2 = players.slice();<br>team2[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;Lux2&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(players, team2);<br></code></pre></td></tr></table></figure><ul><li>方法二 Array.prototype.concat()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> team3 = [].concat(players);<br>team3[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;Lux3&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(players, team3); <br></code></pre></td></tr></table></figure><ul><li>方法三 ES6 扩展语法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> team4 = [...players];<br>team4[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;Lux4&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(players, team4);<br></code></pre></td></tr></table></figure><ul><li>方法四 Array.from()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> team5 = <span class="hljs-built_in">Array</span>.from(players);<br>team5[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;Lux5&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(players, team5);<br></code></pre></td></tr></table></figure></li><li><p>对象的复制</p><ul><li><p>方法一 Object.assign()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Wes Bos&#x27;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">80</span><br> &#125;;<br><span class="hljs-keyword">const</span> cap2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, person, &#123; <span class="hljs-attr">number</span>: <span class="hljs-number">99</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span> &#125;);<br><span class="hljs-built_in">console</span>.log(cap2); <span class="hljs-comment">// Object &#123;name: &quot;Wes Bos&quot;, age: 12, number: 99&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>方法二 JSON 转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> wes = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Wes&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">100</span>,<br>  <span class="hljs-attr">social</span>: &#123;<br>    <span class="hljs-attr">twitter</span>: <span class="hljs-string">&#x27;@wesbos&#x27;</span>,<br>    <span class="hljs-attr">facebook</span>: <span class="hljs-string">&#x27;wesbos.developer&#x27;</span><br>  &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> dev = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, wes);<br><span class="hljs-keyword">const</span> dev2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(wes));<br><span class="hljs-built_in">console</span>.log(wes);<br><span class="hljs-built_in">console</span>.log(dev);<br><span class="hljs-built_in">console</span>.log(dev2);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="ES6扩展运算符"><a href="#ES6扩展运算符" class="headerlink" title="ES6扩展运算符"></a>ES6扩展运算符</h4><p>符号：<code>...</code></p><p>作用：将数组或对象进行展开</p><p>例如，对于数组arr=[1,2,3]</p><p>console.log(…arr)相当于for循环把arr中每个元素打印一下。</p><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><p>1 <a href="https://segmentfault.com/a/1190000015411195">js 值引用和值复制</a></p><p>2 <a href="https://zh.javascript.info/object-copy">对象引用和复制</a></p><p>3 <a href="https://segmentfault.com/a/1190000020259974">总结 ES6 扩展运算符（…）</a></p><p>4 <a href="https://github.com/soyaine">未枝丫</a>的<a href="https://github.com/soyaine/JavaScript30/tree/master/14%20-%20JavaScript%20References%20VS%20Copying">JS30博客</a></p><blockquote><p>JS30的第14个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#56;&#x30;&#x33;&#x31;&#48;&#53;&#x35;&#x33;&#x38;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">&#x31;&#56;&#x30;&#x33;&#x31;&#48;&#53;&#x35;&#x33;&#x38;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Slide in on scroll 13</title>
    <link href="/myblog.github.io/2022/01/30/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Slide-in-on-scroll-13/"/>
    <url>/myblog.github.io/2022/01/30/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Slide-in-on-scroll-13/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第13天的“图片随屏幕滚动而滑入滑出”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>网页效果： <a href="https://janice143.github.io/sliderIn/">https://janice143.github.io/sliderIn/</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_Slidein13.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>本项目为一个图文浏览网页，其中，当浏览到图片时（屏幕滚动到图片上），图片具有滑入特效，浏览完毕后，图片滑出。滑入滑出特效由css的<code>translateX()</code>实现，触发特效有javascript控制。</p><h4 id="项目重点"><a href="#项目重点" class="headerlink" title="项目重点"></a>项目重点</h4><ul><li><p>window的scroll事件</p><ul><li><code>window.addEventListener(&#39;scroll&#39;)</code></li></ul></li><li><p>一些位置（像素值）</p><ul><li><code>window.scrollY</code>  文档当前垂直滚动的像素数</li><li> <code>window.innerHeight</code> viewport部分的高度</li><li><code>sliderImage.offsetTop</code> 当前元素顶部相对于其 offsetParent 元素的顶部的距离</li><li><a href="https://github.com/soyaine/JavaScript30/tree/master/13%20-%20Slide%20in%20on%20Scroll">未枝丫博客有图解</a></li></ul></li><li><p><code>debounce</code> 的作用（函数防抖）</p><ul><li> 降低事件监听的频率，使用了 Lodash 中的 debounce 方法</li></ul></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h4><ol><li><code>p</code>标签的文字</li><li><code>img</code>标签的图片</li></ol><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><ul><li>监听window的scroll事件</li><li>触发<code>checkSlide</code>函数<ul><li>图片滑入条件：屏幕滚动位置以及屏幕高度之和 &gt; 图片顶部距离页面距离以及图片半高；屏幕滚动位置 &lt; 图片底部距离</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> slideInAt = (<span class="hljs-built_in">window</span>.scrollY + <span class="hljs-built_in">window</span>.innerHeight);<br><span class="hljs-keyword">const</span> imageBottom = sliderImage.offsetTop + sliderImage.height;<br><span class="hljs-keyword">const</span> isHalfShown = slideInAt &gt; (sliderImage.offsetTop + sliderImage.height / <span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> isNotScrolledPast = <span class="hljs-built_in">window</span>.scrollY &lt; imageBottom;<br></code></pre></td></tr></table></figure><ul><li><p>函数防抖</p><p>由于每次滚动都触发监听事件，会降低 JavaScript 运行性能，所以用 <code>debounce</code> 函数来降低触发的次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait = <span class="hljs-number">20</span>, immediate = <span class="hljs-literal">true</span></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timeout;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>, args = <span class="hljs-built_in">arguments</span>;<br>        <span class="hljs-keyword">var</span> later = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            timeout = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (!immediate) func.apply(context, args);<br>        &#125;;<br>        <span class="hljs-keyword">var</span> callNow = immediate &amp;&amp; !timeout;<br>        <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        timeout = <span class="hljs-built_in">setTimeout</span>(later, wait);<br>        <span class="hljs-keyword">if</span> (callNow) func.apply(context, args);<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h4><ul><li>屏幕滚动之前，图片的状态是：不透明度为0（隐藏），x方向偏移30%（相对于图片大小），缩放95%。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.align-right</span><span class="hljs-selector-class">.slide-in</span> &#123;<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">30%</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.95</span>);<br>&#125;<br><span class="hljs-selector-class">.slide-in</span><span class="hljs-selector-class">.active</span> &#123;<br><span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0%</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>触发特效，图片的状态是：不透明度为1，x方向偏移0%（相对于图片大小），缩放1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.slide-in</span><span class="hljs-selector-class">.active</span> &#123;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0%</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="项目补充"><a href="#项目补充" class="headerlink" title="项目补充"></a>项目补充</h2><h4 id="元素浮动"><a href="#元素浮动" class="headerlink" title="元素浮动"></a>元素浮动</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>能够实现让多个元素排在问一行,并且给这些元素设置宽度与高度。</p><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>在标准文档流中的元素只有两种：块级元素和行内元素。让多个元素排在同一行：行内元素的特性；给这些元素设置宽高:块级元素的特性。如果想让一些元素既要有块级元素的特点也要有行内元素的特点，只能让这些元素脱离标准文档流（脱标），浮动可以让元素脱离标准文档流，可以实现让多个元素排在同一行并且可以设置宽高。</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>浮动通过浮动属性来实现，<code>float</code>这个属性有两个值left向左浮动，向左移动、right向右浮动，向右移动。</p><h5 id="浮动元素的特性"><a href="#浮动元素的特性" class="headerlink" title="浮动元素的特性"></a>浮动元素的特性</h5><ul><li><p>浮动元素脱离标准文档流不再占用空间；</p></li><li><p>我们可以把浮动元素理解为“漂”</p></li><li><p>浮动元素的层级比标准文档流里面的元素层级要高,会将标准文档流中的元素给压盖住</p></li><li><p>行内素浮动后，变成块状元素</p></li></ul><h5 id="清除浮动：只要有浮动那么必须有清除浮动"><a href="#清除浮动：只要有浮动那么必须有清除浮动" class="headerlink" title="清除浮动：只要有浮动那么必须有清除浮动"></a>清除浮动：只要有浮动那么必须有清除浮动</h5><p><strong>1</strong> <strong>为什么要清除浮动?</strong></p><p>因为经过浮动元素会影响到下面的元素的排版布局，浮动元素的父元素没有将浮动元素包裹，只要清除了浮动，就不会影响到浮动元素的下面进行排版布局，浮动元素的父元素会将浮动元素从视觉上包裹着。</p><p><strong>2</strong> <strong>清除浮动有以下三种方法:</strong></p><ul><li>给浮动元素的父元素设置一个固定的高度</li><li>使用清除浮动的样式属性 clear.（clear:left清除左浮动, clear: right:;清除右浮动 clear: both两者都清除）,这个属性一般用在最后一个浮动元素的下面,在最后一个浮动元素的下面（不是子级，而是并列下一行）新建一个空白的div,这个div什么内容都不要放,只做一件事件，就是清除浮动</li><li>使用 overflow: hidden这个属性来清除浮动</li></ul><p><strong>注意</strong>*：使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围</p><blockquote><p>JS30的第13个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#x38;&#x30;&#x33;&#x31;&#x30;&#53;&#53;&#x33;&#56;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;">&#x31;&#x38;&#x30;&#x33;&#x31;&#x30;&#53;&#53;&#x33;&#56;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Secret code sequence 12</title>
    <link href="/myblog.github.io/2022/01/20/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Secret-code-sequence-12/"/>
    <url>/myblog.github.io/2022/01/20/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Secret-code-sequence-12/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第12天的“字符序列检测”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>网页效果： <a href="https://janice143.github.io/secretCode/">https://janice143.github.io/secretCode/</a></p><p>键盘输入 <strong><u>happy 2022</u></strong> 即可触发彩蛋。</p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>通过判断键盘输入的字符串中是否含有指定字符串序列，开启网页中的隐藏彩蛋。本项目的彩蛋是</p><p>从网页 <a href="https://www.cornify.com/">Cornify.com</a> 中加载一个 JS 文件，调用其中的 <code>cornify_add()</code> 方法时，随机在页面出加载独角兽的图标和<code>p</code>标签。</p><p>项目重点</p><ul><li><p>window的keyup事件</p><ul><li><code>window.addEventListener(&#39;keyup&#39;,)</code></li><li><code>e.key</code></li></ul></li><li><p>数组操作</p><ul><li><code>.push()</code></li><li><code>.splice()</code></li><li><code>.length</code></li><li><code>.join()</code></li><li><code>.includes()</code></li></ul></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h4><ol><li><code>p</code>标签标记一段提示的文字</li></ol><h4 id="Js部分"><a href="#Js部分" class="headerlink" title="Js部分"></a>Js部分</h4><ul><li><p>声明一个变量用来存储按下的字符串序列数组</p></li><li><p>声明一个变量用来存储已知的指定字符串序列</p></li><li><p>window的键盘监听事件</p><ul><li>将字符串指定规则切分</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pressCode.splice(-secretCode.length - <span class="hljs-number">1</span>, pressCode.length - secretCode.length)<br></code></pre></td></tr></table></figure></li><li><p>判断是否包含指定字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (pressCode.join(<span class="hljs-string">&#x27;&#x27;</span>).includes(secretCode))&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>随机在页面中加载独角兽图标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cornify_add();<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目知识点"><a href="#项目知识点" class="headerlink" title="项目知识点"></a>项目知识点</h2><h4 id="js中的splice方法的使用说明"><a href="#js中的splice方法的使用说明" class="headerlink" title="js中的splice方法的使用说明"></a>js中的splice方法的使用说明</h4><p>splice方法可以用来对js的数组进行删除，添加，替换等操作。</p><ol><li> 删除。第一个参数为起始位置（如果为负数，表示倒数），第二个参数为要删除几个。</li></ol><p>   <code>array.splice(index,num)</code></p><ol start="2"><li> 插入。第一个参数（插入位置），第二个参数（0），第三个参数（插入的项）。</li></ol><p>   <code>array.splice(index,0,insertValue)</code></p><ol start="3"><li><p>替换。第一个参数（起始位置），第二参数（删除项数），第三参数（插入任意数量的项）。</p><p><code>array.splice(index,num,insertValue)</code></p></li></ol><blockquote><p>JS30的第12个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#49;&#x38;&#48;&#x33;&#x31;&#x30;&#53;&#53;&#51;&#56;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;">&#49;&#x38;&#48;&#x33;&#x31;&#x30;&#53;&#53;&#51;&#56;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Video player 11</title>
    <link href="/myblog.github.io/2022/01/18/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Video-player-11/"/>
    <url>/myblog.github.io/2022/01/18/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Video-player-11/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第11天的“自定义视频播放器”项目。Have fun with the website! ♪(^∇^*)</p></blockquote><p>网页效果： <a href="https://janice143.github.io/videoPlayer/">https://janice143.github.io/videoPlayer/</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_VideoPlayer11.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>利用video标签，以及一些div标签，在js中设置视频的播放控件，包括<strong>暂停/播放</strong>，<strong>声音调节</strong>，<strong>视频进度调节</strong>，<strong>视频播放率</strong>，<strong>跳过/退后</strong>。</p><p>项目重点</p><ul><li><p><a href="https://www.w3school.com.cn/jsref/dom_obj_video.asp">video对象的各种属性、方法和事件</a></p><ul><li><code>paused</code></li><li><code>play()</code></li><li><code>pause()</code></li><li><code>currentTime</code></li><li><code>volume</code></li><li><code>playbackRate</code></li></ul></li><li><p>HTML DOM offsetWidth 属性</p><ul><li>获取元素的宽度，包含内边距（padding）和边框（border）:</li></ul></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/data-*">HTML5 data-* 自定义属性</a></p><ul><li>this.dataset.</li><li>data-</li></ul></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h4><ol><li><code>video</code>标签标记视频文件</li><li><code>div</code>标签和<code>button</code>标签实现的一些视频控件，类名为.controlers<ul><li>.progress进度条，.progress_filled进度条填充颜色</li><li>.player_button播放按钮</li><li>声音滑块</li><li>播放速度滑块</li><li>前进/后退按钮</li></ul></li></ol><h4 id="Js部分"><a href="#Js部分" class="headerlink" title="Js部分"></a>Js部分</h4><ul><li><p>获取标签</p></li><li><p>编写自定义函数</p><ul><li><p>播放按键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> method = video.paused ? <span class="hljs-string">&#x27;play&#x27;</span> : <span class="hljs-string">&#x27;pause&#x27;</span>;<br>video[method]();<br></code></pre></td></tr></table></figure></li><li><p>更新播放键的按键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> icon = <span class="hljs-built_in">this</span>.paused ? <span class="hljs-string">&#x27;►&#x27;</span> : <span class="hljs-string">&#x27;❚ ❚&#x27;</span>;<br>toggle.textContent = icon;<br></code></pre></td></tr></table></figure></li><li><p>前进/后退</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">video.currentTime += <span class="hljs-built_in">parseFloat</span>(<span class="hljs-built_in">this</span>.dataset.skip);<br></code></pre></td></tr></table></figure></li><li><p>更新滑块的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">video[<span class="hljs-built_in">this</span>.name] = <span class="hljs-built_in">this</span>.value;<br></code></pre></td></tr></table></figure></li><li><p>更新进度条（填充颜色）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> percent = (video.currentTime / video.duration) * <span class="hljs-number">100</span>;<br>progressBar.style.flexBasis = <span class="hljs-string">`<span class="hljs-subst">$&#123;percent&#125;</span>%`</span>;<br></code></pre></td></tr></table></figure></li><li><p>鼠标移动进度条</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> scrubTime = (e.offsetX / progress.offsetWidth) * video.duration;<br>video.currentTime = scrubTime;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>添加监听事件</p><ul><li>视频的click,play,pause,timeupdata事件</li><li>播放按钮、前进后退按钮的click事件</li><li>滑块的change,mousemove事件</li><li>进度条的click,mousemove,mousedown,mouseup事件</li></ul></li></ul><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><ul><li><p>flex容器的项目属性</p><ul><li> <code>flex-basis</code>：项目占据的主轴空间（main size）</li><li> <code>flex</code></li></ul></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">属性选择器</a></p><ul><li> input[type=range]</li></ul></li></ul><h2 id="项目知识点"><a href="#项目知识点" class="headerlink" title="项目知识点"></a>项目知识点</h2><h4 id="data"><a href="#data" class="headerlink" title="data-*"></a><a href="https://juejin.cn/post/6844904039407157262">data-*</a></h4><p>自定义数据属性，可通过所属元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement"><code>HTMLElement</code></a> 接口访问，确切地说是<code>HTMLElement.dataset</code> ， <code>HTMLElement.dataset[&quot;testValue&quot;]</code> 属性访问。</p><p>注*：data-后面的命名规则</p><ul><li>该名称不能以<code>xml</code>开头，无论这些字母是大写还是小写；</li><li>该名称不能包含任何分号；</li><li>该名称不能包含A至Z的大写字母</li><li>data后面的命名中有-，如 <em>data-test-value</em> ，可通过 <code>HTMLElement.dataset.testValue</code> ( 或者是<code>HTMLElement.dataset[&quot;testValue&quot;]</code>) 来访问，任何短线符号都会被下个字母的大写替代(驼峰拼写)。</li></ul><blockquote><p>JS30的第11个项目圆满完成啦，感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#x38;&#x30;&#51;&#49;&#x30;&#x35;&#x35;&#x33;&#x38;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;">&#x31;&#x38;&#x30;&#51;&#49;&#x30;&#x35;&#x35;&#x33;&#x38;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Go list 10</title>
    <link href="/myblog.github.io/2022/01/09/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Go-list-10/"/>
    <url>/myblog.github.io/2022/01/09/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Go-list-10/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第10天的“待办清单”项目，我增加了 <strong>双击删除任务</strong> 、<strong>添加任务</strong>的功能。Have fun with the website! ♪(^∇^*)</p></blockquote><p>网页效果：<a href="https://janice143.github.io/goList/">https://janice143.github.io/goList/</a></p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_Golist10.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>利用一些 <code>checkbox</code> 类型的 <code>input</code> 元素，通过在js中实现特定功能，而设计的待办清单网页。在网页中，可以通过点击checkbox来<strong>标记</strong>任务状态，通过按住shift键可以对任务实现<strong>多项check</strong>。也可以通过点击添加来<strong>增加</strong>任务，完成的任务可以通过<strong>双击实现删除</strong>。</p><p>项目重点</p><ul><li>类型为checkbox的input元素的点击事件，回调函数为<code>clickCheck</code><ul><li><em>e</em>.shiftKey</li><li>this.checked</li><li>标记上一次点击的input，以及多选内部的Input</li></ul></li><li>类型为text的input元素的change事件，回调函数为<code>displayTask</code><ul><li>使用createElement创建元素</li><li>使用append来在指定结点后添加html</li><li>输入文本回车后情况文本，this.value = ‘’</li><li>监听双击事件，移除任务</li></ul></li><li>checkbox后面的文本双击事件，回调函数为<code>removeTask</code><ul><li><em>e</em>.path[1].remove()</li></ul></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h4><ol><li>输入文本框input</li><li>定位在文本框上的div元素，点击后display: none</li><li>四个类名为task-item是checkbox和任务文本p</li><li>新添任务的占位标签，新添加的任务将会append在这里</li></ol><h4 id="Js部分"><a href="#Js部分" class="headerlink" title="Js部分"></a>Js部分</h4><ul><li>获取类型为checkbox的所有input，遍历点击事件<ul><li>点击事件为<code>clickCheck</code></li><li>多选操作的原理</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(e.shiftKey &amp;&amp; <span class="hljs-built_in">this</span>.checked)<br>    inputChecks.forEach(<span class="hljs-function"><span class="hljs-params">inputCheck</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(inputCheck === <span class="hljs-built_in">this</span> || inputCheck === lastChecked);<br>        <span class="hljs-keyword">if</span> (inputCheck === <span class="hljs-built_in">this</span> || inputCheck === lastChecked) &#123;<br>            inBetween = !inBetween;<br>            <span class="hljs-comment">// console.log(&#x27;Starting to check them in between!&#x27;);</span><br>        &#125;<br>        <span class="hljs-comment">// console.log(&#x27;行内是否&#x27;,inBetween);</span><br>        <span class="hljs-keyword">if</span> (inBetween) &#123;<br>            inputCheck.checked = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure><ul><li>获取所有p元素，遍历双击事件<ul><li>双击事件为<code>removeTask</code></li><li>找到对应的任务路径，remove即可</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeTask</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(e.path[<span class="hljs-number">1</span>].remove());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>获取类名为add-icon的元素，监听点击事件，点击隐藏</p><ul><li><p>使页面元素隐藏和显示可以有两种方式：</p><ul><li>方式1：设置元素style属性中的display</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> t = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>);<span class="hljs-comment">//选取id为test的元素</span><br>t.style.display = <span class="hljs-string">&#x27;none&#x27;</span>;<span class="hljs-comment">// 隐藏选择的元素</span><br>t.style.display = <span class="hljs-string">&#x27;block&#x27;</span>;<span class="hljs-comment">// 以块级样式显示</span><br></code></pre></td></tr></table></figure><ul><li>方式2：设置元素style属性中的visibility</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> t = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>);<br>t.style.visibility = <span class="hljs-string">&#x27;hidden&#x27;</span>;<span class="hljs-comment">// 隐藏元素</span><br>t.style.visibility = <span class="hljs-string">&#x27;visible&#x27;</span>;<span class="hljs-comment">// 显示元素</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p>二者的区别在于设置display隐藏后不占用原来的位置，而visibility隐藏后元素位置任然被占用。</p><ul><li><p>获取类型为text的input元素，监听change事件</p><ul><li>change事件调用<code>displayTask</code></li><li><a href="https://zh.javascript.info/modifying-document">动态插入html</a><ul><li>使用createElement创建元素</li><li>使用append挂载元素</li></ul></li><li>监听双击事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayTask</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 使用createElement创建元素</span><br>    <span class="hljs-keyword">const</span> newTaskItem = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    newTaskItem.className = <span class="hljs-string">&#x27;new-task-item&#x27;</span>;<br>    <span class="hljs-keyword">const</span> html =<br>          <span class="hljs-string">`</span><br><span class="hljs-string">&lt;div class=&quot;task-item&quot;&gt;</span><br><span class="hljs-string">&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="hljs-string">&lt;p&gt;<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.value&#125;</span>&lt;/p&gt;</span><br><span class="hljs-string">&lt;/div&gt;</span><br><span class="hljs-string">`</span>;<br>    newTaskItem.innerHTML = html;<br>    newTask.append(newTaskItem);<br>    <span class="hljs-comment">// console.log(newTask);</span><br>    <span class="hljs-comment">// console.log(html);</span><br>    <span class="hljs-built_in">this</span>.value = <span class="hljs-string">&#x27;&#x27;</span><br>    newTaskItem.addEventListener(<span class="hljs-string">&#x27;dblclick&#x27;</span>,removeTask)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h3><ul><li> <code>:checked</code> 选择器</li><li>紧邻兄弟组合器：A<code>+</code> B 组合器选择相邻元素，即后一个元素B紧跟在前一个A之后，并且共享同一个父节点</li><li>添加删除线  <em>text-decoration</em>: line-through;</li></ul><h2 id="项目知识点"><a href="#项目知识点" class="headerlink" title="项目知识点"></a>项目知识点</h2><h4 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h4><p>DOM为文档对象模型，每个 HTML 标签都是一个对象。</p><p>DOM 将 HTML 表示为标签的树形结构。标签被称为 <strong>元素节点</strong>（或者仅仅是元素），并形成了树状结构：<code>&lt;html&gt;</code> 在根节点，<code>&lt;head&gt;</code> 和 <code>&lt;body&gt;</code> 是其子项，等。元素内的文本形成 <strong>文本节点</strong>，被标记为 <code>＃text</code>。一个文本节点只包含一个字符串。它没有子项，并且总是树的叶子。</p><h4 id="利用JS修改文档"><a href="#利用JS修改文档" class="headerlink" title="利用JS修改文档"></a>利用JS修改文档</h4><ul><li><p>创建一个元素（DOM节点）</p><ul><li><code>document.createElement(tag)</code>创建一个新 <strong>元素节点（element node）</strong></li><li><code>document.createTextNode(text)</code>创建一个 <strong>文本节点</strong></li></ul></li><li><p>创建 <code>div</code> 分为 3 个步骤：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 创建 &lt;div&gt; 元素</span><br><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br><br><span class="hljs-comment">// 2. 将元素的类设置为 &quot;alert&quot;</span><br>div.className = <span class="hljs-string">&quot;alert&quot;</span>;<br><br><span class="hljs-comment">// 3. 填充消息内容</span><br>div.innerHTML = <span class="hljs-string">&quot;&lt;strong&gt;Hi there!&lt;/strong&gt; You&#x27;ve read an important message.&quot;</span>;<br></code></pre></td></tr></table></figure><p>这时已经创建了该元素。但到目前为止，它还只是在一个名为 <code>div</code> 的变量中，尚未在页面中。所以我们无法在页面上看到它。</p><ul><li><p><code>append</code>挂载元素</p><p>为了让 <code>div</code> 显示出来，我们需要将其插入到 <code>document</code> 中的某处。</p><ul><li><code>append</code>：<code>document.body.append(div)</code>。</li><li><code>node.append(...nodes or strings)</code> —— 在 <code>node</code> <strong>末尾</strong> 插入节点或字符串，</li><li><code>node.prepend(...nodes or strings)</code> —— 在 <code>node</code> <strong>开头</strong> 插入节点或字符串，</li><li><code>node.before(...nodes or strings)</code> —— 在 <code>node</code> <strong>前面</strong> 插入节点或字符串，</li><li><code>node.after(...nodes or strings)</code> —— 在 <code>node</code> <strong>后面</strong> 插入节点或字符串，</li><li><code>node.replaceWith(...nodes or strings)</code> —— 将 <code>node</code> 替换为给定的节点或字符串。</li></ul></li></ul><blockquote><p>JS30的第10个项目圆满完成啦，虽然对原项目做了一些改进，但是整体上也实现了一些我自己的独特功能。PS：中间跳了第7和9个项目，如果有时间我后面会补上滴！</p><p>感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#56;&#48;&#x33;&#49;&#48;&#53;&#x35;&#51;&#56;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;">&#x31;&#56;&#48;&#x33;&#49;&#48;&#53;&#x35;&#51;&#56;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Canvas 08</title>
    <link href="/myblog.github.io/2022/01/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Canvas-08/"/>
    <url>/myblog.github.io/2022/01/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Canvas-08/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：<a href="https://courses.wesbos.com/account">30 Day Challenge</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。</p><p>本项目为第8天项目，为了更有挑战性，我实现了 <strong>移动端绘图</strong> 、<strong>画笔样式选择</strong>的功能。Have fun with the website! ♪(^∇^*)</p></blockquote><p>网页效果：<a href="https://janice143.github.io/myCanvas/">https://janice143.github.io/myCanvas/</a> （画了个嗅嗅，一不小心暴露自己是个魔法师啦，哈哈）</p><p><img src="https://github.com/janice143/myblog.github.io/blob/master/images/js30_Canvas08.png?raw=true"></p><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>利用html5 中的canvas实现的画板。在<strong>电脑端</strong>可利用鼠标移动点击进行绘图，在<strong>移动端</strong>可以通过触摸移动实现绘图。绘图的笔<strong>颜色</strong>、<strong>粗细</strong>可以调节，选中<strong>橡皮擦</strong>可对局部区域进行修改，<strong>清屏</strong>按钮可以一键清屏。</p><p>项目重点</p><ul><li><p>canvas</p><ul><li>window.innerWidth</li><li>lineJoin、lineWidth、lineCap </li><li>strokeColor </li><li>beginPath、moveTo、lineTo、stroke()</li></ul></li><li><p>鼠标事件</p><ul><li>mousemove: <em>e</em>.offsetX, <em>e</em>.offsetY</li><li>mouseup</li><li>mouseout</li><li>mousedown</li></ul></li><li><p>触摸事件</p><ul><li>touchmove</li><li>touchend</li><li>touchcancel</li><li>touchstart</li><li>touch坐标计算的坐标偏移问题</li></ul></li><li><p><em>input</em>标签的change事件</p><ul><li>this.value</li><li>this.name</li><li>this.checked</li><li>滑块input线性过渡变成非线性过渡</li></ul></li><li><p>css的flex容器属性</p><ul><li><em>display</em>:flex</li><li><em>align-items</em>: center 竖直居中</li><li> <em>justify-content</em>: center 水平居中</li></ul></li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h4><ol><li>三个input控件<ul><li>颜色 type=”color”</li><li>粗细 type=”range”</li><li>橡皮擦 type=”checkbox”</li></ul></li><li>canvas标签设置画布</li><li>清屏按钮 type=”button”</li></ol><h4 id="Js部分"><a href="#Js部分" class="headerlink" title="Js部分"></a>Js部分</h4><ul><li>获取<code>canvas</code>标签，并设定宽度和高度；获取四个input元素</li><li>利用<code>getContext()</code>获取渲染上下文，存储在变量<code>ctx</code>中。<ul><li>在二维渲染上下文中，左上点坐标为(0,0)，向右（x轴）向下（y轴）为正</li></ul></li><li>设置初始值<ul><li>初始化画笔颜色（<code>ctx.StrokeStyle</code>）粗细（<code>ctx.lineWidth</code>），橡皮擦不选中(<code>eraserChecked = false</code>)；</li><li>设置lineCap(线的末端形状）为圆形，lineJoin（两条线段连接处形状）为圆形</li></ul></li><li> 编写<code>updateValue()</code>函数</li><li>三个控件input发生改变时，触发事件，调用该函数，更新画笔三个初始值。</li><li>编写<code>draw()</code>函数<ul><li>设定一个用于标记绘画状态的变量，画或者不画（true or false)</li><li>判断是鼠标事件还是触摸事件，返回当前鼠标点和触摸点的坐标</li><li>赋值新的画笔参数</li><li>绘制前调用<code>beginPath()</code>，设定路径起点、终点</li></ul></li><li>编写<code>clearCanvas()</code>函数<ul><li>清屏的原理就是在画布上画满一个白色矩阵</li></ul></li><li>所有input的监听事件，控件中的change事件，清屏是click事件</li></ul><h4 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h4><p>使用over-flow:hidden来设置页面不动，这点在移动端触摸时显得必不可少。</p><h2 id="项目知识点"><a href="#项目知识点" class="headerlink" title="项目知识点"></a>项目知识点</h2><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a><a href="https://www.w3school.com.cn/html/html5_canvas.asp">Canvas</a></h4><ul><li>创建 Canvas 元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>通过 JavaScript 来绘制</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;canvas&#x27;</span>);<br><span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>基本样式属性<ul><li>颜色<code>：strokeStyle</code>：线条描边的颜色，<code>fillStyle</code>：填充的颜色</li><li>线型：<code>lineCap</code>：笔触的形状；<code>lineJoin</code>：线条相较的方式；<code>lineWidth</code>：线条的宽度</li></ul></li><li>路径绘制<ul><li><code>beginPath()</code>：新建一条路径</li><li><code>stroke()</code>：绘制轮廓</li><li><code>moveTo()</code>：绘制操作的起点</li><li><code>lineTo()</code>：路径的终点</li></ul></li></ul><h4 id="触摸屏端坐标偏移问题"><a href="#触摸屏端坐标偏移问题" class="headerlink" title="触摸屏端坐标偏移问题"></a>触摸屏端坐标偏移问题</h4><p>使用鼠标事件在canvas画布上画画，非常容易就能获取到画布上的坐标，使用（e.offsetX，e.offsetY）就行。但是对于移动端的触摸屏，必须利用【页面上的坐标】-【画布左上角的坐标】=【画布上的坐标】公式去计算当前触摸位置坐标。</p><p>changedTouches[0].clientX表示当前触摸点在页面上的坐标，e.target.offsetLeft表示画布偏离页面左上角的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x = e.changedTouches[<span class="hljs-number">0</span>].clientX -e.target.offsetLeft;<br>y = e.changedTouches[<span class="hljs-number">0</span>].clientY-e.target.offsetTop;<br></code></pre></td></tr></table></figure><blockquote><p>JS30的第8个项目圆满完成啦，虽然对原项目做了一些改进，但是整体上也实现了一些我自己的独特功能。PS：发现自己真的很喜欢编程，fun with front end development.希望自己能力越来越强，实现自己的程序员梦想。</p><p>感谢阅读，有问题联系我的邮箱<a href="mailto:&#x31;&#x38;&#48;&#51;&#x31;&#x30;&#53;&#x35;&#51;&#56;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109;">&#x31;&#x38;&#48;&#51;&#x31;&#x30;&#53;&#x35;&#51;&#56;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】 Fun dictionary 06</title>
    <link href="/myblog.github.io/2022/01/06/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Fun-dictionary-06/"/>
    <url>/myblog.github.io/2022/01/06/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Fun-dictionary-06/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：©<a href="https://github.com/janice143?tab=repositories">Iaine 万一</a><br>简介：30-day vanilla js coding challenge <a href="https://courses.wesbos.com/account">(30 Day Challenge)</a>是 <a href="https://github.com/wesbos">Wes Bos</a> 设计的一个 30 天原生js编程挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。本项目属于第6天项目，为了更有挑战性，我尝试实现了 <strong>单词查找</strong> 的功能。</p><p> Have fun with the website! ♪(^∇^*)</p><p>网页效果：<a href="https://janice143.github.io/funDictionary/">https://janice143.github.io/funDictionary/</a></p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在输入框中输入一个单词，会实时匹配现有词库中所有包含该字段的单词（以一定的样式展示），每个单词中，会高亮显示出文本输入框中输入的字段。词库为<a href="https://gist.githubusercontent.com/BideoWego/60fbd40d5d1f0f1beca11ba95221dd38/raw/58fb4cce910fbf5fa67a2f0f1f619c09d7b1b373/dictionary.json">json数据</a>，在加载页面时，异步获取而来。</p><p>项目主要知识点包括：</p><ul><li>异步操作</li><li>数组Array对象的一些方法</li><li>正则表达式</li><li>CSS transform的一些属性</li></ul><h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a>项目过程</h2><h4 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h4><p>设置input标签用来输入单词，ul标签（列表标签）用来展示搜索的结果</p><h4 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h4><ol><li>空数组直接赋值给一个<code>dict</code>变量，用来存储json数据中的词库</li><li>使用fetch 方法从网络中异步获取资源，解析 JSON 数据，存入数组<code>dict</code></li><li>利用 filter() 方法查找单词<code>wordToMatch</code>，筛选的条件是正则表达式，如果string的match(regex)方法返回不是空，则filter函数返回词库中所有wordToMatch字段的单词<ul><li>运用 <code>filter()</code> 过滤数组数据</li><li>创建正则表达式，构造过滤条件</li><li>match方法匹配</li></ul></li><li>编写匹配输入的函数。在Html中显示匹配的单词，利用map方法按照原始数组元素顺序依次处理元素。<ul><li>获取匹配数据</li><li>替换关键词放入高亮的标签</li><li>构造 HTML 标签数据</li><li>将匹配值的 HTML 标签放入 <code>&lt;ul&gt;</code> 中</li></ul></li><li>编写展示匹配结果的函数<ul><li>获取匹配数据</li><li>利用map方法依次处理元素，替换关键词放入高亮的标签，返回html标签数据</li><li>将匹配值的 HTML 标签放入 <code>&lt;ul&gt;</code> 中</li></ul></li><li>获取两个主要 HTML 元素（<code>&lt;input&gt;</code>，<code>&lt;ul&gt;</code>），给 <code>&lt;input&gt;</code> 添加事件监听（<code>change</code>, <code>keyup</code>）</li></ol><h4 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h4><p>CSS**<code>transform</code>**属性允许旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。</p><h2 id="项目知识点"><a href="#项目知识点" class="headerlink" title="项目知识点"></a>项目知识点</h2><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><p>概念：程序执行任务时分两段进行，执行第一段任务后，执行其他任务，其他任务执行完后接着执行第二段任务。</p><p>异步操作的方法：</p><ul><li>回调函数多重嵌套</li></ul><p>缺点：出现多重嵌套，代码很容易乱成一团，无法管理，出现callback hell。</p><p><strong>示例:</strong> 读取A文件之后，再读取B文件，之后再回到读取A文件后的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fs.readFile(fileA, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;<br>  fs.readFile(fileB, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>Promise</li></ul><p>它不是新的语法功能，而是一种新的写法。代码从横向发展，变成纵向发展。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> readFile = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs-readfile-promise&#x27;</span>);<br><br>readFile(fileA)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(data.toString());<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> readFile(fileB);<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(data.toString());<br>&#125;)<br>.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(err);<br>&#125;);<br></code></pre></td></tr></table></figure><p>参考文档：<a href="https://wiki.jikexueyuan.com/project/es6/async.html#:~:text=%E6%89%80%E8%B0%93%22%E5%BC%82%E6%AD%A5%22%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4,%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B0%B1%E5%8F%AB%E5%81%9A%E5%BC%82%E6%AD%A5%E3%80%82">https://wiki.jikexueyuan.com/project/es6/async.html#:~:text=%E6%89%80%E8%B0%93%22%E5%BC%82%E6%AD%A5%22%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4,%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B0%B1%E5%8F%AB%E5%81%9A%E5%BC%82%E6%AD%A5%E3%80%82</a></p><h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><p>属于Fetch API的一个全局方法。需要接受 <code>url</code> 作为参数，返回值是一个 Promise 对象。若请求成功，这个对象包含了（对应 Request 的）Response，但这只是一个 HTTP 响应。</p><p>一个基本的 fetch 请求设置代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetch(<span class="hljs-string">&#x27;http://example.com/movies.json&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(data));<br></code></pre></td></tr></table></figure><p>这里通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 <code>fetch()</code> 到的资源路径，然后返回一个包含响应结果的 promise（一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response"><code>Response</code></a> 对象）。</p><p>当然它只是一个 HTTP 响应，而不是真的 JSON。为了获取JSON的内容，我们需要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response/json"><code>json()</code></a> 方法（该方法返回一个将响应 body 解析成 JSON 的 promise）。</p><h4 id="对象转换为数组"><a href="#对象转换为数组" class="headerlink" title="对象转换为数组"></a>对象转换为数组</h4><p>获取的资源data为对象类型，</p><p>``{a: ‘The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).’, ab: ‘The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.’, aback: ‘Backward against the mast;-said of the sails when …uddenly checked, baffled, ordiscomfited. Dickens.’, abaft: ‘Behind; toward the stern from; as, abaft the wheelhouse. Abaftthe beam. See under Beam.’, abalone: ‘A univalve mollusk of the genus Haliotis. The shel…oast of California, clingingclosely to the rocks.’, …}`</p><p>想要转换为数组：</p><p><code>[0:&#123;a: &#39;The first letter of the English and of many other …tury, wasa sound of the quality of ä (as in far).&#39;&#125;</code></p><p><code>1:&#123;ab: &#39;The fifth month of the Jewish year according to th…putation,coinciding nearly with August. W. Smith.&#39;&#125;]</code></p><p>代码参考链接：<a href="https://juejin.cn/post/6844903602478120967">https://juejin.cn/post/6844903602478120967</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">data =&gt; <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> o = &#123;&#125;;<br>    o[v] = data[v];<br>    dict.push(o);<br>&#125;)<br></code></pre></td></tr></table></figure><p>Object.keys方法是JavaScript中用于遍历对象属性的一个方法 。它传入的参数是一个对象，返回的是一个数组，数组中包含的是该对象所有的属性名。</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>概念：匹配字符串的字符组合模式</p><p>创建一个正则表达式有两种方法：</p><p>1 使用正则表达式字面量，包含在斜杠之间</p><p>2 调用<code>RegExp</code>对象的构造函数</p><p>知识参考链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></p><p>正则表达式可以被用于 <code>RegExp</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test">test (en-US)</a> 方法以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a> 的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match">match (en-US)</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search">search (en-US)</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split">split (en-US)</a> 方法。其中match方法是一个在字符串中执行查找匹配的String方法，返回一个数组，在未匹配到时会返回 null。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 匹配单词</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findWords</span>(<span class="hljs-params">wordToMatch,dict</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> dict.filter(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span>&#123;<br>            <span class="hljs-keyword">const</span> regex  = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(wordToMatch,<span class="hljs-string">&#x27;gi&#x27;</span>);<span class="hljs-comment">// g:global,i:intensive          </span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(word)[<span class="hljs-number">0</span>].match(regex))<br>                <span class="hljs-keyword">return</span> word[<span class="hljs-built_in">Object</span>.keys(word)[<span class="hljs-number">0</span>]];<br>           &#125;)<br>    &#125;;<br></code></pre></td></tr></table></figure><h4 id="一些数组和对象方法"><a href="#一些数组和对象方法" class="headerlink" title="一些数组和对象方法"></a>一些数组和对象方法</h4><p>17个实用的JavaScript数组和对象的方法：<a href="https://segmentfault.com/a/1190000015301183">https://segmentfault.com/a/1190000015301183</a></p><ul><li>.filter()<br>创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</li><li>.map()<br>创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</li><li>.reduce()<br>对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。</li><li>.forEach()<br>对数组的每个元素执行一次提供的函数。</li><li>.some()<br>判断数组中的某些元素是否通过由提供的函数实现的测试。</li><li>.every()<br>检查是否数组中的每个值都满足条件。</li><li>.includes()<br>检查是否一个数组包含一个确定的值。</li><li>Array.from()<br>这是一个可以从其他数组或者字符串中创造新array的方法。</li><li>Objects.values()<br>返回一个由给定对象自己的所有可枚举属性值的数组。</li><li>Objects.keys()<br>返回一个由给定对象的自身可枚举属性组成的数组。</li><li>Object.entries()<br>返回一个由一个给定对象的键值对组成的数组。</li><li>Array spread<br>在数组中使用扩展运算符（…）可以展开数组中的元素。</li><li>Object spread<br>扩展对象允许为一个没有更改的对象添加新的属性和方法（换句话说，创建了一个新对象)</li><li>Object.freeze()<br>防止修改现有的对象属性或者向对象添加新的属性和值。</li><li>Object.seal()<br>停止将任何新属性添加到对象，但仍允许更改现有属性。</li><li>Object.assign()<br>允许将对象组合在一起。</li></ul><blockquote><p>想把我的技术文章写好一点，特意参考其他优秀人的文档，感谢<a href="https://github.com/soyaine">未枝丫</a>，我觉得他的文档写的不错，特意模仿，顺便挂上他的JS30挑战项目<a href="https://github.com/soyaine/JavaScript30/tree/master/06%20-%20Type%20Ahead">链接</a>。</p><p>感谢阅读，有问题联系我的邮箱<a href="mailto:&#49;&#56;&#x30;&#x33;&#x31;&#48;&#x35;&#x35;&#51;&#56;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#109;">&#49;&#56;&#x30;&#x33;&#x31;&#48;&#x35;&#x35;&#51;&#56;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#109;</a>.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】 Flex Panel 05</title>
    <link href="/myblog.github.io/2021/11/17/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Flex-Panel-05/"/>
    <url>/myblog.github.io/2021/11/17/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91-Flex-Panel-05/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文介绍一个动态放映网页，知识点主要涉及到flex容器，以及元素点击事件。</p><p>效果网站：<a href="https://janice143.github.io/flexPanel/">https://janice143.github.io/flexPanel/</a></p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="一、html部分"><a href="#一、html部分" class="headerlink" title="一、html部分"></a>一、html部分</h4><p>主要为5个div元素将网页分为5块，横向排列。每一个div元素中有上中下三个p标签，对应3段话。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panels&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel1 panel&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickOpen(1)&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hey<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Let&#x27;s<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Dance<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel2 panel&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickOpen(2)&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Give<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Take<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Receive<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel3 panel&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickOpen(3)&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Experience<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>It<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Today<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel4 panel&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickOpen(4)&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Give<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>All<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You can<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel5 panel&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickOpen(5)&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Life<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>In<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Motion<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="二、css部分"><a href="#二、css部分" class="headerlink" title="二、css部分"></a>二、css部分</h4><p>css代码主要要实现5个div元素均匀横向排列，每个div元素内有对应的背景图片、3个p标签的文本。P标签的文本在每一个div元素中也是左右居中、上下均匀排列。主要是利用了flex容器来实现。</p><h4 id="1-flex容器"><a href="#1-flex容器" class="headerlink" title="1 flex容器"></a>1 flex容器</h4><p>参考网站：<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p>容器的属性：</p><ul><li>flex-direction：项目的排列方向</li><li>flex-wrap：默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow：<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式</li><li>justify-content：项目在主轴上的对齐方式</li><li>align-items：项目在交叉轴上如何对齐</li><li>align-content：定义了多根轴线的对齐方式</li></ul><p>项目的属性：</p><ul><li>order：项目的排列顺序，数值越小，排列越靠前</li><li>flex-grow：定义项目的放大比例，默认为0</li><li>flex-shrink：项目的缩小比例，默认为1</li><li>flex-basis： 项目占据的主轴空间</li><li>flex：是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code></li><li>align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性</li></ul><h4 id="2-css字体"><a href="#2-css字体" class="headerlink" title="2 css字体"></a>2 css字体</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fonts.googleapis.com/css?family=Amatic+SC<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string">text-transform: uppercase;</span><br><span class="hljs-string">font-family: &#x27;Amatic SC&#x27;,cursive;</span><br><span class="hljs-string">text-shadow: 0 0 4px rgba(0,0,0,0.72),0 0 14px rgba(0,0,0,0.45);</span><br></code></pre></td></tr></table></figure><h4 id="3过渡样式"><a href="#3过渡样式" class="headerlink" title="3过渡样式"></a>3过渡样式</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transition</span>:<br>font-size <span class="hljs-number">0.7s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.61</span>,-<span class="hljs-number">0.19</span>, <span class="hljs-number">0.7</span>,-<span class="hljs-number">0.11</span>),<br>flex <span class="hljs-number">0.7s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.61</span>,-<span class="hljs-number">0.19</span>, <span class="hljs-number">0.7</span>,-<span class="hljs-number">0.11</span>),<br>background <span class="hljs-number">0.2s</span>;<br><span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateY</span>(-<span class="hljs-number">100%</span>);<br></code></pre></td></tr></table></figure><h4 id="4-背景图片"><a href="#4-背景图片" class="headerlink" title="4 背景图片"></a>4 背景图片</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-size</span>: cover;<br><span class="hljs-attribute">background-position</span>: center;<br><span class="hljs-selector-class">.panel1</span> &#123; <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">https://source.unsplash.com/gYl-UtwNg_I/1500x1500</span>); &#125;<br><span class="hljs-selector-class">.panel2</span> &#123; <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">https://source.unsplash.com/rFKUFzjPYiQ/1500x1500</span>); &#125;<br><span class="hljs-selector-class">.panel3</span> &#123; <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">https://images.unsplash.com/photo-1465188162913-8fb5709d6d57?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=faces&amp;cs=tinysrgb&amp;w=1500&amp;h=1500&amp;fit=crop&amp;s=967e8a713a4e395260793fc8c802901d</span>); &#125;<br><span class="hljs-selector-class">.panel4</span> &#123; <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">https://source.unsplash.com/ITjiVXcwVng/1500x1500</span>); &#125;<br><span class="hljs-selector-class">.panel5</span> &#123; <span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">https://source.unsplash.com/3MNzGlQM7qs/1500x1500</span>); &#125;<br></code></pre></td></tr></table></figure><h4 id="5其他"><a href="#5其他" class="headerlink" title="5其他"></a>5其他</h4><p>CSS选择器</p><p><code>*</code> 将匹配文档的所有元素；<code>&gt;</code> 组合器选择前一个元素的直接子代的节点。</p><p> .panel &gt; *选择类名为panel的所以直接子元素</p><h3 id="Js部分"><a href="#Js部分" class="headerlink" title="Js部分"></a>Js部分</h3><p>我写的程序，大致思路是在html代码里设置onclick属性，然后函数内容在js里写，不同的panel传入参数不一样</p><p>定位类名有两个以上的标签document.getElementsByClassName(<code>panel$&#123;num&#125; panel-open</code>)；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 点击panel 12345，给对应的panel添加.panel-open属性</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickOpen</span>(<span class="hljs-params">num</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> panelNumIf = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">`panel<span class="hljs-subst">$&#123;num&#125;</span> panel-open`</span>);<br>    <span class="hljs-keyword">const</span> panelNum = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">`panel<span class="hljs-subst">$&#123;num&#125;</span>`</span>);<br>    <span class="hljs-comment">// console.log(panelNumIf[0])</span><br>    <span class="hljs-keyword">if</span> (panelNumIf[<span class="hljs-number">0</span>])<br>        panelNumIf[<span class="hljs-number">0</span>].classList.remove(<span class="hljs-string">&#x27;panel-open&#x27;</span>);<br>    <span class="hljs-keyword">else</span><br>        panelNum[<span class="hljs-number">0</span>].classList.add(<span class="hljs-string">&#x27;panel-open&#x27;</span>);<span class="hljs-comment">//添加panel-open类属性</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`panel<span class="hljs-subst">$&#123;num&#125;</span> panel-open`</span>);          <br>&#125;;<br></code></pre></td></tr></table></figure><p>别人的程序，大致思路是遍历5个Panel，监控是否有点击事件，有的话就运行toggleOpen函数，该函数里 this.classList.toggle(‘open’)表示如果this有open类名，则删除，没有则加上。</p><p>e.propertyName获取transitionend的属性名，e.propertyName.includes(‘flex’)包含flex字段的属性名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> panels = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.panel&#x27;</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleOpen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>    <span class="hljs-built_in">this</span>.classList.toggle(<span class="hljs-string">&#x27;open&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleActive</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(e.propertyName);<br>    <span class="hljs-keyword">if</span> (e.propertyName.includes(<span class="hljs-string">&#x27;flex&#x27;</span>)) &#123;<br>        <span class="hljs-built_in">this</span>.classList.toggle(<span class="hljs-string">&#x27;open-active&#x27;</span>);<br>    &#125;<br>&#125;<br>panels.forEach(<span class="hljs-function"><span class="hljs-params">panel</span> =&gt;</span> panel.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, toggleOpen));<br>panels.forEach(<span class="hljs-function"><span class="hljs-params">panel</span> =&gt;</span> panel.addEventListener(<span class="hljs-string">&#x27;transitionend&#x27;</span>, toggleActive));<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完整代码放在了<a href="https://github.com/janice143/flexPanel">Github</a>上，如果读者有兴趣，不妨试一试。</p>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】数组操作 04</title>
    <link href="/myblog.github.io/2021/11/15/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C-04/"/>
    <url>/myblog.github.io/2021/11/15/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C-04/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文介绍一下数组操作的一些常用方法。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="1创建数组"><a href="#1创建数组" class="headerlink" title="1创建数组"></a>1创建数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> people = [<br><span class="hljs-string">&#x27;Bernhard, Sandra&#x27;</span>, <span class="hljs-string">&#x27;Bethea, Erin&#x27;</span>, <span class="hljs-string">&#x27;Becker, Carl&#x27;</span>, <span class="hljs-string">&#x27;Bentsen, Lloyd&#x27;</span>, <span class="hljs-string">&#x27;Beckett, Samuel&#x27;</span>, <span class="hljs-string">&#x27;Blake, William&#x27;</span>, <span class="hljs-string">&#x27;Berger, Ric&#x27;</span>, <span class="hljs-string">&#x27;Beddoes, Mick&#x27;</span>, <span class="hljs-string">&#x27;Beethoven, Ludwig&#x27;</span>,<br><span class="hljs-string">&#x27;Belloc, Hilaire&#x27;</span>, <span class="hljs-string">&#x27;Begin, Menachem&#x27;</span>, <span class="hljs-string">&#x27;Bellow, Saul&#x27;</span>, <span class="hljs-string">&#x27;Benchley, Robert&#x27;</span>, <span class="hljs-string">&#x27;Blair, Robert&#x27;</span>, <span class="hljs-string">&#x27;Benenson, Peter&#x27;</span>, <span class="hljs-string">&#x27;Benjamin, Walter&#x27;</span>, <span class="hljs-string">&#x27;Berlin, Irving&#x27;</span>,<br><span class="hljs-string">&#x27;Benn, Tony&#x27;</span>, <span class="hljs-string">&#x27;Benson, Leana&#x27;</span>, <span class="hljs-string">&#x27;Bent, Silas&#x27;</span>, <span class="hljs-string">&#x27;Berle, Milton&#x27;</span>, <span class="hljs-string">&#x27;Berry, Halle&#x27;</span>, <span class="hljs-string">&#x27;Biko, Steve&#x27;</span>, <span class="hljs-string">&#x27;Beck, Glenn&#x27;</span>, <span class="hljs-string">&#x27;Bergman, Ingmar&#x27;</span>, <span class="hljs-string">&#x27;Black, Elk&#x27;</span>, <span class="hljs-string">&#x27;Berio, Luciano&#x27;</span>,<br><span class="hljs-string">&#x27;Berne, Eric&#x27;</span>, <span class="hljs-string">&#x27;Berra, Yogi&#x27;</span>, <span class="hljs-string">&#x27;Berry, Wendell&#x27;</span>, <span class="hljs-string">&#x27;Bevan, Aneurin&#x27;</span>, <span class="hljs-string">&#x27;Ben-Gurion, David&#x27;</span>, <span class="hljs-string">&#x27;Bevel, Ken&#x27;</span>, <span class="hljs-string">&#x27;Biden, Joseph&#x27;</span>, <span class="hljs-string">&#x27;Bennington, Chester&#x27;</span>, <span class="hljs-string">&#x27;Bierce, Ambrose&#x27;</span>,<br><span class="hljs-string">&#x27;Billings, Josh&#x27;</span>, <span class="hljs-string">&#x27;Birrell, Augustine&#x27;</span>, <span class="hljs-string">&#x27;Blair, Tony&#x27;</span>, <span class="hljs-string">&#x27;Beecher, Henry&#x27;</span>, <span class="hljs-string">&#x27;Biondo, Frank&#x27;</span><br>];<br></code></pre></td></tr></table></figure><h4 id="2-获取数组长度"><a href="#2-获取数组长度" class="headerlink" title="2 获取数组长度"></a>2 获取数组长度</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(people.length);<br></code></pre></td></tr></table></figure><h4 id="3循环"><a href="#3循环" class="headerlink" title="3循环"></a>3循环</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">people.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,index</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(item,index);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="4-数据尾部添加一个元素"><a href="#4-数据尾部添加一个元素" class="headerlink" title="4 数据尾部添加一个元素"></a>4 数据尾部添加一个元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> newLength = people.push(<span class="hljs-string">&#x27;Wheeler, Ben&#x27;</span>);<span class="hljs-comment">// newLength的结果是people的长度，不是新添加的元素内容</span><br><span class="hljs-built_in">console</span>.log(people.length);<br></code></pre></td></tr></table></figure><h4 id="5-从尾部删除一个元素"><a href="#5-从尾部删除一个元素" class="headerlink" title="5 从尾部删除一个元素"></a>5 从尾部删除一个元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> last = people.pop();<br><span class="hljs-built_in">console</span>.log(people.length);<br></code></pre></td></tr></table></figure><h4 id="6-从头部删除一个元素"><a href="#6-从头部删除一个元素" class="headerlink" title="6 从头部删除一个元素"></a>6 从头部删除一个元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> first = people.shift();<br><span class="hljs-built_in">console</span>.log(people.length);<br></code></pre></td></tr></table></figure><h4 id="7-从提添加一个新元素"><a href="#7-从提添加一个新元素" class="headerlink" title="7 从提添加一个新元素"></a>7 从提添加一个新元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> firstItem = people.unshift(<span class="hljs-string">&#x27;Bernhard, Sandra&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(people);<br></code></pre></td></tr></table></figure><h4 id="8-寻找下标"><a href="#8-寻找下标" class="headerlink" title="8 寻找下标"></a>8 寻找下标</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> pos = people.indexOf(<span class="hljs-string">&#x27;Blair, Tony&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(pos);<br></code></pre></td></tr></table></figure><h4 id="9-根据下标删除元素"><a href="#9-根据下标删除元素" class="headerlink" title="9 根据下标删除元素"></a>9 根据下标删除元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> removeItem = people.splice(pos,<span class="hljs-number">1</span>);<span class="hljs-comment">//参数1表示Pos下标后多少个</span><br><span class="hljs-built_in">console</span>.log(removeItem);<br></code></pre></td></tr></table></figure><h4 id="10-复制数组"><a href="#10-复制数组" class="headerlink" title="10 复制数组"></a>10 复制数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 复制数组 1</span><br><span class="hljs-keyword">let</span> newPeople1 = people; <span class="hljs-comment">//people和newPeople1指向同一个内存</span><br><span class="hljs-comment">// 复制数组 2</span><br><span class="hljs-keyword">let</span> newPeople2 = people.slice(); <span class="hljs-comment">// people和newPeople1指向不同一个内存</span><br></code></pre></td></tr></table></figure><h4 id="11-Index超出数组长度"><a href="#11-Index超出数组长度" class="headerlink" title="11 Index超出数组长度"></a>11 Index超出数组长度</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">people[<span class="hljs-number">100</span>] = <span class="hljs-string">&#x27;bbb&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(people);<br></code></pre></td></tr></table></figure><h4 id="12-Array-prototype-filter-过滤"><a href="#12-Array-prototype-filter-过滤" class="headerlink" title="12 Array.prototype.filter() 过滤"></a>12 Array.prototype.filter() 过滤</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fifteen = inventors.filter(<span class="hljs-function"><span class="hljs-params">inventor</span>=&gt;</span>(inventor.year&gt;=<span class="hljs-number">1500</span> &amp;&amp; inventor.year &lt; <span class="hljs-number">1600</span>));<br><span class="hljs-built_in">console</span>.table(fifteen);<br></code></pre></td></tr></table></figure><h4 id="13-Array-prototype-map"><a href="#13-Array-prototype-map" class="headerlink" title="13 Array.prototype.map()"></a>13 Array.prototype.map()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">const</span> fullNames = inventors.map(<span class="hljs-function"><span class="hljs-params">inventor</span> =&gt;</span> (inventor.first + <span class="hljs-string">&#x27; &#x27;</span> + inventor.last));<br><span class="hljs-keyword">const</span> fullNames2 = inventors.map(<span class="hljs-function"><span class="hljs-params">inventor</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;inventor.first&#125;</span> <span class="hljs-subst">$&#123;inventor.last&#125;</span>`</span>);<br><span class="hljs-built_in">console</span>.log(fullNames);<br><span class="hljs-built_in">console</span>.log(fullNames2);<br></code></pre></td></tr></table></figure><h4 id="14-Array-prototype-sort"><a href="#14-Array-prototype-sort" class="headerlink" title="14  Array.prototype.sort()"></a>14  Array.prototype.sort()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 升序</span><br><span class="hljs-keyword">const</span> ordered = inventors.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a.year &gt; b.year ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.table(ordered);<br><span class="hljs-comment">// 降序</span><br><span class="hljs-keyword">const</span> oldest = inventors.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> lastInventor = a.passed - a.year;<br>    <span class="hljs-keyword">const</span> nextInventor = b.passed - b.year;<br>    <span class="hljs-keyword">return</span> lastInventor &gt; nextInventor ? -<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>&#125;);<br><span class="hljs-built_in">console</span>.table(oldest);<br></code></pre></td></tr></table></figure><h4 id="15-Array-prototype-reduce-结果返回单个值"><a href="#15-Array-prototype-reduce-结果返回单个值" class="headerlink" title="15 Array.prototype.reduce() 结果返回单个值"></a>15 Array.prototype.reduce() 结果返回单个值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Array.prototype.reduce() 结果返回单个值</span><br><span class="hljs-keyword">const</span> totalYears = inventors.reduce(<span class="hljs-function">(<span class="hljs-params">total,inventor</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> total + (inventor.passed - inventor.year);<br>&#125;, <span class="hljs-number">0</span>); <span class="hljs-comment">// 0表示返回的单个值再加上0</span><br><span class="hljs-built_in">console</span>.log(totalYears);<br>            <br></code></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>完整代码放在了<a href="https://github.com/janice143/arrayOperation">Github</a>上，如果读者有兴趣，不妨试一试。</p>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Image Procession with Javascipt 03</title>
    <link href="/myblog.github.io/2021/11/13/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Image-Procession-with-Javascipt-03/"/>
    <url>/myblog.github.io/2021/11/13/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Image-Procession-with-Javascipt-03/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文利用javascript更新css变量，实现一个简易的图像处理网页。对于图像处理部分，本网页可调节图像的边框宽度、模糊度以及边框颜色值。</p><p>网址为(<a href="https://janice143.github.io/imageProcessionwithJS/">https://janice143.github.io/imageProcessionwithJS/</a>)</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="1-页面布局"><a href="#1-页面布局" class="headerlink" title="1 页面布局"></a>1 页面布局</h4><p>页面分为三部分：标题、三个input组成的控件、图像</p><p>通过调节三个Input的值，可以实现对外边距、模糊值和颜色的改变。 </p><p>一、html代码</p><p>1 标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>利用<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-color&quot;</span>&gt;</span>JS<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>更新CSS自定义变量<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2 三个input值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;controlers&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;spacing&quot;</span>&gt;</span>外边距:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;spacing&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;spacing&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">data-unit</span>=<span class="hljs-string">&quot;px&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;blur&quot;</span>&gt;</span>模糊值:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blur&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;blur&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">data-unit</span>=<span class="hljs-string">&quot;px&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;color&quot;</span>&gt;</span>底色:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;color&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;color&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;color&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#fecc00&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>data-unit=”px”是自己设置的dataset(数据集合)。</p><p>3 图像</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://source.unsplash.com/7bwQXzbF6KE/800x500&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>二、css代码</p><p>1 css变量</p><p>变量声明：在选择器里（任何选择器），变量名前面要加两根连词线（<code>--</code>）。本文里在:root根元素里声明，这是全局变量的声明方式，保证任何选择器都可以使用。变量名大小写敏感。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span>&#123;<br>    <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">600px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">375px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-built_in">var</span>(--spacing);<span class="hljs-comment">/* var函数获取变量 */</span><br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--color);<br>    <span class="hljs-attribute">filter</span>:<span class="hljs-built_in">blur</span>(<span class="hljs-built_in">var</span>(--blur));<br>&#125;<br></code></pre></td></tr></table></figure><p>读取变量：利用var()函数读取</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-pseudo">:root</span>&#123;<br>     --<span class="hljs-attribute">color</span>:<span class="hljs-number">#fecc00</span>;<br>     --spacing:<span class="hljs-number">10px</span>;<br>     --blur:<span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>css变量参考网址：（<a href="https://www.ruanyifeng.com/blog/2017/05/css-variables.html%EF%BC%89">https://www.ruanyifeng.com/blog/2017/05/css-variables.html）</a></p><p>三、javascript代码</p><p>1 suffix中文意思为 后缀。在js代码中，设置了一个suffix变量，这是因为spacing和blur的值在css中需要加上px单位，而color的值没有，所以使用了||逻辑运算。</p><p>2 this.dataset需要注意一下，在html代码中，我们设置了自定义了data-unit数据，this.dataset会取出所有自定义的数据集，比如你可以在Html中设置data-key(回想起前几天的js程序）,data-name,data-poo任何数据名字，因为是自定义。this.dataset.unit是本文在html代码中提前设置好的。</p><p>3 document.documentElement用来获取当前文档的直接子节点，对于Html文档而言，一般是<html>。</p><p>4 style.setProperty(propertyName, value);给css样式某个属性名propertyName赋一个新值value。</p><p>5 <code>--$&#123;this.name&#125;</code>为模板字面量，可以嵌入表达式的字符串字面量，${}表示一个占位符。一般的字符串是用单引号或者双引号标注的，这些字符串之间没有任何区别，而模板字面量则可以通过一个占位符来进行插值，模板字面量用反引号``实现。</p><p>6 箭头函数优点：剪短、this指向函数定义生效时所在对象。</p><p>函数声明：关键字、函数名、参数、函数体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionName</span> (<span class="hljs-params">[arg1 [,arg2 [...,argn]]]</span>) </span>&#123;<br>  <span class="hljs-comment">// functionBody 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>没有函数名时，函数为匿名函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> square = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> number * number;<br>&#125;;<br><span class="hljs-comment">// 相当于箭头函数：number=&gt;number*number;</span><br></code></pre></td></tr></table></figure><p>具名函数由函数名，而且函数内部可以代指本身（迭代函数使用）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> factorial = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fac</span>(<span class="hljs-params">n</span>) </span>&#123;  <span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : n * fac(n - <span class="hljs-number">1</span>);&#125;;<br><span class="hljs-built_in">console</span>.log(factorial(<span class="hljs-number">3</span>));<br><span class="hljs-keyword">var</span> x = square(<span class="hljs-number">4</span>);<span class="hljs-comment">// x 得到的值为16</span><br></code></pre></td></tr></table></figure><p>箭头函数；如果函数体只有一个表达式，可以不用{}符号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// do something</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取Input的value，并且将value赋值给css</span><br><span class="hljs-keyword">const</span> inputs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.controlers input&#x27;</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateValue</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> suffix = <span class="hljs-built_in">this</span>.dataset.unit || <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// 给blur和spacing加单位</span><br>    <span class="hljs-built_in">document</span>.documentElement.style.setProperty(<span class="hljs-string">`--<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>,<span class="hljs-built_in">this</span>.value + suffix);<br>&#125;<br>inputs.forEach(<span class="hljs-function"><span class="hljs-params">input</span>=&gt;</span>input.addEventListener(<span class="hljs-string">&#x27;change&#x27;</span>,updateValue));<br></code></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>完整代码放在了<a href="https://github.com/janice143/imageProcessionwithJS">Github</a>上，如果读者有兴趣，不妨试一试。</p>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Real time clock 02</title>
    <link href="/myblog.github.io/2021/11/12/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Real-time-clock-02/"/>
    <url>/myblog.github.io/2021/11/12/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Real-time-clock-02/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文利用javascript写一个实时显示时间的时钟特效网页。</p><p>网址为(<a href="https://janice143.github.io/realTImeClock/">https://janice143.github.io/realTImeClock/</a>)</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="1网页布局与功能"><a href="#1网页布局与功能" class="headerlink" title="1网页布局与功能"></a>1网页布局与功能</h4><p>网页主体为一个时钟，具有表盘（12个数字）和三个指针（时针、分针、秒针）。</p><h4 id="2实现原理"><a href="#2实现原理" class="headerlink" title="2实现原理"></a>2实现原理</h4><p>一、 html代码</p><p>使用一个类名为clock为的div容器，里面包含时针.hour-hand,分针.minute-hand,秒针second-hand，以及12个数字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clock&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hour-hand hand&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;minute-hand hand&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;second-hand hand&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;number&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num12&quot;</span>&gt;</span>12<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num4&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num5&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num6&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num7&quot;</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num8&quot;</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num9&quot;</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num10&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;num11&quot;</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>二、css代码</p><p>1 先让时钟显示在页面的中部（垂直居中，水平居中），这可以用个在clock的上一级词main中设置flex容器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#main</span>&#123;<br><br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-attribute">justify-content</span>: center;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>2 时钟的表盘的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clock</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">20px</span> solid white;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br></code></pre></td></tr></table></figure><p>3 指针的样式</p><p>指针旋转的特效是由transfrom：rotate(deg)实现的（本文这里是通过js代码后面再设置的）。transform-origin默认是50%，元素会绕着中间旋转，设置成100%后，元素绕着一端旋转。transition-timing-function是设置过渡的时间函数特效，不设置是默认均匀地过渡。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.hand</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">120px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">6px</span>;<br>    <span class="hljs-attribute">background-color</span>: blueviolet;<br>    <span class="hljs-attribute">position</span>:absolute;<br>    <span class="hljs-attribute">top</span>:<span class="hljs-number">148px</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">148px</span>;<br>    <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">transition</span>:all <span class="hljs-number">0.05s</span>;<br>    <span class="hljs-attribute">transition-timing-function</span>: <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">2.7</span>, <span class="hljs-number">0.58</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-selector-class">.hour-hand</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.second-hand</span>&#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">4px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4 12个数字的样式</p><p>先给数字设置相对定位，相对于上一级.number。然后再给每个数字设置相应的top和left. 数字位置算法为：</p><p>  num=2;   top=135<em>sin((num-3)<em>30/180</em>pi)+135；  left=135</em>cos((num-3)<em>30/180</em>pi)+135 （num为1-12的数字）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.number</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;<br><br><br>    <span class="hljs-attribute">position</span>:absolute;<br>    <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>三、 javascript代码</p><p>分别获取时针、分钟、秒针的类名，然后通过当前时间给三个指针分配正确的旋转角度。</p><p>1 秒针： parseInt(second/60*360)+90;</p><p>2 分针： parseInt(minute/(60)*360+second/10)+90;</p><p>3 时针：parseInt(hour/(12)*360+minute/(60)*30)+90;</p><p>+90度是因为设置指针css样式的时候，指针都在指在9点钟的位置，+90度可让指针从12点为起始点旋转。</p><p>设置为指针的角度后，利用定时器每隔一秒刷新指针的位置，这样就可以达到实时显示的效果。</p><p>当指针转弯一圈后，重新运行设置时间函数 setDate()重置指针的角度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取指针的transform样式，从而让其旋转</span><br>      <span class="hljs-keyword">const</span> secondHand = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.second-hand&#x27;</span>);<br>      <span class="hljs-keyword">const</span> minuteHand = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.minute-hand&#x27;</span>);<br>      <span class="hljs-keyword">const</span> hourHand = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.hour-hand&#x27;</span>);<br><br>      <span class="hljs-keyword">const</span> audio = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;audio&#x27;</span>);<br>      <span class="hljs-comment">// 获取当前时间，从时间里设置指针</span><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDate</span>(<span class="hljs-params"></span>)</span>&#123;<br>          <span class="hljs-keyword">const</span> time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>          <span class="hljs-keyword">const</span> second = time.getSeconds();<br>          <span class="hljs-keyword">const</span> secondDeg = <span class="hljs-built_in">parseInt</span>(second/<span class="hljs-number">60</span>*<span class="hljs-number">360</span>)+<span class="hljs-number">90</span>;<br>          secondHand.style.transform = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;secondDeg&#125;</span>deg)`</span>;<br><br>          <span class="hljs-keyword">const</span> minute= time.getMinutes();<br>          <span class="hljs-keyword">const</span> minuteDeg = <span class="hljs-built_in">parseInt</span>(minute/(<span class="hljs-number">60</span>)*<span class="hljs-number">360</span>+second/<span class="hljs-number">10</span>)+<span class="hljs-number">90</span>;<br>          minuteHand.style.transform = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;minuteDeg&#125;</span>deg)`</span>;<br><br>          <span class="hljs-keyword">const</span> hour= time.getHours();<br>          <span class="hljs-keyword">const</span> hourDeg = <span class="hljs-built_in">parseInt</span>(hour/(<span class="hljs-number">12</span>)*<span class="hljs-number">360</span>+minute/(<span class="hljs-number">60</span>)*<span class="hljs-number">30</span>)+<span class="hljs-number">90</span>;<br>          hourHand.style.transform = <span class="hljs-string">`rotate(<span class="hljs-subst">$&#123;hourDeg&#125;</span>deg)`</span>;<br>          <br>      &#125;<br>      <span class="hljs-comment">// 设置定时器美隔一秒时间进行刷新页面</span><br>      <span class="hljs-built_in">setInterval</span>(setDate,<span class="hljs-number">1000</span>);<br>      <span class="hljs-comment">// </span><br>      setDate(); <span class="hljs-comment">// 当指针转一圈后，重置度数</span><br><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完整代码放在了<a href="https://github.com/janice143/realTImeClock">Github</a>上，如果读者有兴趣，不妨试一试。</p>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【原生javascript项目】Piano-Kit-01</title>
    <link href="/myblog.github.io/2021/11/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Piano-Kit-01/"/>
    <url>/myblog.github.io/2021/11/07/%E3%80%90%E5%8E%9F%E7%94%9Fjavascript%E9%A1%B9%E7%9B%AE%E3%80%91Piano-Kit-01/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文介绍如何用javascripty语法写一个简单的琴键(drum ang piano)网页，通过敲击特定键盘（音键），可以发出不同音调。</p><p>网址为(<a href="https://janice143.github.io/musicKit.github.io/">https://janice143.github.io/musicKit.github.io/</a>)</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="1网页布局与功能"><a href="#1网页布局与功能" class="headerlink" title="1网页布局与功能"></a>1网页布局与功能</h4><p>网页整体分为3个部分：</p><p>1是最顶上居中排布的乐器切换(Drum Kit, Piano Kit)组块，选中响应的kit，背景图和琴键切换为响应的内容，同时kit字体变为白色；</p><p>2是页面居中排布的琴键；</p><p>3是背景图。</p><p>琴键可以通过鼠标点击或者按下响应的键盘来操作，可以发出对应的音效（黄色字体表示音效的名称）。琴键被点击按下后，加以一定的css动画（黄色高亮边框）来区分。</p><h4 id="2实现原理"><a href="#2实现原理" class="headerlink" title="2实现原理"></a>2实现原理</h4><p>一、 html代码</p><p>1 乐器切换组块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;switch&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;drum chosen&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;addChosenDrum()&quot;</span>&gt;</span>Drum Kit<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;piano&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;addChosen()&quot;</span>&gt;</span>Piano Kit<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2 Drum Kit:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pianoKit&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;65&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key1 key&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(65)&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>DO<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;83&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key2 key&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(83)&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>S<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>RE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;68&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key3 key&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(68)&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>D<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>MI<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;70&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key4 key&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(70)&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>F<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>FA<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;71&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key5 key&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(71)&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>G<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>SOL<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;72&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key6 key&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(72)&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>H<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>LA<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;74&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key7 key&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(74)&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>J<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>SI<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;65&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/1.MP3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;83&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/2.MP3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;68&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/3.MP3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;70&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/4.MP3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;71&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/5.MP3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;72&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/6.MP3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;74&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/7.MP3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <br></code></pre></td></tr></table></figure><p>3 Piano Kit</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drumKit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;chosen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;65&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key1 key&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#1&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(65)&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>CLAP<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;83&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key2 key&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#1&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(83)&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>S<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>HIHAT<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;68&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key3 key&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#1&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(68)&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>D<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>KICK<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;70&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key4 key&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#1&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(70)&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>F<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>OPENHAP<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;71&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key5 key&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#1&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(71)&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>G<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>BOOM<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;72&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key6 key&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#1&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(72)&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>H<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>RIDE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;74&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key7 key&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#1&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(74)&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>J<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>SNARE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;75&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key7 key&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#1&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(75)&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>K<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>TOM<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;76&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key7 key&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#1&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;clickPlaySound(76)&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-ABC&quot;</span>&gt;</span>L<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;key-tune&quot;</span>&gt;</span>TINK<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;65&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/clap.wav&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;83&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/hihat.wav&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;68&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/kick.wav&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;70&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/openhat.wav&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;71&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/boom.wav&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;72&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/ride.wav&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;74&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/snare.wav&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;75&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/tom.wav&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">data-key</span>=<span class="hljs-string">&quot;76&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;sounds/tink.wav&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>二、css代码</p><p>1 实现顶部的切换组块（Drum Kit, Piano Kit)固定在窗口的某个位置，不占位置，脱离标准文档流；居中排布</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: fixed;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;  <br><span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;  <br><span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto; <br></code></pre></td></tr></table></figure><p>2 实现琴键居中排布：用Flex 布局实现垂直、水平居中。</p><p>任何一个容器都可以指定为 Flex 布局（flex容器），display: flex即可实现。采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”Item”。</p><p>容器具有6个属性：</p><p>· flex-direction:水平主轴的方向</p><p>· flex-wrap:如果主轴拍不下，可以用这个属性来设置换行的形式</p><p>· flex-flow:合并了flex-direction 和flex-wrap的功能，用这个属性可以同时设置这两个属性。</p><p>· justify-content:定义了item在主轴（水平方向上）的对齐方式</p><p>·align-items：定义了item在垂直方向上的对齐方式</p><p>· align-content：定义了多跟轴线的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#drumKit</span>,<span class="hljs-selector-id">#pianoKit</span>&#123;<br>    <span class="hljs-comment">/* background-color: red; */</span><br>    <span class="hljs-comment">/* 在需要垂直居中的父元素上，设置display:flex和align-items：center。要求：父元素必须显示设置height值 */</span><br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">90vh</span>; <span class="hljs-comment">/*vh 就是当前屏幕可见高度的100% </span><br><span class="hljs-comment">    align-items: center; /*子元素水平居中*/</span><br>    <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/*子元素垂直居中*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>90vh表示占窗口（当前页面窗口）大小的90%。</p><p>3 键盘被点击时，js会添加playing类，其css布局为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.playing</span>&#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.1</span>);<br>    <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#ffc600</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1rem</span> <span class="hljs-number">#ffc600</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4 drum kit 和piano kit被选中时，js会添加chosen类名。设置css代码让选中字体变为白色以区分</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#switch</span> <span class="hljs-selector-class">.chosen</span>&#123;<br>    <span class="hljs-attribute">color</span>:white;<br>&#125;<br></code></pre></td></tr></table></figure><p>三、 javascript代码</p><p>1 切换键盘(drum kit, piano kit)</p><p>对于drum kit：点击drum，添加.chosen，同时去掉piano kit 的.chosen类名；显示drum琴键，隐藏piano琴键；显示响应背景background-image。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 点击a标签，切换键盘:点击piano键盘，添加chosen class，去掉drum的class; 显示对应的piano键盘;在对应的键盘中添加chosen，这样audio也可以对应</span><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addChosen</span>(<span class="hljs-params"></span>)</span>&#123;<br>       <span class="hljs-keyword">const</span> chosen =  <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&quot;piano&quot;</span>);<br>       <span class="hljs-keyword">const</span> notChosen = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&quot;drum&quot;</span>);<br>       chosen[<span class="hljs-number">0</span>].classList.add(<span class="hljs-string">&#x27;chosen&#x27;</span>);<br>       notChosen[<span class="hljs-number">0</span>].classList.remove(<span class="hljs-string">&#x27;chosen&#x27;</span>);<br>       <span class="hljs-keyword">const</span> notChosenKit = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;drumKit&quot;</span>);<br>       notChosenKit.classList.remove(<span class="hljs-string">&#x27;chosen&#x27;</span>);<br>       notChosenKit.style.display = <span class="hljs-string">&quot;none&quot;</span>; <br>       <span class="hljs-keyword">const</span> chosenKit = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;pianoKit&quot;</span>);<br>       chosenKit.style.display = <span class="hljs-string">&quot;flex&quot;</span>;<br>       chosenKit.classList.add(<span class="hljs-string">&#x27;chosen&#x27;</span>);<br>       <span class="hljs-comment">// 换钢琴壁纸</span><br>       <span class="hljs-keyword">const</span> wallpaper = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;html&quot;</span>);<br>       wallpaper[<span class="hljs-number">0</span>].style.backgroundImage=<span class="hljs-string">&quot;url(./pianoback.jpg)&quot;</span>;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addChosenDrum</span>(<span class="hljs-params"></span>)</span>&#123;<br>       <span class="hljs-keyword">const</span> chosen =  <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&quot;drum&quot;</span>);<br>       <span class="hljs-keyword">const</span> notChosen = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&quot;piano&quot;</span>);<br>       chosen[<span class="hljs-number">0</span>].classList.add(<span class="hljs-string">&#x27;chosen&#x27;</span>);<br>       notChosen[<span class="hljs-number">0</span>].classList.remove(<span class="hljs-string">&#x27;chosen&#x27;</span>);<br>       <span class="hljs-keyword">const</span> notChosenKit = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;pianoKit&quot;</span>);<br>       notChosenKit.classList.remove(<span class="hljs-string">&#x27;chosen&#x27;</span>);<br>       notChosenKit.style.display = <span class="hljs-string">&quot;none&quot;</span>; <br>       <span class="hljs-keyword">const</span> chosenKit = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;drumKit&quot;</span>);<br>       chosenKit.style.display = <span class="hljs-string">&quot;flex&quot;</span>;<br>       chosenKit.classList.add(<span class="hljs-string">&#x27;chosen&#x27;</span>);<br>       <span class="hljs-comment">// 换鼓壁纸</span><br>       <span class="hljs-keyword">const</span> wallpaper = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;html&quot;</span>);<br>       wallpaper[<span class="hljs-number">0</span>].style.backgroundImage=<span class="hljs-string">&quot;url(./drumback.jpg)&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>2 键盘敲击琴键，用keycode标注，给对应琴键添加.playing类名。设置audio.play发出音效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 点击键盘字母时，对应的键添加class属性</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">playSound</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> audio = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">`.chosen audio[data-key=&quot;<span class="hljs-subst">$&#123;e.keyCode&#125;</span>&quot;]`</span>);<br>    <span class="hljs-comment">// console.log(audio);</span><br>    <span class="hljs-keyword">if</span> (!audio) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">`.chosen div[data-key=&quot;<span class="hljs-subst">$&#123;e.keyCode&#125;</span>&quot;]`</span>);<br>    key.classList.add(<span class="hljs-string">&#x27;playing&#x27;</span>);<span class="hljs-comment">//添加playing类属性</span><br>    audio.currentTime = <span class="hljs-number">0</span>; <span class="hljs-comment">//音频重头播放</span><br><br>    audio.play();<br>&#125;<br></code></pre></td></tr></table></figure><p>3 如果连续敲击多个琴键，多个琴键都会显示过渡特效（黄色Border,放大1.2倍），为了让最后一个琴键之前的琴键过滤样式去掉，可以利用transitionend事件，让已经过渡的琴键去掉.playing类名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 去掉playing 类属性</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeTransition</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (e.propertyName !=<span class="hljs-string">&#x27;transform&#x27;</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">this</span>.classList.remove(<span class="hljs-string">&#x27;playing&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.key&#x27;</span>);<br>keys.forEach(<span class="hljs-function"><span class="hljs-params">key</span>=&gt;</span>key.addEventListener(<span class="hljs-string">&#x27;transitionend&#x27;</span>,removeTransition));<br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;keydown&#x27;</span>,playSound);<br><br></code></pre></td></tr></table></figure><p>4 鼠标点击也可以实现琴键发出音效。设置onclick事件，传入keycode参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickPlaySound</span>(<span class="hljs-params">keycode</span>)</span>&#123;<br>       <span class="hljs-comment">// data-key=keycode;</span><br>       <span class="hljs-keyword">const</span> audio = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">`.chosen audio[data-key=&quot;<span class="hljs-subst">$&#123;keycode&#125;</span>&quot;]`</span>);<br>       <span class="hljs-keyword">if</span> (!audio) <span class="hljs-keyword">return</span>;<br>       <span class="hljs-keyword">const</span> key = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">`.chosen div[data-key=&quot;<span class="hljs-subst">$&#123;keycode&#125;</span>&quot;]`</span>);<br>       key.classList.add(<span class="hljs-string">&#x27;playing&#x27;</span>);<span class="hljs-comment">//添加playing类属性</span><br>       audio.currentTime = <span class="hljs-number">0</span>; <span class="hljs-comment">//音频重头播放</span><br>       audio.play();<br>       <span class="hljs-comment">// console.log(audio);</span><br>   &#125;;<br><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完整代码放在了<a href="https://github.com/janice143/musicKit.github.io.git">Github</a>上，如果读者有兴趣，不妨试一试。</p>]]></content>
    
    
    <categories>
      
      <category>30个原生javascript项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原生javascript项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用python实现清理重复图片</title>
    <link href="/myblog.github.io/2021/09/02/%E5%88%A9%E7%94%A8python%E5%AE%9E%E7%8E%B0%E6%B8%85%E7%90%86%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87/"/>
    <url>/myblog.github.io/2021/09/02/%E5%88%A9%E7%94%A8python%E5%AE%9E%E7%8E%B0%E6%B8%85%E7%90%86%E9%87%8D%E5%A4%8D%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文解释如何编写python脚本，实现重复图片清理的功能。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>MD5,Message-Digest Algorithm，信息摘要算法，是一种信息加密算法，可以把任意长度的数据转换为一个长度固定的数据串（通常是16进制的字符串表示）。<br>一个图片文本的本质是一个数据串，所以要想清理重复图片，就是要匹配到相同的数据串的两张图片，使用DM5的目的是将图片的数据串统一，如果两张图片经过MD5算法变换后的数据串相同，<br>则可判断这两种图片重复。</p><p>以计算一个字符串的MD5值为例，代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import hashlib<br><br>md5 = hashlib<span class="hljs-selector-class">.md5</span>()<br>md5<span class="hljs-selector-class">.update</span>(<span class="hljs-string">&#x27;how to use md5 in python hashlib?&#x27;</span><span class="hljs-selector-class">.encode</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(md5.hexdigest()</span></span>)<br></code></pre></td></tr></table></figure><p>计算结果为</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">d26a53750bc40b38b65a5<span class="hljs-number">20292f69306</span><br></code></pre></td></tr></table></figure><p>参考网站：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017686752491744">廖雪峰老师博客中摘要算法简介</a></p><p>本文的脚本的思路如下：<br>1 遍历文件夹下的图片文件<br>2 把图片文件记录到一个字典变量中<br>3 生成所有图片文件的MD5值<br>4 把MD5值存放到一个新的字典变量中<br>5 判断如果已经存放，则该图片为重复图片，删除即可</p><h2 id="选取文件夹，遍历文件夹下所有的文件"><a href="#选取文件夹，遍历文件夹下所有的文件" class="headerlink" title="选取文件夹，遍历文件夹下所有的文件"></a>选取文件夹，遍历文件夹下所有的文件</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">inpath = <span class="hljs-string">&quot;G:/最新/照片/2018-2019年照片备份/2021年&quot;</span><br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">path</span>,dir,filelist <span class="hljs-keyword">in</span> <span class="hljs-built_in">os</span>.walk(inpath):<br>    <span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filelist:<br>        # <span class="hljs-built_in">print</span>(filename)<br>        allfile.append(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">path</span>,filename))<br></code></pre></td></tr></table></figure><h2 id="获取MD5值"><a href="#获取MD5值" class="headerlink" title="获取MD5值"></a>获取MD5值</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">fd = <span class="hljs-keyword">open</span>(file,<span class="hljs-string">&#x27;rb&#x27;</span>)<br>md5 = hashlib.md5()<br>md5.<span class="hljs-keyword">update</span>(fd.<span class="hljs-keyword">read</span>())<br>fd.<span class="hljs-keyword">close</span>()<br><span class="hljs-keyword">return</span> md5.hexdigest()<br><br></code></pre></td></tr></table></figure><h2 id="根据MD5值比较"><a href="#根据MD5值比较" class="headerlink" title="根据MD5值比较"></a>根据MD5值比较</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> photo <span class="hljs-keyword">in</span> allfile:<br>    <span class="hljs-built_in">md5sum</span> = getmd5(photo)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">md5sum</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> md5list:<br>        md5list.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">md5sum</span>)<br>    <span class="hljs-keyword">else</span>:<br>        identicallist.<span class="hljs-built_in">append</span>(photo)<br></code></pre></td></tr></table></figure><h2 id="删除重复照片"><a href="#删除重复照片" class="headerlink" title="删除重复照片"></a>删除重复照片</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> idenPhoto <span class="hljs-keyword">in</span> identicallist:<br>    <span class="hljs-built_in">os</span>.<span class="hljs-built_in">remove</span>(idenPhoto)<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完整代码放在了<a href="https://github.com/janice143/photoClear">Github</a>上，如果读者有兴趣，不妨试一试。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh配置连接github</title>
    <link href="/myblog.github.io/2021/08/20/ssh%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5github/"/>
    <url>/myblog.github.io/2021/08/20/ssh%E9%85%8D%E7%BD%AE%E8%BF%9E%E6%8E%A5github/</url>
    
    <content type="html"><![CDATA[<h3 id="复制代码"><a href="#复制代码" class="headerlink" title="复制代码"></a>复制代码</h3><p>配置身份，不正确会影响贡献度统计</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;A175A174@gmail.com&quot;</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;A175A174&quot;</span><br></code></pre></td></tr></table></figure><h3 id="配置-ssh-链接，一路回车，打开提示目录下-id-rsa-pub"><a href="#配置-ssh-链接，一路回车，打开提示目录下-id-rsa-pub" class="headerlink" title="配置 ssh 链接，一路回车，打开提示目录下 id_rsa.pub"></a>配置 ssh 链接，一路回车，打开提示目录下 id_rsa.pub</h3><p>复制到 <a href="https://github.com/settings/keys">https://github.com/settings/keys</a> 点击 New sshKey，Title 可以不写</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">ssh-keygen -t rsa -C &quot;<span class="hljs-keyword">A</span><span class="hljs-number">175A174</span>@email.com&quot;<br></code></pre></td></tr></table></figure><h3 id="验证-ssh-是否成功"><a href="#验证-ssh-是否成功" class="headerlink" title="验证 ssh 是否成功"></a>验证 ssh 是否成功</h3><p>Hi A175A174! You’ve successfully authenticated, but GitHub does not provide shell access</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ssh -T <span class="hljs-symbol">git@</span>github.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【程序】我是如何建立我的第一个博客网站的？</title>
    <link href="/myblog.github.io/2020/09/11/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%EF%BC%9F/"/>
    <url>/myblog.github.io/2020/09/11/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>我从大二开始喜欢上写程序，也从那开始自学了很多编程语言。当我第一次接触到前端开发的时候，那些由多个不同后缀名组成的项目，让我觉得又新奇（第一次见这种编程语言，太有特色了），同时又恐惧（这么多个编程语言组成，我能学会吗）。</p><p>大二是我人生阶段最迷茫的一段时间，不想上课，不想和人交往。但是我生来好像就有股向上的劲头，即使每天很颓废，也告诫自己做点有用的事情，做点有用的事情。所以我那段时间学了很多编程语言，虽然是迷迷糊糊学了很多语言，走了很多弯路。</p><p>好在我也勉勉强强地学了前端开发，我记得那段时间我先是在网上看了一个教学视频，然后就开始自己动手捣鼓做起了第一个<a href="https://janice143.github.io/thejanicelan/index.html">个人网站</a>，花了一天一夜的时间。</p><p>大三开始我稳定地在实验室跟着一个老师做科研，便没有时间再去学写程序。</p><p>大四基本上是在做创新创业比赛，更没有时间写程序了。</p><p>但是大二以后的整个过程，我总是偶尔地问自己：当初我为何要学写这么多程序？我大二整整一年的时间都花在自学程序上，感觉就这么放弃有点太不值得？自学程序有用吗以后？</p><p>现在我也不知道学的程序有没有用，但是就是因为当初花了一年时间起步，不甘心没有一点收获地戛然而止。所以我，到了大四暑假的末尾，研一马上要开学，要重新拾起我以前学的东西，好好做下去，希望能做出点东西。</p><p>自学编程的时候听到最多、最有用的建议就是要多做实战，而对于前端开发来讲，第一个要做的实战就是建立自己的个人网站，第二个就是建立个人博客。所以在建立好自己的第一个网站，一年后，也就是现在，我开始建个人博客，并且立下不倒的flag，这个网站将会见证我一点一滴的成长（未来我的生活琐事，学习曲线等奖全部记录记录在这里），是我人生中一笔宝贵的财富，我一定会好好经营。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="一、找资料"><a href="#一、找资料" class="headerlink" title="一、找资料"></a>一、找资料</h4><p>一般开始一个新东西，第一步肯定是找资料，毕竟光想是想不出来的。我找的第一个资料就是B站Up主CodeSheep的一个视频<br><u>手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo：</u><a href="https://www.bilibili.com/video/BV1Yb411a7ty">https://www.bilibili.com/video/BV1Yb411a7ty</a></p><p>在看这个视频的过程中，我有很多疑惑（为什么要下载node.js,在cmd下建文件夹是怎么回事等等），所以也会找其他资料<br><u>使用hexo+github搭建免费个人博客详细教程：</u><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a><br><u>hexo5分钟免费搭建个人博客教程：</u><a href="https://www.jianshu.com/p/722fe57ef163">https://www.jianshu.com/p/722fe57ef163</a></p><p>结合视频，以及文本资料，我的很多疑惑都消除了，接下来我便可以自己动手尝试了。</p><h4 id="二、下载软件，准备环境"><a href="#二、下载软件，准备环境" class="headerlink" title="二、下载软件，准备环境"></a>二、下载软件，准备环境</h4><p>1.安装好<a href="http://nodejs.cn/download/">node.js</a>（最好下载Windows 安装包 (.msi)，在安装过程中会配置好路径，用zip文件还要自己手动配置，特别容易报错） 和 <a href="https://git-scm.com/download/">Git</a></p><p>2.在das窗口下输入命令 <code>node -v</code>和 <code>npm -v</code>，检验hexo运行环境</p><p>3.git安装完成后的检验操作是：鼠标右键。会出现git GUI here 和git bash here</p><h4 id="三、使用hexo框架搭建静态博客"><a href="#三、使用hexo框架搭建静态博客" class="headerlink" title="三、使用hexo框架搭建静态博客"></a>三、使用hexo框架搭建静态博客</h4><p>1.安装 hexo 框架</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><p>2.在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>E:\程序\html_codes\janiceBlog</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p><p>3.cmd窗口下切换到janiceBlog文件夹路径，然后输入一下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span> <span class="hljs-meta"># 初始化</span><br></code></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> g <span class="hljs-comment"># 生成</span><br>hexo s <span class="hljs-comment"># 启动服务</span><br></code></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。hexo s是开启本地预览服务，打开浏览器访问<a href="http://localhost:4000/">http://localhost:4000</a>即可看到内容</p><p>4.修改主题<br>可以再官网选一个好看的<a href="https://hexo.io/themes/">主题</a><br>以yilia主题为例，在博客路径下，输入一下命令:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/litten/</span>hexo-theme-yilia.git themes/yilia<br></code></pre></td></tr></table></figure><p>修改_config.yml中的<code>theme: landscape</code>改为<code>theme: yilia</code>，然后重新执行<code>hexo g</code>来重新生成。</p><p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布</p><h4 id="四、上传到github"><a href="#四、上传到github" class="headerlink" title="四、上传到github"></a>四、上传到github</h4><p>1.配置_config.yml中有关deploy的部分：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git   <br><span class="hljs-symbol">  repository:</span> git@github.com:janice143/iainsBlog.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>2.打开博客文件夹，右键选择git bash here，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会(部署这个命令一定要用git bash,不要在cmd下，不然会报错)</p><h4 id="五、上传到GitHub出现一些错误"><a href="#五、上传到GitHub出现一些错误" class="headerlink" title="五、上传到GitHub出现一些错误"></a>五、上传到GitHub出现一些错误</h4><p><u>错误1： hexo + github pages搭建博客，本地server成功，部署到github上之后样式加载不出来</u><br>解决：<br>需要修改根目录_config.yml文件中的url地址和根目录</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment">##If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><br><span class="hljs-symbol">url:</span> <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/janice143.github.io/myblog</span>.github.io/<br><span class="hljs-symbol">root:</span> /myblog.github.io<br><span class="hljs-symbol">permalink:</span> <span class="hljs-symbol">:year/</span><span class="hljs-symbol">:month/</span><span class="hljs-symbol">:day/</span><span class="hljs-symbol">:title</span>.html<br><span class="hljs-symbol">permalink_defaults:</span><br></code></pre></td></tr></table></figure><p>url 是GitHub pages给我们分配的网址<br>root是搭建该博客的仓库名</p><p>最后重新部署上传就可以了</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p><u>错误2：修改默认头像</u><br>解决：<br>在主题的yilia文件夹的img文件夹里放上头像图片，然后修改yilia文件夹下的_config.yml文件</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#你的头像url</span><br><span class="hljs-symbol">avatar:</span> /myblog.github.io<span class="hljs-meta-keyword">/img/</span>me.JPG<br></code></pre></td></tr></table></figure><h4 id="六、写博客"><a href="#六、写博客" class="headerlink" title="六、写博客"></a>六、写博客</h4><p>1.定位到我们的博客目录，执行命令：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type"></span>“博客名自己取”<br></code></pre></td></tr></table></figure><p>2.markdown格式编写规则参考：<a href="http://www.mdeditor.com/">http://www.mdeditor.com/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
